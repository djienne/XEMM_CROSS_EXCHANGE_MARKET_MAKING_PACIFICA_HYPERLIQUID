================================================================================
RUST SOURCE CODE COLLECTION
Generated: 2025-11-26 23:37:02
Total files: 69
================================================================================


================================================================================
FILE: examples\advanced_usage.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\advanced_usage.rs
================================================================================

use xemm_rust::connector::pacifica::{OrderbookClient, OrderbookConfig};
use std::sync::{Arc, Mutex};
use std::collections::VecDeque;
use tracing::{info, warn};
use tokio::time::Duration;

/// Example showing advanced usage with price tracking and statistics
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    info!("Starting Advanced Pacifica Orderbook Client Example");

    // Shared state for tracking prices
    let price_history = Arc::new(Mutex::new(PriceTracker::new(100)));
    let history_clone = price_history.clone();

    // Configure client
    let config = OrderbookConfig {
        symbol: "BTC".to_string(),
        agg_level: 1,
        reconnect_attempts: 5,
        ping_interval_secs: 30,
    };

    let mut client = OrderbookClient::new(config)?;

    // Spawn a task to print statistics every 10 seconds
    let stats_history = price_history.clone();
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(10));
        loop {
            interval.tick().await;
            let tracker = stats_history.lock().unwrap();
            tracker.print_statistics();
        }
    });

    // Start client with callback
    client.start(move |best_bid, best_ask, symbol, timestamp| {
        let bid_price: f64 = best_bid.parse().unwrap_or(0.0);
        let ask_price: f64 = best_ask.parse().unwrap_or(0.0);
        let mid_price = (bid_price + ask_price) / 2.0;
        let spread = ask_price - bid_price;
        let spread_bps = if bid_price > 0.0 {
            (spread / bid_price) * 10000.0
        } else {
            0.0
        };

        // Update price history
        {
            let mut tracker = history_clone.lock().unwrap();
            tracker.add_update(bid_price, ask_price, mid_price, spread_bps, timestamp);
        }

        info!(
            "{} | Bid: ${:.2} | Ask: ${:.2} | Mid: ${:.2} | Spread: {:.2} bps",
            symbol, bid_price, ask_price, mid_price, spread_bps
        );
    }).await?;

    Ok(())
}

/// Structure to track price updates and calculate statistics
struct PriceTracker {
    max_size: usize,
    updates: VecDeque<PriceUpdate>,
}

struct PriceUpdate {
    bid: f64,
    ask: f64,
    mid: f64,
    spread_bps: f64,
    timestamp: u64,
}

impl PriceTracker {
    fn new(max_size: usize) -> Self {
        Self {
            max_size,
            updates: VecDeque::with_capacity(max_size),
        }
    }

    fn add_update(&mut self, bid: f64, ask: f64, mid: f64, spread_bps: f64, timestamp: u64) {
        if self.updates.len() >= self.max_size {
            self.updates.pop_front();
        }

        self.updates.push_back(PriceUpdate {
            bid,
            ask,
            mid,
            spread_bps,
            timestamp,
        });
    }

    fn print_statistics(&self) {
        if self.updates.is_empty() {
            warn!("No price updates yet");
            return;
        }

        let count = self.updates.len();
        let avg_mid: f64 = self.updates.iter().map(|u| u.mid).sum::<f64>() / count as f64;
        let avg_spread: f64 = self.updates.iter().map(|u| u.spread_bps).sum::<f64>() / count as f64;

        let min_mid = self.updates.iter().map(|u| u.mid).fold(f64::INFINITY, f64::min);
        let max_mid = self.updates.iter().map(|u| u.mid).fold(f64::NEG_INFINITY, f64::max);

        let min_spread = self.updates.iter().map(|u| u.spread_bps).fold(f64::INFINITY, f64::min);
        let max_spread = self.updates.iter().map(|u| u.spread_bps).fold(f64::NEG_INFINITY, f64::max);

        info!("=== Statistics (last {} updates) ===", count);
        info!("Mid Price  -> Avg: ${:.2} | Min: ${:.2} | Max: ${:.2}", avg_mid, min_mid, max_mid);
        info!("Spread     -> Avg: {:.2} bps | Min: {:.2} bps | Max: {:.2} bps", avg_spread, min_spread, max_spread);
        info!("========================================");
    }
}


================================================================================
FILE: examples\cancel_all_test.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\cancel_all_test.rs
================================================================================

use anyhow::{Context, Result};
use tracing::{error, info};
use xemm_rust::config::Config;
use xemm_rust::connector::pacifica::{OrderSide, PacificaCredentials, PacificaTrading};

/// Test the cancel_all_orders functionality
///
/// This test will:
/// 1. Place 2-3 limit orders on Pacifica
/// 2. Use cancel_all_orders to cancel them
/// 3. Verify that all orders are cancelled
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    info!("═══════════════════════════════════════════════════");
    info!("  Cancel All Orders Test");
    info!("═══════════════════════════════════════════════════");
    info!("");

    // Load configuration
    let config = Config::load_default().context("Failed to load config.json")?;

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials from environment")?;

    // Create trading client
    let mut trading = PacificaTrading::new(credentials.clone());
    info!("[TEST] Trading client initialized");

    // Get market info
    let market_info = trading
        .get_market_info()
        .await
        .context("Failed to fetch market info")?;

    let symbol_info = market_info
        .get(&config.symbol)
        .with_context(|| format!("Symbol {} not found", config.symbol))?;

    let tick_size: f64 = symbol_info
        .tick_size
        .parse()
        .context("Failed to parse tick size")?;

    info!(
        "[TEST] Using symbol: {} (tick size: {})",
        config.symbol, tick_size
    );
    info!("");

    // Step 1: Cancel any existing orders first
    info!("[STEP 1] Cancelling any existing orders...");
    match trading
        .cancel_all_orders(false, Some(&config.symbol), false)
        .await
    {
        Ok(count) => info!("[STEP 1] ✓ Cancelled {} existing order(s)", count),
        Err(e) => error!("[STEP 1] Failed to cancel existing orders: {}", e),
    }
    info!("");

    // Step 2: Place a few test orders
    info!("[STEP 2] Placing 3 test limit orders...");

    // Get a reference price (we'll use a price far from market to avoid fills)
    // Orders must be at least $10 notional
    let far_price_buy = 100.0; // Very low price for buy order
    let far_price_sell = 300.0; // Very high price for sell order

    // Place 2 BUY orders with $10+ notional (0.1 SOL @ $100 = $10)
    for i in 1..=2 {
        let price = far_price_buy + (i as f64 * tick_size);
        let size = 0.11; // 0.11 * $100 = $11 (above $10 minimum)

        match trading
            .place_limit_order(
                &config.symbol,
                OrderSide::Buy,
                size,
                Some(price),
                0.0,
                None,
                None,
            )
            .await
        {
            Ok(order_data) => {
                info!(
                    "[STEP 2] ✓ Placed BUY order {}: ID={:?}, cloid={:?}",
                    i, order_data.order_id, order_data.client_order_id
                );
            }
            Err(e) => {
                error!("[STEP 2] Failed to place BUY order {}: {}", i, e);
            }
        }
    }

    // Place 1 SELL order with $10+ notional (0.04 SOL @ $300 = $12)
    let size = 0.04; // 0.04 * $300 = $12 (above $10 minimum)
    match trading
        .place_limit_order(
            &config.symbol,
            OrderSide::Sell,
            size,
            Some(far_price_sell),
            0.0,
            None,
            None,
        )
        .await
    {
        Ok(order_data) => {
            info!(
                "[STEP 2] ✓ Placed SELL order: ID={:?}, cloid={:?}",
                order_data.order_id, order_data.client_order_id
            );
        }
        Err(e) => {
            error!("[STEP 2] Failed to place SELL order: {}", e);
        }
    }

    info!("[STEP 2] All test orders placed");
    info!("");

    // Wait a bit for orders to be registered
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    // Step 3: Cancel all orders for the symbol
    info!("[STEP 3] Cancelling all orders for {}...", config.symbol);
    match trading
        .cancel_all_orders(false, Some(&config.symbol), false)
        .await
    {
        Ok(count) => {
            info!(
                "[STEP 3] ✓ Successfully cancelled {} order(s)",
                count
            );
            if count >= 3 {
                info!("[TEST] ✓✓✓ TEST PASSED - All orders were cancelled!");
            } else {
                error!(
                    "[TEST] ✗✗✗ TEST FAILED - Expected to cancel 3 orders, but cancelled {}",
                    count
                );
            }
        }
        Err(e) => {
            error!("[STEP 3] ✗ Failed to cancel all orders: {}", e);
            error!("[TEST] ✗✗✗ TEST FAILED - Could not cancel orders");
        }
    }

    info!("");
    info!("═══════════════════════════════════════════════════");
    info!("  Test Complete");
    info!("═══════════════════════════════════════════════════");

    Ok(())
}


================================================================================
FILE: examples\check_hyperliquid_symbols.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\check_hyperliquid_symbols.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("Loading Hyperliquid credentials...");
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    println!("Creating Hyperliquid client...");
    let trading = HyperliquidTrading::new(credentials, false)?;

    println!("\nFetching available symbols from Hyperliquid...\n");
    let meta = trading.get_meta().await?;

    println!("Found {} available symbols:\n", meta.universe.len());

    // Search for ENA
    let ena_found = meta.universe.iter().any(|asset| asset.name == "ENA");

    if ena_found {
        println!("✓ ENA is available on Hyperliquid");
    } else {
        println!("✗ ENA is NOT available on Hyperliquid");
        println!("\nSearching for similar symbols...");

        let similar: Vec<_> = meta.universe.iter()
            .filter(|asset| asset.name.contains("EN") || asset.name.starts_with("E"))
            .map(|asset| &asset.name)
            .collect();

        if !similar.is_empty() {
            println!("Similar symbols found: {:?}", similar);
        }
    }

    println!("\n--- All Available Symbols ---");
    for (i, asset) in meta.universe.iter().enumerate() {
        print!("{:8}", asset.name);
        if (i + 1) % 8 == 0 {
            println!();
        }
    }
    println!("\n");

    // Check specific symbols
    let test_symbols = vec!["BTC", "ETH", "SOL", "XPL", "ENA"];
    println!("--- Checking Specific Symbols ---");
    for symbol in test_symbols {
        let found = meta.universe.iter().any(|asset| asset.name == symbol);
        if found {
            println!("✓ {} is available", symbol);
        } else {
            println!("✗ {} is NOT available", symbol);
        }
    }

    Ok(())
}


================================================================================
FILE: examples\check_positions_debug.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\check_positions_debug.rs
================================================================================

/// Debug Position Checker - Shows raw API response
///
/// This utility fetches and displays the raw position data from Hyperliquid
/// to debug what values we're actually getting.

use anyhow::{Context, Result};
use std::env;

use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("=== Position Debug Checker ===\n");

    // Load credentials
    dotenv::dotenv().ok();
    let hl_credentials = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;
    let hl_wallet = env::var("HL_WALLET")
        .context("HL_WALLET environment variable not set")?;

    println!("Wallet: {}\n", hl_wallet);

    // Initialize trading client
    let hl_trading = HyperliquidTrading::new(hl_credentials, false)
        .context("Failed to create Hyperliquid trading client")?;

    // Fetch user state
    let user_state = hl_trading.get_user_state(&hl_wallet).await
        .context("Failed to fetch user state")?;

    println!("Found {} position(s)\n", user_state.asset_positions.len());

    for asset_pos in &user_state.asset_positions {
        let pos = &asset_pos.position;

        println!("─────────────────────────────────────────");
        println!("Symbol: {}", pos.coin);
        println!("Raw szi: {}", pos.szi);
        println!("Raw positionValue: {}", pos.position_value);
        println!("Raw unrealizedPnl: {}", pos.unrealized_pnl);
        println!("Raw marginUsed: {}", pos.margin_used);
        println!("Entry price: {:?}", pos.entry_px);
        println!("Leverage type: {}", pos.leverage.type_);
        println!("Leverage value: {}", pos.leverage.value);

        // Parse values
        let szi: f64 = pos.szi.parse().unwrap_or(0.0);
        let position_value: f64 = pos.position_value.parse().unwrap_or(0.0);
        let entry_px: f64 = pos.entry_px.as_ref().and_then(|s| s.parse().ok()).unwrap_or(0.0);

        println!("\nParsed values:");
        println!("  szi (signed size): {}", szi);
        println!("  position_value: {}", position_value);
        println!("  entry_px: {}", entry_px);

        // Calculate notional properly
        let abs_size = szi.abs();
        let calculated_notional = abs_size * entry_px;

        println!("\nCalculations:");
        println!("  abs(szi) * entry_px = {} * {} = ${:.2}", abs_size, entry_px, calculated_notional);
        println!("  position_value (from API) = ${:.2}", position_value.abs());
        println!("  Difference: ${:.2}", (position_value.abs() - calculated_notional).abs());
        println!();
    }

    println!("\n=== Cross Margin Summary ===");
    println!("Account Value: {}", user_state.cross_margin_summary.account_value);
    println!("Total Margin Used: {}", user_state.cross_margin_summary.total_margin_used);
    println!("Total Ntl Pos: {}", user_state.cross_margin_summary.total_ntl_pos);
    println!("Total Raw USD: {}", user_state.cross_margin_summary.total_raw_usd);

    Ok(())
}


================================================================================
FILE: examples\close_ena_position.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\close_ena_position.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("Closing ENA short position...");
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    let mut trading = HyperliquidTrading::new(credentials, false)?;

    // Close short position: BUY 50 ENA with 10% slippage
    // NOTE: reduce_only should NEVER be used on Hyperliquid
    let result = trading
        .place_market_order(
            "ENA",
            true,          // is_buy = true (closes short)
            50.0,          // size
            0.10,          // 10% slippage (higher to ensure fill)
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(0.39),    // bid
            Some(0.40),    // ask (manually set to avoid rounding issues)
        )
        .await?;

    println!("Result: {:?}", result);
    Ok(())
}


================================================================================
FILE: examples\debug_msgpack.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\debug_msgpack.rs
================================================================================

use serde_json::json;
use xemm_rust::connector::hyperliquid::types::*;

fn main() -> anyhow::Result<()> {
    // Create a simple order action
    let order = Order {
        a: 4,  // Asset ID
        b: true,  // Is buy
        p: "1100".to_string(),  // Price
        s: "0.2".to_string(),  // Size
        r: false,  // Reduce only
        t: OrderType {
            limit: LimitOrderType {
                tif: TimeInForce::Gtc,
            },
        },
        c: None,  // No client order ID
    };

    let action = Action {
        type_: "order".to_string(),
        orders: vec![order],
        grouping: "na".to_string(),
    };

    // Encode with msgpack (using named encoding)
    let msgpack_bytes_named = rmp_serde::encode::to_vec_named(&action)?;
    let msgpack_bytes_compact = rmp_serde::to_vec(&action)?;

    println!("=== NAMED ENCODING (correct) ===");
    let msgpack_bytes = msgpack_bytes_named;

    println!("Action JSON:");
    println!("{}", serde_json::to_string_pretty(&action)?);
    println!();
    println!("Msgpack bytes ({} bytes):", msgpack_bytes.len());
    println!("{}", hex::encode(&msgpack_bytes));
    println!();
    println!("Msgpack bytes (debug):");
    for (i, byte) in msgpack_bytes.iter().enumerate() {
        print!("{:02x} ", byte);
        if (i + 1) % 16 == 0 {
            println!();
        }
    }
    println!();
    println!();

    println!("=== COMPACT ENCODING (incorrect - encodes as array) ===");
    println!("Msgpack bytes ({} bytes):", msgpack_bytes_compact.len());
    println!("{}", hex::encode(&msgpack_bytes_compact));
    println!();

    Ok(())
}


================================================================================
FILE: examples\fetch_pump_trades.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\fetch_pump_trades.rs
================================================================================

/// Test script to fetch recent PUMP trades from both exchanges
///
/// This demonstrates the trade history fetching logic used in the bot's
/// profit calculation after a hedge execution.

use anyhow::{Context, Result};
use colored::Colorize;

use xemm_rust::connector::pacifica::{PacificaCredentials, PacificaTrading};
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();

    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  Fetch PUMP Trades Test".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();

    let symbol = "PUMP";

    // Load credentials
    let pacifica_creds = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials")?;
    let hyperliquid_creds = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;

    println!("{} {} Credentials loaded", "✓".green().bold(), "Pacifica");
    println!("{} {} Credentials loaded", "✓".green().bold(), "Hyperliquid");
    println!();

    // Initialize trading clients
    let pacifica_trading = PacificaTrading::new(pacifica_creds.clone());
    let hyperliquid_trading = HyperliquidTrading::new(hyperliquid_creds.clone(), false)?;

    // ═══════════════════════════════════════════════════
    // Fetch Pacifica Trade History
    // ═══════════════════════════════════════════════════

    println!("{}", "─────────────────────────────────────────────────".bright_white());
    println!("{} {}", "[PACIFICA]".magenta().bold(), "Fetching recent trades...");
    println!();

    match pacifica_trading.get_trade_history(Some(symbol), Some(10), None, None).await {
        Ok(trades) => {
            if trades.is_empty() {
                println!("{} No Pacifica trades found for {}", "⚠".yellow().bold(), symbol.bright_white().bold());
            } else {
                println!("{} Found {} Pacifica trade(s)", "✓".green().bold(), trades.len());
                println!();

                for (idx, trade) in trades.iter().enumerate() {
                    let side_colored = if trade.side.to_lowercase() == "buy" || trade.side.to_lowercase() == "bid" {
                        trade.side.green()
                    } else {
                        trade.side.red()
                    };

                    println!("  Trade #{}", idx + 1);
                    println!("    Symbol:           {}", trade.symbol.bright_white().bold());
                    println!("    Side:             {}", side_colored);
                    println!("    Price:            {}", format!("${}", trade.entry_price).cyan());
                    println!("    Amount:           {}", trade.amount.bright_white());
                    println!("    Fee:              {}", format!("${}", trade.fee).yellow());
                    println!("    Client Order ID:  {}...{}",
                        &trade.client_order_id[..8],
                        &trade.client_order_id[trade.client_order_id.len()-4..]
                    );

                    // Convert timestamp to readable format
                    let dt = chrono::DateTime::from_timestamp_millis(trade.created_at as i64);
                    let time_str = dt.map(|d| d.format("%Y-%m-%d %H:%M:%S UTC").to_string())
                        .unwrap_or_else(|| trade.created_at.to_string());
                    println!("    Time:             {}", time_str);
                    println!();
                }

                // Show most recent trade details
                if let Some(latest) = trades.first() {
                    println!("{}", "Most Recent Pacifica Trade:".bright_yellow().bold());

                    let price: f64 = latest.entry_price.parse().unwrap_or(0.0);
                    let amount: f64 = latest.amount.parse().unwrap_or(0.0);
                    let fee: f64 = latest.fee.parse().unwrap_or(0.0);
                    let notional = price * amount;
                    let fee_bps = if notional > 0.0 { (fee / notional) * 10000.0 } else { 0.0 };

                    println!("  Price:    {} (${:.6})", format!("${}", latest.entry_price).cyan().bold(), price);
                    println!("  Amount:   {} {}", latest.amount.bright_white().bold(), symbol);
                    println!("  Notional: {}", format!("${:.4}", notional).bright_white());
                    println!("  Fee:      {} ({:.2} bps)", format!("${:.6}", fee).yellow().bold(), fee_bps);
                }
            }
        }
        Err(e) => {
            println!("{} Failed to fetch Pacifica trades: {}", "✗".red().bold(), e);
        }
    }

    println!();

    // ═══════════════════════════════════════════════════
    // Fetch Hyperliquid User Fills
    // ═══════════════════════════════════════════════════

    println!("{}", "─────────────────────────────────────────────────".bright_white());
    println!("{} {}", "[HYPERLIQUID]".magenta().bold(), "Fetching recent fills...");
    println!();

    let hl_wallet = std::env::var("HL_WALLET").unwrap_or_default();

    match hyperliquid_trading.get_user_fills(&hl_wallet, true).await {
        Ok(fills) => {
            // Filter to PUMP symbol
            let pump_fills: Vec<_> = fills.iter()
                .filter(|f| f.coin == symbol)
                .take(10)
                .collect();

            if pump_fills.is_empty() {
                println!("{} No Hyperliquid fills found for {}", "⚠".yellow().bold(), symbol.bright_white().bold());
            } else {
                println!("{} Found {} Hyperliquid fill(s) for {}",
                    "✓".green().bold(),
                    pump_fills.len(),
                    symbol.bright_white().bold()
                );
                println!();

                for (idx, fill) in pump_fills.iter().enumerate() {
                    let side_colored = if fill.side.to_lowercase() == "b" {
                        "BUY".green()
                    } else {
                        "SELL".red()
                    };

                    // Convert timestamp to readable format
                    let timestamp_ms = fill.time;
                    let dt = chrono::DateTime::from_timestamp_millis(timestamp_ms as i64);
                    let time_str = dt.map(|d| d.format("%Y-%m-%d %H:%M:%S UTC").to_string())
                        .unwrap_or_else(|| timestamp_ms.to_string());

                    println!("  Fill #{}", idx + 1);
                    println!("    Coin:     {}", fill.coin.bright_white().bold());
                    println!("    Side:     {}", side_colored);
                    println!("    Price:    {}", format!("${}", fill.px).cyan());
                    println!("    Size:     {}", fill.sz.bright_white());
                    println!("    Fee:      {}", format!("${}", fill.fee).yellow());
                    println!("    Time:     {}", time_str);
                    println!();
                }

                // Show most recent fill details
                if let Some(latest) = pump_fills.first() {
                    println!("{}", "Most Recent Hyperliquid Fill:".bright_yellow().bold());

                    let price: f64 = latest.px.parse().unwrap_or(0.0);
                    let size: f64 = latest.sz.parse().unwrap_or(0.0);
                    let fee: f64 = latest.fee.parse().unwrap_or(0.0);
                    let notional = price * size;
                    let fee_bps = if notional > 0.0 { (fee / notional) * 10000.0 } else { 0.0 };

                    println!("  Price:    {} (${:.6})", format!("${}", latest.px).cyan().bold(), price);
                    println!("  Size:     {} {}", latest.sz.bright_white().bold(), symbol);
                    println!("  Notional: {}", format!("${:.4}", notional).bright_white());
                    println!("  Fee:      {} ({:.2} bps)", format!("${:.6}", fee).yellow().bold(), fee_bps);

                    // Calculate time since fill
                    let now = chrono::Utc::now().timestamp_millis() as u64;
                    let age_ms = now.saturating_sub(latest.time);
                    let age_secs = age_ms as f64 / 1000.0;
                    println!("  Age:      {:.1} seconds ago", age_secs);
                }
            }
        }
        Err(e) => {
            println!("{} Failed to fetch Hyperliquid fills: {}", "✗".red().bold(), e);
        }
    }

    println!();
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());

    Ok(())
}


================================================================================
FILE: examples\fetch_recent_trades.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\fetch_recent_trades.rs
================================================================================

/// Test script to fetch recent trades from both exchanges
///
/// This uses the EXACT SAME trade fetching logic as the bot's profit calculation.
/// Run with: cargo run --example fetch_recent_trades --release [SYMBOL]
///
/// Examples:
///   cargo run --example fetch_recent_trades --release PUMP
///   cargo run --example fetch_recent_trades --release ENA
///   cargo run --example fetch_recent_trades --release BTC

use anyhow::{Context, Result};
use colored::Colorize;
use std::sync::Arc;
use tokio::sync::Mutex;

use xemm_rust::connector::pacifica::{PacificaCredentials, PacificaTrading};
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};
use xemm_rust::trade_fetcher;

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();

    let args: Vec<String> = std::env::args().collect();
    let symbol = if args.len() > 1 {
        &args[1]
    } else {
        println!("{}", "Usage: cargo run --example fetch_recent_trades --release [SYMBOL]".yellow());
        println!("Defaulting to PUMP symbol...\n");
        "PUMP"
    };

    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", format!("  Fetch {} Trades Test", symbol).bright_cyan().bold());
    println!("{}", "  Using BOT's Profit Calculation Logic".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();

    // Load credentials
    let pacifica_creds = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials")?;
    let hyperliquid_creds = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;

    println!("{} {} Credentials loaded", "✓".green().bold(), "Pacifica");
    println!("{} {} Credentials loaded", "✓".green().bold(), "Hyperliquid");
    println!();

    // Initialize trading clients
    let pacifica_trading = Arc::new(Mutex::new(PacificaTrading::new(pacifica_creds.clone())));
    let hyperliquid_trading = HyperliquidTrading::new(hyperliquid_creds.clone(), false)?;

    // ═══════════════════════════════════════════════════
    // First, get the most recent client_order_id for this symbol
    // ═══════════════════════════════════════════════════

    println!("{}", "─────────────────────────────────────────────────".bright_white());
    println!("{} {}", "[PACIFICA]".magenta().bold(), "Finding most recent trade...");
    println!();

    let (client_order_id, pacifica_timestamp) = match pacifica_trading.lock().await.get_trade_history(Some(symbol), Some(5), None, None).await {
        Ok(trades) => {
            if trades.is_empty() {
                println!("{} No Pacifica trades found for {}", "⚠".yellow().bold(), symbol.bright_white().bold());
                println!("Cannot proceed without a recent trade. Try running the bot first.");
                return Ok(());
            }

            let most_recent = &trades[0];
            println!("{} Found most recent trade:", "✓".green().bold());
            println!("  Client Order ID: {}...{}",
                &most_recent.client_order_id[..8],
                &most_recent.client_order_id[most_recent.client_order_id.len()-4..]
            );
            println!("  Price:           {}", format!("${}", most_recent.entry_price).cyan());
            println!("  Amount:          {} {}", most_recent.amount.bright_white(), symbol);
            println!("  Fee:             {}", format!("${}", most_recent.fee).yellow());

            let dt = chrono::DateTime::from_timestamp_millis(most_recent.created_at as i64);
            let time_str = dt.map(|d| d.format("%Y-%m-%d %H:%M:%S UTC").to_string())
                .unwrap_or_else(|| most_recent.created_at.to_string());
            println!("  Time:            {}", time_str);
            println!();

            (most_recent.client_order_id.clone(), most_recent.created_at)
        }
        Err(e) => {
            println!("{} Failed to fetch Pacifica trades: {}", "✗".red().bold(), e);
            return Ok(());
        }
    };

    // ═══════════════════════════════════════════════════
    // Test Pacifica Trade Fetcher (BOT LOGIC)
    // ═══════════════════════════════════════════════════

    println!("{}", "─────────────────────────────────────────────────".bright_white());
    println!("{} {}", "[TEST PACIFICA FETCHER]".magenta().bold(), "Using bot's fetch logic...");
    println!();

    let pac_result = trade_fetcher::fetch_pacifica_trade(
        pacifica_trading.clone(),
        symbol,
        &client_order_id,
        3, // max_attempts
        |msg| println!("  {}", msg),
    ).await;

    // Show details of matched Pacifica fills (MAKER ONLY)
    if let Ok(trades) = pacifica_trading.lock().await.get_trade_history(Some(symbol), Some(20), None, None).await {
        // First, show ALL fills with this client_order_id for debugging
        let all_matching: Vec<_> = trades.iter()
            .filter(|t| &t.client_order_id == &client_order_id)
            .collect();

        if !all_matching.is_empty() {
            println!();
            println!("  {} ALL fills with this client_order_id (before maker filter):", "DEBUG:".bright_black());
            for (i, trade) in all_matching.iter().enumerate() {
                println!("  {}   Fill {}: {} {} @ ${} - {} - {}",
                    "DEBUG:".bright_black(),
                    i + 1,
                    trade.amount,
                    symbol,
                    trade.entry_price,
                    trade.event_type.to_uppercase(),
                    trade.side
                );
            }
        }

        // Now filter to only MAKER fills
        let matching_trades: Vec<_> = trades.iter()
            .filter(|t| {
                &t.client_order_id == &client_order_id &&
                t.event_type == "fulfill_maker"
            })
            .collect();

        if !matching_trades.is_empty() {
            println!();
            println!("  {} Pacifica fills breakdown (MAKER ONLY):", "DETAIL:".bright_blue());

            let mut total_notional = 0.0;
            let mut total_size = 0.0;

            for (i, trade) in matching_trades.iter().enumerate() {
                let dt = chrono::DateTime::from_timestamp_millis(trade.created_at as i64);
                let time_str = dt.map(|d| d.format("%H:%M:%S UTC").to_string())
                    .unwrap_or_else(|| trade.created_at.to_string());

                // Parse values from API
                let price_f64 = trade.entry_price.parse::<f64>().unwrap_or(0.0);
                let size_f64 = trade.amount.parse::<f64>().unwrap_or(0.0);
                let notional = price_f64 * size_f64;

                total_notional += notional;
                total_size += size_f64;

                println!("  {}   Fill {}: amount=\"{}\" ({})",
                    "✓".green(),
                    i + 1,
                    trade.amount,         // RAW amount string from API
                    size_f64
                );
                println!("  {}           entry_price=\"{}\" (${:.15})",
                    "✓".green(),
                    trade.entry_price,    // RAW entry_price string from API
                    price_f64
                );
                println!("  {}           notional = {} × {:.15} = ${:.15}",
                    "✓".green(),
                    size_f64,
                    price_f64,
                    notional
                );
                println!("  {}           side={}, event_type={}, fee={} ({})",
                    "✓".green(),
                    trade.side,
                    trade.event_type,
                    trade.fee,
                    time_str
                );
            }

            let manual_weighted_avg = if total_size > 0.0 {
                total_notional / total_size
            } else {
                0.0
            };

            println!();
            println!("  {} Weighted Average Calculation:", "VERIFY:".bright_magenta());
            println!("  {} Total Notional: ${:.8}", "VERIFY:".bright_magenta(), total_notional);
            println!("  {} Total Size: {}", "VERIFY:".bright_magenta(), total_size);
            println!("  {} Weighted Avg: ${:.8}", "VERIFY:".bright_magenta(), manual_weighted_avg);
        }
    }

    println!();
    println!("{}", "Pacifica Fetch Result:".bright_yellow().bold());
    match (pac_result.fill_price, pac_result.actual_fee, pac_result.total_size) {
        (Some(price), Some(fee), Some(size)) => {
            println!("  Fill Price: {} (${:.6})", format!("${}", price).cyan().bold(), price);
            println!("  Actual Fee: {} (${:.6})", format!("${}", fee).yellow().bold(), fee);
            println!("  Total Size: {} {}", size.to_string().bright_white(), symbol);

            let notional = price * size;
            let fee_bps = (fee / notional) * 10000.0;
            println!("  Fee Rate:   {:.2} bps", fee_bps);
        }
        (Some(price), Some(fee), None) => {
            println!("  Fill Price: {} (${:.6})", format!("${}", price).cyan().bold(), price);
            println!("  Actual Fee: {} (${:.6})", format!("${}", fee).yellow().bold(), fee);
            println!("  Total Size: {} (not available)", "N/A".yellow());
        }
        (Some(price), None, _) => {
            println!("  Fill Price: {} (${:.6})", format!("${}", price).cyan().bold(), price);
            println!("  Actual Fee: {} (not found)", "N/A".yellow());
        }
        (None, _, _) => {
            println!("  {} No trade data retrieved", "✗".red().bold());
        }
    }

    println!();

    // ═══════════════════════════════════════════════════
    // Test Hyperliquid Fills Fetcher (BOT LOGIC)
    // ═══════════════════════════════════════════════════

    println!("{}", "─────────────────────────────────────────────────".bright_white());
    println!("{} {}", "[TEST HYPERLIQUID FETCHER]".magenta().bold(), "Using bot's fetch logic...");
    println!();

    let hl_wallet = std::env::var("HL_WALLET").unwrap_or_default();

    // Fetch Hyperliquid fills and filter by timestamp proximity to Pacifica trade
    let pac_dt = chrono::DateTime::from_timestamp_millis(pacifica_timestamp as i64);
    let pac_time_str = pac_dt.map(|d| d.format("%Y-%m-%d %H:%M:%S UTC").to_string())
        .unwrap_or_else(|| pacifica_timestamp.to_string());

    println!("  {} Retrieving Hyperliquid fills...", "INFO:".bright_blue());
    println!("  {} Pacifica trade timestamp: {} ({})",
        "INFO:".bright_blue(),
        pac_time_str,
        pacifica_timestamp
    );
    println!("  {} Matching fills within ±10 seconds of this time", "INFO:".bright_blue());
    println!();

    let hl_result = match hyperliquid_trading.get_user_fills(&hl_wallet, true).await {
        Ok(all_fills) => {
            println!("  {} Retrieved {} total fill(s)", "DEBUG:".bright_black(), all_fills.len());

            // Filter fills by symbol AND timestamp proximity (±10 seconds)
            let time_window_ms = 10000u64; // ±10 seconds
            let matching_fills: Vec<_> = all_fills.iter()
                .filter(|f| {
                    f.coin == symbol &&
                    (f.time as i64 - pacifica_timestamp as i64).abs() < time_window_ms as i64
                })
                .collect();

            if !matching_fills.is_empty() {
                println!("  {} Found {} matching Hyperliquid fill(s) within ±10s", "✓".green().bold(), matching_fills.len());

                // Show matched fills with details
                for (i, fill) in matching_fills.iter().enumerate() {
                    let dt = chrono::DateTime::from_timestamp_millis(fill.time as i64);
                    let time_str = dt.map(|d| d.format("%Y-%m-%d %H:%M:%S UTC").to_string())
                        .unwrap_or_else(|| fill.time.to_string());
                    let time_diff = (fill.time as i64 - pacifica_timestamp as i64) as f64 / 1000.0;
                    println!("  {}   Fill {}: {} {} @ ${} - Fee: ${} ({}, {:+.1}s)",
                        "✓".green(),
                        i + 1,
                        fill.sz,
                        symbol,
                        fill.px,
                        fill.fee,
                        time_str,
                        time_diff
                    );
                }

                // Calculate result from matching fills
                trade_fetcher::calculate_hyperliquid_fill_result(&matching_fills)
            } else {
                println!("  {} No Hyperliquid fills found within ±10s of Pacifica trade", "⚠".yellow().bold());

                // Show nearby fills for debugging
                let symbol_fills: Vec<_> = all_fills.iter()
                    .filter(|f| f.coin == symbol)
                    .take(5)
                    .collect();

                if !symbol_fills.is_empty() {
                    println!("  {} Available {} fills (may be from different cycles):", "DEBUG:".bright_black(), symbol);
                    for (i, fill) in symbol_fills.iter().enumerate() {
                        let dt = chrono::DateTime::from_timestamp_millis(fill.time as i64);
                        let time_str = dt.map(|d| d.format("%Y-%m-%d %H:%M:%S UTC").to_string())
                            .unwrap_or_else(|| fill.time.to_string());
                        let time_diff = (fill.time as i64 - pacifica_timestamp as i64) as f64 / 1000.0;
                        println!("  {}   Fill {}: {} @ ${} ({}, {:+.1}s from Pacifica)",
                            "DEBUG:".bright_black(),
                            i + 1,
                            fill.sz,
                            fill.px,
                            time_str,
                            time_diff
                        );
                    }
                }

                trade_fetcher::TradeFetchResult {
                    fill_price: None,
                    actual_fee: None,
                    total_size: None,
                    total_notional: None,
                }
            }
        }
        Err(e) => {
            println!("  {} Failed to retrieve Hyperliquid fills: {}", "✗".red().bold(), e);
            trade_fetcher::TradeFetchResult {
                fill_price: None,
                actual_fee: None,
                total_size: None,
                total_notional: None,
            }
        }
    };

    println!();
    println!("{}", "Hyperliquid Fetch Result:".bright_yellow().bold());
    match (hl_result.fill_price, hl_result.actual_fee, hl_result.total_size) {
        (Some(price), Some(fee), Some(size)) => {
            println!("  Fill Price: {} (${:.6})", format!("${}", price).cyan().bold(), price);
            println!("  Actual Fee: {} (${:.6})", format!("${}", fee).yellow().bold(), fee);
            println!("  Total Size: {} {}", size.to_string().bright_white(), symbol);

            let notional = price * size;
            let fee_bps = (fee / notional) * 10000.0;
            println!("  Fee Rate:   {:.2} bps", fee_bps);
        }
        (Some(price), Some(fee), None) => {
            println!("  Fill Price: {} (${:.6})", format!("${}", price).cyan().bold(), price);
            println!("  Actual Fee: {} (${:.6})", format!("${}", fee).yellow().bold(), fee);
            println!("  Total Size: {} (not available)", "N/A".yellow());
        }
        (Some(price), None, _) => {
            println!("  Fill Price: {} (${:.6})", format!("${}", price).cyan().bold(), price);
            println!("  Actual Fee: {} (not found)", "N/A".yellow());
        }
        (None, _, _) => {
            println!("  {} No fill data retrieved", "✗".red().bold());
        }
    }

    println!();

    // ═══════════════════════════════════════════════════
    // Calculate Combined Profit (like the bot does)
    // ═══════════════════════════════════════════════════

    if let (Some(pac_notional), Some(pac_fee), Some(pac_size), Some(hl_notional), Some(hl_fee), Some(hl_size)) =
        (pac_result.total_notional, pac_result.actual_fee, pac_result.total_size,
         hl_result.total_notional, hl_result.actual_fee, hl_result.total_size)
    {
        println!("{}", "─────────────────────────────────────────────────".bright_white());
        println!("{} {}", "[PROFIT CALCULATION]".bright_green().bold(), "Combined hedge profit...");
        println!();

        // Get the side from most recent Pacifica trade to determine direction
        let pac_side = pacifica_trading.lock().await
            .get_trade_history(Some(symbol), Some(1), None, None).await
            .ok()
            .and_then(|trades| trades.first().map(|t| t.side.clone()));

        // Verify sizes match (they should for a proper hedge)
        let size_diff_pct = ((pac_size - hl_size).abs() / pac_size) * 100.0;
        if size_diff_pct > 0.1 {
            println!("  {} Size mismatch detected!", "⚠".yellow().bold());
            println!("  {} Pacifica: {} {}, Hyperliquid: {} {}",
                "⚠".yellow().bold(),
                pac_size, symbol,
                hl_size, symbol
            );
            println!("  {} This may indicate partial fills or matching issues", "⚠".yellow().bold());
            println!();
        }

        let is_pacifica_buy = pac_side.as_ref().map(|s| s == "buy").unwrap_or(false);

        // Use the shared profit calculation function (same as main bot!)
        let profit = trade_fetcher::calculate_hedge_profit(
            pac_notional,
            hl_notional,
            pac_fee,
            hl_fee,
            is_pacifica_buy,
        );

        println!("  Trade Direction: {}",
            if is_pacifica_buy {
                "BUY on Pacifica, SELL on Hyperliquid".green().bold()
            } else {
                "SELL on Pacifica, BUY on Hyperliquid".red().bold()
            });
        println!("  Size:            {} {}", pac_size.to_string().bright_white(), symbol);
        println!();
        println!("  Pacifica Notional:  {}", format!("${:.6}", pac_notional).cyan());
        println!("  Hyperliquid Notional: {}", format!("${:.6}", hl_notional).cyan());
        println!("  Notional Diff:   {}",
            if profit.gross_pnl >= 0.0 {
                format!("${:.6}", profit.gross_pnl).green()
            } else {
                format!("${:.6}", profit.gross_pnl).red()
            });
        println!();
        println!("  Gross P&L:       {}",
            if profit.gross_pnl >= 0.0 {
                format!("${:.6}", profit.gross_pnl).green()
            } else {
                format!("${:.6}", profit.gross_pnl).red()
            });
        println!("  Pacifica Fee:    {}", format!("-${:.6}", profit.pac_fee).yellow());
        println!("  Hyperliquid Fee: {}", format!("-${:.6}", profit.hl_fee).yellow());
        println!("  {}", "─".repeat(47).bright_black());
        println!("  Net Profit:      {}",
            if profit.net_profit >= 0.0 {
                format!("${:.6}", profit.net_profit).bright_green().bold()
            } else {
                format!("${:.6}", profit.net_profit).bright_red().bold()
            });
        println!("  Profit (bps):    {}",
            if profit.profit_bps >= 0.0 {
                format!("{:.2} bps", profit.profit_bps).bright_green().bold()
            } else {
                format!("{:.2} bps", profit.profit_bps).bright_red().bold()
            });

        println!();
    } else {
        println!("{}", "─────────────────────────────────────────────────".bright_white());
        println!("{} Cannot calculate combined profit - missing data from one or both exchanges", "⚠".yellow().bold());
        println!();
    }

    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();
    println!("{}", "✓ This test uses the EXACT SAME code as the bot's profit calculation".green().bold());

    Ok(())
}


================================================================================
FILE: examples\fill_detection_test.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\fill_detection_test.rs
================================================================================

use xemm_rust::connector::pacifica::{
    OrderbookClient, OrderbookConfig, PacificaTrading, PacificaCredentials, OrderSide,
    FillDetectionClient, FillDetectionConfig, FillEvent,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test script for fill detection functionality
///
/// This example:
/// 1. Connects to Pacifica orderbook to get current SOL prices
/// 2. Places a buy order 0.05% below mid price (likely to fill quickly)
/// 3. Monitors for fills using the fill detection WebSocket client
/// 4. Reports partial fills, full fills, and cancellations
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  Fill Detection Test");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials from .env
    dotenv::dotenv().ok();
    let credentials = PacificaCredentials::from_env()?;
    info!("✓ Loaded credentials for account: {}", credentials.account);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client to get real-time prices
    info!("Starting orderbook client for SOL...");
    let orderbook_config = OrderbookConfig {
        symbol: "SOL".to_string(),
        agg_level: 1,
        reconnect_attempts: 5,
        ping_interval_secs: 30,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _symbol, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current prices - Bid: ${:.2}, Ask: ${:.2}, Mid: ${:.2}", bid, ask, mid);

    // Calculate order price (0.05% below mid)
    let offset_percent = 0.05;
    let order_price = mid * (1.0 - offset_percent / 100.0);

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Placing Order");
    info!("════════════════════════════════════════════════");
    info!("Symbol: SOL");
    info!("Side: BUY");
    info!("Size: 0.1 SOL");
    info!("Price: ${:.2} ({}% below mid)", order_price, offset_percent);
    info!("════════════════════════════════════════════════");
    info!("");

    // Start fill detection client in background
    let fill_detection_config = FillDetectionConfig {
        account: credentials.account.clone(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
    };

    let mut fill_detection_client = FillDetectionClient::new(fill_detection_config, false)?;

    // Track fill events
    let fill_received = Arc::new(Mutex::new(false));
    let fill_received_clone = fill_received.clone();

    info!("Starting fill detection monitor...");
    tokio::spawn(async move {
        fill_detection_client.start(move |fill_event| {
            match fill_event {
                FillEvent::PartialFill {
                    order_id,
                    client_order_id,
                    symbol,
                    side,
                    filled_amount,
                    original_amount,
                    avg_price,
                    timestamp,
                } => {
                    info!("");
                    info!("🟡 ════════════════════════════════════════════════");
                    info!("🟡 PARTIAL FILL DETECTED!");
                    info!("🟡 ════════════════════════════════════════════════");
                    info!("Order ID: {}", order_id);
                    if let Some(cloid) = client_order_id {
                        info!("Client Order ID: {}", cloid);
                    }
                    info!("Symbol: {}", symbol);
                    info!("Side: {}", side);
                    info!("Filled: {} / {} SOL", filled_amount, original_amount);
                    info!("Average Price: ${}", avg_price);
                    info!("Timestamp: {}", timestamp);
                    info!("🟡 ════════════════════════════════════════════════");
                    info!("");
                    *fill_received_clone.lock().unwrap() = true;
                }
                FillEvent::FullFill {
                    order_id,
                    client_order_id,
                    symbol,
                    side,
                    filled_amount,
                    avg_price,
                    timestamp,
                } => {
                    info!("");
                    info!("🟢 ════════════════════════════════════════════════");
                    info!("🟢 FULL FILL DETECTED!");
                    info!("🟢 ════════════════════════════════════════════════");
                    info!("Order ID: {}", order_id);
                    if let Some(cloid) = client_order_id {
                        info!("Client Order ID: {}", cloid);
                    }
                    info!("Symbol: {}", symbol);
                    info!("Side: {}", side);
                    info!("Filled: {} SOL", filled_amount);
                    info!("Average Price: ${}", avg_price);
                    info!("Timestamp: {}", timestamp);
                    info!("🟢 ════════════════════════════════════════════════");
                    info!("");
                    *fill_received_clone.lock().unwrap() = true;
                }
                FillEvent::Cancelled {
                    order_id,
                    client_order_id,
                    symbol,
                    side,
                    filled_amount,
                    original_amount,
                    reason,
                    timestamp,
                } => {
                    info!("");
                    info!("🔴 ════════════════════════════════════════════════");
                    info!("🔴 ORDER CANCELLED!");
                    info!("🔴 ════════════════════════════════════════════════");
                    info!("Order ID: {}", order_id);
                    if let Some(cloid) = client_order_id {
                        info!("Client Order ID: {}", cloid);
                    }
                    info!("Symbol: {}", symbol);
                    info!("Side: {}", side);
                    info!("Filled: {} / {} SOL", filled_amount, original_amount);
                    info!("Reason: {}", reason);
                    info!("Timestamp: {}", timestamp);
                    info!("🔴 ════════════════════════════════════════════════");
                    info!("");
                    *fill_received_clone.lock().unwrap() = true;
                }
            }
        }).await.ok();
    });

    // Give fill detection time to connect and subscribe
    sleep(Duration::from_secs(2)).await;

    // Place the order
    let mut trading_client = PacificaTrading::new(credentials);

    info!("Placing order...");
    let order = trading_client.place_limit_order(
        "SOL",
        OrderSide::Buy,
        0.1,  // Small size for testing
        Some(order_price),  // Exact price
        0.05,  // Offset (ignored when exact price is provided)
        Some(bid),
        Some(ask),
    ).await?;

    let client_order_id = order.client_order_id.clone().unwrap();
    info!("✓ Order placed successfully!");
    info!("  Order ID: {}", order.order_id.unwrap());
    info!("  Client Order ID: {}", client_order_id);
    info!("");

    // Monitor for fills or timeout
    info!("Monitoring for fills (will wait up to 60 seconds)...");
    info!("The order is placed very close to mid price, so it should fill quickly.");
    info!("");

    let start_time = std::time::Instant::now();
    let timeout = Duration::from_secs(60);

    loop {
        sleep(Duration::from_secs(1)).await;

        // Check if fill was received
        if *fill_received.lock().unwrap() {
            info!("Fill detection test completed successfully!");
            break;
        }

        // Check for timeout
        if start_time.elapsed() > timeout {
            info!("");
            info!("⏱️  Timeout reached (60 seconds)");
            info!("No fill detected - order may still be open on the exchange");
            info!("Attempting to cancel order...");

            match trading_client.cancel_order("SOL", &client_order_id).await {
                Ok(_) => {
                    info!("✓ Order cancelled successfully");
                    info!("The cancellation should be detected by the fill detection monitor");

                    // Wait a bit more to see if we get the cancellation event
                    sleep(Duration::from_secs(5)).await;
                }
                Err(e) => {
                    info!("✗ Failed to cancel order: {}", e);
                }
            }
            break;
        }

        // Show periodic status
        if start_time.elapsed().as_secs() % 10 == 0 {
            info!("Still monitoring... ({} seconds elapsed)", start_time.elapsed().as_secs());
        }
    }

    info!("");
    info!("════════════════════════════════════════════════");
    info!("Test completed. Exiting in 3 seconds...");
    info!("════════════════════════════════════════════════");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\hyperliquid_market_test.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\hyperliquid_market_test.rs
================================================================================

use xemm_rust::connector::hyperliquid::{
    OrderbookClient, OrderbookConfig, HyperliquidTrading, HyperliquidCredentials,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test script for Hyperliquid market orders
///
/// IMPORTANT: reduce_only should NEVER be used on Hyperliquid
///
/// This example:
/// 1. Connects to Hyperliquid orderbook to get current ENA prices
/// 2. Opens a long position (50 ENA, ~$19.50 notional)
/// 3. Waits 10 seconds
/// 4. Closes the long position (opposite order, NOT reduce-only)
/// 5. Opens a short position (50 ENA, ~$19.50 notional)
/// 6. Waits 10 seconds
/// 7. Closes the short position (opposite order, NOT reduce-only)
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  Hyperliquid Market Order Test");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials from .env
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    // Derive wallet address from private key
    use ethers::signers::Signer;
    let wallet: ethers::signers::LocalWallet = credentials.private_key.parse()?;
    let wallet_address = format!("{:?}", wallet.address());
    info!("✓ Loaded credentials for wallet: {}", wallet_address);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client to get real-time prices
    info!("Starting orderbook client for ENA...");
    let orderbook_config = OrderbookConfig {
        coin: "ENA".to_string(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
        request_interval_ms: 100,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current prices - Bid: ${:.2}, Ask: ${:.2}, Mid: ${:.2}", bid, ask, mid);

    // Create trading client
    let mut trading_client = HyperliquidTrading::new(credentials, false)?;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 1: Long Position");
    info!("════════════════════════════════════════════════");
    info!("Opening long position: BUY 50 ENA");
    info!("Expected notional: ${:.2}", 50.0 * mid);
    info!("════════════════════════════════════════════════");
    info!("");

    // Open long position (buy)
    let (bid, ask) = *prices.lock().unwrap();
    let long_open_result = trading_client
        .place_market_order(
            "ENA",
            true,          // is_buy = true
            50.0,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ Long position opened: {:?}", long_open_result);
    info!("");

    // Wait 10 seconds
    info!("Waiting 10 seconds...");
    sleep(Duration::from_secs(10)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Closing Long Position");
    info!("════════════════════════════════════════════════");
    info!("Closing long position: SELL 50 ENA");
    info!("════════════════════════════════════════════════");
    info!("");

    // Close long position (sell - NOT reduce-only)
    let (bid, ask) = *prices.lock().unwrap();
    let long_close_result = trading_client
        .place_market_order(
            "ENA",
            false,         // is_buy = false
            50.0,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ Long position closed: {:?}", long_close_result);
    info!("");

    // Small delay before opening short
    sleep(Duration::from_secs(2)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 2: Short Position");
    info!("════════════════════════════════════════════════");
    let (bid, ask) = *prices.lock().unwrap();
    let mid = (bid + ask) / 2.0;
    info!("Opening short position: SELL 50 ENA");
    info!("Expected notional: ${:.2}", 50.0 * mid);
    info!("════════════════════════════════════════════════");
    info!("");

    // Open short position (sell)
    let short_open_result = trading_client
        .place_market_order(
            "ENA",
            false,         // is_buy = false
            50.0,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ Short position opened: {:?}", short_open_result);
    info!("");

    // Wait 10 seconds
    info!("Waiting 10 seconds...");
    sleep(Duration::from_secs(10)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Closing Short Position");
    info!("════════════════════════════════════════════════");
    info!("Closing short position: BUY 50 ENA");
    info!("════════════════════════════════════════════════");
    info!("");

    // Close short position (buy - NOT reduce-only)
    let (bid, ask) = *prices.lock().unwrap();
    let short_close_result = trading_client
        .place_market_order(
            "ENA",
            true,          // is_buy = true
            50.0,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ Short position closed: {:?}", short_close_result);
    info!("");

    info!("════════════════════════════════════════════════");
    info!("  All tests completed successfully!");
    info!("════════════════════════════════════════════════");
    info!("Exiting in 3 seconds...");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\hyperliquid_orderbook.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\hyperliquid_orderbook.rs
================================================================================

use xemm_rust::connector::hyperliquid::{OrderbookClient, OrderbookConfig};
use xemm_rust::Config;
use tracing::info;

/// Example: Subscribe to Hyperliquid orderbook and print top of book
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    // Load configuration from config.json
    let app_config = Config::load_default()?;

    info!("═══════════════════════════════════════════════════");
    info!("  HYPERLIQUID Orderbook Example");
    info!("═══════════════════════════════════════════════════");
    info!("Subscribing to {} orderbook on mainnet", app_config.symbol);
    info!("Press Ctrl+C to stop");
    info!("═══════════════════════════════════════════════════");
    info!("");

    // Configure the client using settings from config.json
    let config = OrderbookConfig {
        coin: app_config.symbol,
        reconnect_attempts: app_config.reconnect_attempts,
        ping_interval_secs: app_config.ping_interval_secs,
    };

    // Create client
    let mut client = OrderbookClient::new(config)?;

    // Start client with callback for top of book updates
    client.start(|best_bid, best_ask, coin, timestamp| {
        info!(
            "[HYPERLIQUID] {} | Bid: {} | Ask: {} | Spread: {:.4} | TS: {}",
            coin,
            best_bid,
            best_ask,
            best_ask.parse::<f64>().unwrap_or(0.0) - best_bid.parse::<f64>().unwrap_or(0.0),
            timestamp
        );
    }).await?;

    Ok(())
}


================================================================================
FILE: examples\low_latency.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\low_latency.rs
================================================================================

use xemm_rust::connector::pacifica::{OrderbookClient, OrderbookConfig};
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Instant;
use tracing::info;

/// Example demonstrating low-latency mode for maximum speed
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    info!("═══════════════════════════════════════════════════");
    info!("  LOW-LATENCY MODE EXAMPLE - Maximum Speed");
    info!("═══════════════════════════════════════════════════");
    info!("This example demonstrates ultra-fast data reception");
    info!("with minimal processing overhead.");
    info!("═══════════════════════════════════════════════════");
    info!("");

    // Create orderbook client configuration
    let config = OrderbookConfig {
        symbol: "SOL".to_string(),
        agg_level: 1,
        reconnect_attempts: 5,
        ping_interval_secs: 30,
    };

    let mut client = OrderbookClient::new(config)?;

    // Performance tracking
    let update_count = Arc::new(AtomicU64::new(0));
    let start_time = Instant::now();
    let count_clone = update_count.clone();

    // Spawn a task to print statistics every 5 seconds
    tokio::spawn(async move {
        let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(5));
        loop {
            interval.tick().await;
            let count = count_clone.load(Ordering::Relaxed);
            let elapsed = start_time.elapsed().as_secs_f64();
            let rate = count as f64 / elapsed;

            info!("═══════════════════════════════════════════════════");
            info!("  PERFORMANCE STATS");
            info!("  Total Updates: {}", count);
            info!("  Elapsed Time: {:.2}s", elapsed);
            info!("  Update Rate: {:.2} updates/sec", rate);
            info!("═══════════════════════════════════════════════════");
        }
    });

    info!("Starting LOW-LATENCY orderbook stream for SOL...");
    info!("Updates are processed as fast as possible with minimal overhead.");
    info!("");

    // Start client with minimal processing callback
    client.start(move |_best_bid, _best_ask, _symbol, _timestamp| {
        // Increment counter with atomic operation (lock-free, very fast)
        update_count.fetch_add(1, Ordering::Relaxed);

        // NO string parsing
        // NO calculations
        // NO logging (except in stats task)
        // Just raw data reception!

        // In production, you would:
        // 1. Send to a lock-free queue (crossbeam-channel)
        // 2. Process in a separate thread/task
        // 3. Store in shared memory for other processes
    }).await?;

    Ok(())
}


================================================================================
FILE: examples\pacifica_orderbook.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\pacifica_orderbook.rs
================================================================================

mod connector;
mod config;

use config::Config;
use connector::pacifica::{OrderbookClient, OrderbookConfig};
use tracing::info;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging with environment variable control
    // Set RUST_LOG=debug for verbose logging, or RUST_LOG=info for normal logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    // Load configuration from config.json
    let config = Config::load_default()
        .unwrap_or_else(|e| {
            info!("Failed to load config.json: {}. Using default config.", e);
            Config::default()
        });

    // Validate configuration
    if let Err(e) = config.validate() {
        anyhow::bail!("Invalid configuration: {}", e);
    }

    // Create orderbook client configuration from loaded config
    let orderbook_config = OrderbookConfig {
        symbol: config.symbol.clone(),
        agg_level: config.agg_level,
        reconnect_attempts: config.reconnect_attempts,
        ping_interval_secs: config.ping_interval_secs,
    };

    // Create and start the orderbook client
    let mut client = OrderbookClient::new(orderbook_config)?;

    info!("════════════════════════════════════════════");
    info!("  PACIFICA Exchange Connector");
    info!("════════════════════════════════════════════");
    info!("Configuration:");
    info!("  Exchange: PACIFICA");
    info!("  Symbol: {}", config.symbol);
    info!("  Aggregation Level: {}", config.agg_level);
    info!("  Network: Mainnet");
    info!("  Ping Interval: {}s", config.ping_interval_secs);
    info!("  Max Reconnect Attempts: {}", config.reconnect_attempts);
    info!("  Low Latency Mode: {}", if config.low_latency_mode { "ENABLED" } else { "DISABLED" });
    info!("════════════════════════════════════════════");
    info!("Starting PACIFICA orderbook stream...");
    info!("Press Ctrl+C to stop");
    info!("");

    // Start the client and handle top of book updates
    let low_latency = config.low_latency_mode;

    if low_latency {
        // Low-latency mode: minimal processing, log every 100th update
        let mut update_count = 0u64;
        client.start(move |best_bid, best_ask, symbol, timestamp| {
            update_count += 1;

            // Only log every 100th update to reduce I/O overhead
            if update_count % 100 == 0 {
                info!(
                    "[PACIFICA] {} | Bid: ${} | Ask: ${} | TS: {} | Updates: {}",
                    symbol, best_bid, best_ask, timestamp, update_count
                );
            }

            // In production, you would send data to a channel or store for processing
            // instead of logging every update
        }).await?;
    } else {
        // Normal mode: full logging with spread calculations
        client.start(|best_bid, best_ask, symbol, timestamp| {
            // Calculate spread
            let bid_price: f64 = best_bid.parse().unwrap_or(0.0);
            let ask_price: f64 = best_ask.parse().unwrap_or(0.0);
            let spread = ask_price - bid_price;
            let spread_bps = if bid_price > 0.0 {
                (spread / bid_price) * 10000.0
            } else {
                0.0
            };

            info!(
                "[PACIFICA] {} | Bid: ${} | Ask: ${} | Spread: ${:.2} ({:.2} bps) | TS: {}",
                symbol, best_bid, best_ask, spread, spread_bps, timestamp
            );
        }).await?;
    }

    Ok(())
}


================================================================================
FILE: examples\pacifica_orderbook_rest_test.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\pacifica_orderbook_rest_test.rs
================================================================================

use xemm_rust::connector::pacifica::trading::PacificaTrading;
use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("═══════════════════════════════════════════════════");
    println!("  Pacifica REST API Orderbook Test");
    println!("═══════════════════════════════════════════════════");
    println!();

    // Load credentials from environment
    // Note: Credentials are only needed for authenticated endpoints
    // For public orderbook data, credentials don't need to be valid
    let credentials = match xemm_rust::connector::pacifica::trading::PacificaCredentials::from_env() {
        Ok(creds) => creds,
        Err(_) => {
            println!("⚠️  Warning: No credentials found in .env file");
            println!("   Using dummy credentials (OK for public endpoints)");
            xemm_rust::connector::pacifica::trading::PacificaCredentials {
                account: "dummy".to_string(),
                agent_wallet: "dummy".to_string(),
                private_key: "11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111".to_string(),
            }
        }
    };

    let trading = PacificaTrading::new(credentials);

    // Test symbols to fetch
    let test_symbols = vec!["SOL", "BTC", "ETH"];
    let agg_level = 1; // Top of book

    println!("[TEST] Fetching orderbook data for {} symbols", test_symbols.len());
    println!();

    for symbol in &test_symbols {
        println!("──────────────────────────────────────────────────");
        println!("Symbol: {}", symbol);
        println!("──────────────────────────────────────────────────");

        // Test 1: Get full orderbook snapshot
        match trading.get_orderbook_rest(symbol, agg_level).await {
            Ok(snapshot) => {
                println!("✓ Orderbook snapshot retrieved");
                println!("  Bids: {} levels", snapshot.bids.len());
                println!("  Asks: {} levels", snapshot.asks.len());

                // Show top 5 bids
                if !snapshot.bids.is_empty() {
                    println!("\n  Top 5 Bids:");
                    for (i, level) in snapshot.bids.iter().take(5).enumerate() {
                        println!("    {}: ${} @ {}", i + 1, level.price, level.size);
                    }
                }

                // Show top 5 asks
                if !snapshot.asks.is_empty() {
                    println!("\n  Top 5 Asks:");
                    for (i, level) in snapshot.asks.iter().take(5).enumerate() {
                        println!("    {}: ${} @ {}", i + 1, level.price, level.size);
                    }
                }
            }
            Err(e) => {
                println!("✗ Failed to get orderbook: {}", e);
            }
        }

        println!();

        // Test 2: Get best bid/ask
        match trading.get_best_bid_ask_rest(symbol, agg_level).await {
            Ok(Some((bid, ask))) => {
                let mid = (bid + ask) / 2.0;
                let spread = ask - bid;
                let spread_bps = (spread / mid) * 10000.0;

                println!("✓ Best bid/ask retrieved");
                println!("  Best Bid: ${:.4}", bid);
                println!("  Best Ask: ${:.4}", ask);
                println!("  Mid Price: ${:.4}", mid);
                println!("  Spread: ${:.4} ({:.2} bps)", spread, spread_bps);
            }
            Ok(None) => {
                println!("✗ No bid/ask available (empty orderbook)");
            }
            Err(e) => {
                println!("✗ Failed to get bid/ask: {}", e);
            }
        }

        println!();
    }

    println!("═══════════════════════════════════════════════════");
    println!("  Test Complete!");
    println!("═══════════════════════════════════════════════════");

    Ok(())
}


================================================================================
FILE: examples\rebalancer.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\rebalancer.rs
================================================================================

/// Position Rebalancer Utility
///
/// This utility checks for position imbalances on Hyperliquid and automatically
/// rebalances them using market orders if the notional value exceeds the threshold.
///
/// Usage:
///   cargo run --example rebalancer --release
///
/// Environment variables required:
///   HL_WALLET - Hyperliquid wallet address
///   HL_PRIVATE_KEY - Hyperliquid private key
///
/// Optional command-line arguments:
///   --symbol <SYMBOL> - Symbol to check (default: all positions)
///   --threshold <USD> - Minimum notional value to rebalance (default: 13.0)
///   --dry-run - Check positions without executing rebalance

use anyhow::{Context, Result};
use colored::Colorize;
use std::env;

use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

const DEFAULT_THRESHOLD_USD: f64 = 13.0;

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  Position Rebalancer".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();

    // Parse command-line arguments
    let args: Vec<String> = env::args().collect();
    let mut target_symbol: Option<String> = None;
    let mut threshold_usd = DEFAULT_THRESHOLD_USD;
    let mut dry_run = false;

    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "--symbol" => {
                if i + 1 < args.len() {
                    target_symbol = Some(args[i + 1].clone());
                    i += 2;
                } else {
                    eprintln!("Error: --symbol requires a value");
                    std::process::exit(1);
                }
            }
            "--threshold" => {
                if i + 1 < args.len() {
                    threshold_usd = args[i + 1].parse()
                        .context("Invalid threshold value")?;
                    i += 2;
                } else {
                    eprintln!("Error: --threshold requires a value");
                    std::process::exit(1);
                }
            }
            "--dry-run" => {
                dry_run = true;
                i += 1;
            }
            _ => {
                eprintln!("Unknown argument: {}", args[i]);
                eprintln!("Usage: cargo run --example rebalancer [--symbol SYMBOL] [--threshold USD] [--dry-run]");
                std::process::exit(1);
            }
        }
    }

    println!("{} Threshold: {}", "[CONFIG]".blue().bold(), format!("${:.2}", threshold_usd).bright_white());
    if let Some(ref symbol) = target_symbol {
        println!("{} Target Symbol: {}", "[CONFIG]".blue().bold(), symbol.bright_white().bold());
    } else {
        println!("{} Target: {}", "[CONFIG]".blue().bold(), "All positions".bright_white());
    }
    if dry_run {
        println!("{} Mode: {}", "[CONFIG]".blue().bold(), "DRY RUN (no trades)".yellow().bold());
    }
    println!();

    // Load credentials
    dotenv::dotenv().ok();
    let hl_credentials = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;
    let hl_wallet = env::var("HL_WALLET")
        .context("HL_WALLET environment variable not set")?;

    println!("{} Hyperliquid wallet: {}", "[INIT]".cyan().bold(), hl_wallet.bright_white());

    // Initialize trading client
    let hl_trading = HyperliquidTrading::new(hl_credentials, false)
        .context("Failed to create Hyperliquid trading client")?;

    println!("{} {} Trading client initialized", "[INIT]".cyan().bold(), "✓".green().bold());
    println!();

    // Fetch user state (positions)
    println!("{} Fetching positions...", "[CHECK]".magenta().bold());
    let user_state = hl_trading.get_user_state(&hl_wallet).await
        .context("Failed to fetch user state")?;

    println!("{} {} Found {} position(s)",
        "[CHECK]".magenta().bold(),
        "✓".green().bold(),
        user_state.asset_positions.len()
    );
    println!();

    // Filter positions by symbol if specified
    let positions_to_check: Vec<_> = user_state.asset_positions.iter()
        .filter(|pos| {
            if let Some(ref symbol) = target_symbol {
                &pos.position.coin == symbol
            } else {
                true // Check all positions
            }
        })
        .collect();

    if positions_to_check.is_empty() {
        println!("{} No positions found", "[RESULT]".bright_green().bold());
        if let Some(ref symbol) = target_symbol {
            println!("  Symbol {} has no open position", symbol.bright_white().bold());
        }
        return Ok(());
    }

    // Check each position
    let mut rebalanced_count = 0;
    let mut total_rebalanced_notional = 0.0;

    for asset_pos in positions_to_check {
        let pos = &asset_pos.position;
        let symbol = &pos.coin;
        let position_size: f64 = pos.szi.parse().unwrap_or(0.0);
        let position_value: f64 = pos.position_value.parse().unwrap_or(0.0);
        let notional = position_value.abs();

        println!("{}", "─────────────────────────────────────────────────".bright_black());
        println!("{} {}", "Symbol:".bright_white(), symbol.bright_white().bold());
        println!("{} {} ({})",
            "Position:".bright_white(),
            format!("{:.4}", position_size).bright_white(),
            if position_size > 0.0 { "LONG".green() } else { "SHORT".red() }
        );
        println!("{} {}",
            "Notional:".bright_white(),
            format!("${:.2}", notional).cyan().bold()
        );

        if let Some(entry_px) = &pos.entry_px {
            println!("{} {}", "Entry:".bright_white(), format!("${}", entry_px).cyan());
        }

        println!("{} {}",
            "Unrealized PnL:".bright_white(),
            if pos.unrealized_pnl.starts_with('-') {
                pos.unrealized_pnl.red()
            } else {
                pos.unrealized_pnl.green()
            }
        );

        // Check if position needs rebalancing
        if position_size == 0.0 {
            println!("{} {} No position to rebalance",
                "[STATUS]".bright_blue().bold(),
                "○".bright_black()
            );
            continue;
        }

        if notional < threshold_usd {
            println!("{} {} Position below threshold (${:.2} < ${:.2})",
                "[STATUS]".bright_blue().bold(),
                "○".bright_black(),
                notional,
                threshold_usd
            );
            continue;
        }

        // Position needs rebalancing
        println!("{} {} Position EXCEEDS threshold (${:.2} > ${:.2})",
            "[REBALANCE]".bright_yellow().bold(),
            "⚠".yellow().bold(),
            notional,
            threshold_usd
        );

        if dry_run {
            println!("{} {} DRY RUN - Would close {} position of {:.4} {}",
                "[REBALANCE]".bright_yellow().bold(),
                "◉".yellow(),
                if position_size > 0.0 { "LONG" } else { "SHORT" },
                position_size.abs(),
                symbol.bright_white().bold()
            );
            rebalanced_count += 1;
            total_rebalanced_notional += notional;
            continue;
        }

        // Execute rebalance: close position with market order
        println!("{} Executing rebalance...", "[REBALANCE]".bright_yellow().bold());

        // To close a position:
        // - If LONG (positive position), SELL to close
        // - If SHORT (negative position), BUY to close
        let is_buy = position_size < 0.0;
        let close_size = position_size.abs();

        // Get current market price for display
        let (current_bid, current_ask) = match hl_trading.get_l2_snapshot(symbol).await {
            Ok(Some((bid, ask))) => (Some(bid), Some(ask)),
            _ => (None, None),
        };

        if let (Some(bid), Some(ask)) = (current_bid, current_ask) {
            println!("  Current market: bid=${:.4}, ask=${:.4}", bid, ask);
        }

        match hl_trading.place_market_order(
            symbol,
            is_buy,
            close_size,
            0.05, // 5% slippage tolerance
            false, // not reduce_only (we want to fully close)
            current_bid,
            current_ask,
        ).await {
            Ok(response) => {
                println!("{} {} Successfully closed {} position",
                    "[REBALANCE]".bright_yellow().bold(),
                    "✓".green().bold(),
                    if is_buy { "SHORT" } else { "LONG" }
                );

                // Extract fill price from response
                if let Some(status) = response.response.data.statuses.first() {
                    match status {
                        xemm_rust::connector::hyperliquid::OrderStatus::Filled { filled } => {
                            let avg_px: f64 = filled.avgPx.parse().unwrap_or(0.0);
                            let total_sz: f64 = filled.totalSz.parse().unwrap_or(0.0);
                            println!("  Fill: {} {} @ ${:.4}",
                                if is_buy { "BOUGHT".green() } else { "SOLD".red() },
                                format!("{:.4}", total_sz).bright_white(),
                                avg_px
                            );
                        }
                        xemm_rust::connector::hyperliquid::OrderStatus::Error { error } => {
                            println!("{} {} Order failed: {}",
                                "[REBALANCE]".bright_yellow().bold(),
                                "✗".red().bold(),
                                error.red()
                            );
                        }
                        _ => {}
                    }
                }

                rebalanced_count += 1;
                total_rebalanced_notional += notional;
            }
            Err(e) => {
                println!("{} {} Failed to close position: {}",
                    "[REBALANCE]".bright_yellow().bold(),
                    "✗".red().bold(),
                    e.to_string().red()
                );
            }
        }
    }

    // Summary
    println!();
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  Rebalancing Summary".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();

    if rebalanced_count == 0 {
        println!("{} {} No positions required rebalancing",
            "[SUMMARY]".bright_green().bold(),
            "✓".green().bold()
        );
    } else {
        println!("{} {} Rebalanced {} position(s)",
            "[SUMMARY]".bright_green().bold(),
            "✓".green().bold(),
            rebalanced_count
        );
        println!("  Total notional: {}",
            format!("${:.2}", total_rebalanced_notional).cyan().bold()
        );

        if dry_run {
            println!();
            println!("{} This was a DRY RUN - no actual trades were executed",
                "⚠".yellow().bold()
            );
            println!("  Run without --dry-run to execute rebalancing");
        }
    }

    Ok(())
}


================================================================================
FILE: examples\rebalancer_cross_exchange.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\rebalancer_cross_exchange.rs
================================================================================

/// Cross-Exchange Position Rebalancer Utility
///
/// This utility checks for NET position imbalances between Pacifica and Hyperliquid
/// and automatically rebalances them using market orders on Hyperliquid if the NET
/// notional value exceeds the threshold.
///
/// NET position = Hyperliquid position - Pacifica position
///
/// Usage:
///   cargo run --example rebalancer_cross_exchange --release
///
/// Environment variables required:
///   PACIFICA_API_KEY, PACIFICA_SECRET_KEY, PACIFICA_ACCOUNT
///   HL_WALLET, HL_PRIVATE_KEY
///
/// Optional command-line arguments:
///   --symbol <SYMBOL> - Symbol to check (default: all positions)
///   --threshold <USD> - Minimum notional value to rebalance (default: 13.0)
///   --dry-run - Check positions without executing rebalance

use anyhow::{Context, Result};
use colored::Colorize;
use std::collections::HashMap;
use std::env;

use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};
use xemm_rust::connector::pacifica::{PacificaCredentials, PacificaTrading};

const DEFAULT_THRESHOLD_USD: f64 = 13.0;

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  Cross-Exchange Position Rebalancer".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();

    // Parse command-line arguments
    let args: Vec<String> = env::args().collect();
    let mut target_symbol: Option<String> = None;
    let mut threshold_usd = DEFAULT_THRESHOLD_USD;
    let mut dry_run = false;

    let mut i = 1;
    while i < args.len() {
        match args[i].as_str() {
            "--symbol" => {
                if i + 1 < args.len() {
                    target_symbol = Some(args[i + 1].clone());
                    i += 2;
                } else {
                    eprintln!("Error: --symbol requires a value");
                    std::process::exit(1);
                }
            }
            "--threshold" => {
                if i + 1 < args.len() {
                    threshold_usd = args[i + 1].parse()
                        .context("Invalid threshold value")?;
                    i += 2;
                } else {
                    eprintln!("Error: --threshold requires a value");
                    std::process::exit(1);
                }
            }
            "--dry-run" => {
                dry_run = true;
                i += 1;
            }
            _ => {
                eprintln!("Unknown argument: {}", args[i]);
                eprintln!("Usage: cargo run --example rebalancer_cross_exchange [--symbol SYMBOL] [--threshold USD] [--dry-run]");
                std::process::exit(1);
            }
        }
    }

    println!("{} Threshold: {}", "[CONFIG]".blue().bold(), format!("${:.2}", threshold_usd).bright_white());
    if let Some(ref symbol) = target_symbol {
        println!("{} Target Symbol: {}", "[CONFIG]".blue().bold(), symbol.bright_white().bold());
    } else {
        println!("{} Target: {}", "[CONFIG]".blue().bold(), "All positions".bright_white());
    }
    if dry_run {
        println!("{} Mode: {}", "[CONFIG]".blue().bold(), "DRY RUN (no trades)".yellow().bold());
    }
    println!();

    // Load credentials
    dotenv::dotenv().ok();

    let pac_credentials = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials")?;
    let hl_credentials = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;
    let hl_wallet = env::var("HL_WALLET")
        .context("HL_WALLET environment variable not set")?;

    println!("{} Pacifica account: {}", "[INIT]".cyan().bold(), pac_credentials.account.bright_white());
    println!("{} Hyperliquid wallet: {}", "[INIT]".cyan().bold(), hl_wallet.bright_white());

    // Initialize trading clients
    let pac_trading = PacificaTrading::new(pac_credentials);
    let hl_trading = HyperliquidTrading::new(hl_credentials, false)
        .context("Failed to create Hyperliquid trading client")?;

    println!("{} {} Trading clients initialized", "[INIT]".cyan().bold(), "✓".green().bold());
    println!();

    // Fetch positions from both exchanges
    println!("{} Fetching positions from Pacifica...", "[CHECK]".magenta().bold());
    let pac_positions = pac_trading.get_positions(target_symbol.as_deref()).await
        .context("Failed to fetch Pacifica positions")?;
    println!("{} {} Found {} Pacifica position(s)",
        "[CHECK]".magenta().bold(),
        "✓".green().bold(),
        pac_positions.len()
    );

    println!("{} Fetching positions from Hyperliquid...", "[CHECK]".magenta().bold());
    let hl_user_state = hl_trading.get_user_state(&hl_wallet).await
        .context("Failed to fetch Hyperliquid positions")?;
    println!("{} {} Found {} Hyperliquid position(s)",
        "[CHECK]".magenta().bold(),
        "✓".green().bold(),
        hl_user_state.asset_positions.len()
    );
    println!();

    // Build position maps
    let mut pac_positions_map: HashMap<String, f64> = HashMap::new();
    for pos in &pac_positions {
        let amount: f64 = pos.amount.parse().unwrap_or(0.0);
        pac_positions_map.insert(pos.symbol.clone(), amount);
    }

    let mut hl_positions_map: HashMap<String, (f64, String)> = HashMap::new(); // (szi, entry_px)
    for asset_pos in &hl_user_state.asset_positions {
        let pos = &asset_pos.position;
        let szi: f64 = pos.szi.parse().unwrap_or(0.0);
        hl_positions_map.insert(pos.coin.clone(), (szi, pos.entry_px.clone().unwrap_or_default()));
    }

    // Combine all symbols from both exchanges
    let mut all_symbols: Vec<String> = Vec::new();
    for symbol in pac_positions_map.keys() {
        if !all_symbols.contains(symbol) {
            all_symbols.push(symbol.clone());
        }
    }
    for symbol in hl_positions_map.keys() {
        if !all_symbols.contains(symbol) {
            all_symbols.push(symbol.clone());
        }
    }

    // Filter by target symbol if specified
    if let Some(ref target) = target_symbol {
        all_symbols.retain(|s| s == target);
    }

    if all_symbols.is_empty() {
        println!("{} No positions found", "[RESULT]".bright_green().bold());
        return Ok(());
    }

    // Calculate net positions and rebalance if needed
    let mut rebalanced_count = 0;
    let mut total_rebalanced_notional = 0.0;

    for symbol in &all_symbols {
        let pac_pos = *pac_positions_map.get(symbol).unwrap_or(&0.0);
        let (hl_pos, hl_entry_px) = hl_positions_map.get(symbol).cloned().unwrap_or((0.0, String::new()));

        // NET position = HL - Pacifica
        let net_pos = hl_pos - pac_pos;

        println!("{}", "─────────────────────────────────────────────────".bright_black());
        println!("{} {}", "Symbol:".bright_white(), symbol.bright_white().bold());
        println!("{} {}", "Pacifica position:".bright_white(), format!("{:.4}", pac_pos).cyan());
        println!("{} {}", "Hyperliquid position:".bright_white(), format!("{:.4}", hl_pos).cyan());
        println!("{} {} ({})",
            "NET position:".bright_white(),
            format!("{:.4}", net_pos).bright_yellow().bold(),
            if net_pos > 0.0 { "LONG".green() } else if net_pos < 0.0 { "SHORT".red() } else { "FLAT".bright_black() }
        );

        if net_pos == 0.0 {
            println!("{} {} Position is balanced", "[STATUS]".bright_blue().bold(), "✓".green().bold());
            continue;
        }

        // Get current price to calculate notional
        let (current_bid, current_ask) = match hl_trading.get_l2_snapshot(symbol).await {
            Ok(Some((bid, ask))) => (bid, ask),
            _ => {
                println!("{} {} Cannot fetch current price, skipping",
                    "[STATUS]".bright_blue().bold(),
                    "⚠".yellow().bold()
                );
                continue;
            }
        };

        let mid_price = (current_bid + current_ask) / 2.0;
        let net_notional = net_pos.abs() * mid_price;

        println!("{} {}",
            "Current mid price:".bright_white(),
            format!("${:.4}", mid_price).cyan()
        );
        println!("{} {}",
            "NET notional:".bright_white(),
            format!("${:.2}", net_notional).bright_yellow().bold()
        );

        if net_notional < threshold_usd {
            println!("{} {} NET position below threshold (${:.2} < ${:.2})",
                "[STATUS]".bright_blue().bold(),
                "○".bright_black(),
                net_notional,
                threshold_usd
            );
            continue;
        }

        // Need to rebalance
        println!("{} {} NET position EXCEEDS threshold (${:.2} > ${:.2})",
            "[REBALANCE]".bright_yellow().bold(),
            "⚠".yellow().bold(),
            net_notional,
            threshold_usd
        );

        // To rebalance NET position, trade on Hyperliquid:
        // - If NET is LONG (+), SELL on HL to reduce
        // - If NET is SHORT (-), BUY on HL to reduce
        let is_buy = net_pos < 0.0;
        let close_size = net_pos.abs();

        println!("{} Need to {} {} {} on Hyperliquid to balance",
            "[REBALANCE]".bright_yellow().bold(),
            if is_buy { "BUY".green() } else { "SELL".red() },
            format!("{:.4}", close_size).bright_white(),
            symbol.bright_white().bold()
        );

        if dry_run {
            println!("{} {} DRY RUN - Would {} {:.4} {}",
                "[REBALANCE]".bright_yellow().bold(),
                "◉".yellow(),
                if is_buy { "BUY" } else { "SELL" },
                close_size,
                symbol.bright_white().bold()
            );
            rebalanced_count += 1;
            total_rebalanced_notional += net_notional;
            continue;
        }

        // Execute rebalance
        println!("{} Executing rebalance...", "[REBALANCE]".bright_yellow().bold());

        match hl_trading.place_market_order(
            symbol,
            is_buy,
            close_size,
            0.05, // 5% slippage tolerance
            false,
            Some(current_bid),
            Some(current_ask),
        ).await {
            Ok(response) => {
                println!("{} {} Successfully rebalanced NET position",
                    "[REBALANCE]".bright_yellow().bold(),
                    "✓".green().bold()
                );

                // Extract fill price from response
                if let Some(status) = response.response.data.statuses.first() {
                    match status {
                        xemm_rust::connector::hyperliquid::OrderStatus::Filled { filled } => {
                            let avg_px: f64 = filled.avgPx.parse().unwrap_or(0.0);
                            let total_sz: f64 = filled.totalSz.parse().unwrap_or(0.0);
                            println!("  Fill: {} {} @ ${:.4}",
                                if is_buy { "BOUGHT".green() } else { "SOLD".red() },
                                format!("{:.4}", total_sz).bright_white(),
                                avg_px
                            );
                        }
                        xemm_rust::connector::hyperliquid::OrderStatus::Error { error } => {
                            println!("{} {} Order failed: {}",
                                "[REBALANCE]".bright_yellow().bold(),
                                "✗".red().bold(),
                                error.red()
                            );
                        }
                        _ => {}
                    }
                }

                rebalanced_count += 1;
                total_rebalanced_notional += net_notional;
            }
            Err(e) => {
                println!("{} {} Failed to rebalance: {}",
                    "[REBALANCE]".bright_yellow().bold(),
                    "✗".red().bold(),
                    e.to_string().red()
                );
            }
        }
    }

    // Summary
    println!();
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  Rebalancing Summary".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!();

    if rebalanced_count == 0 {
        println!("{} {} No NET positions required rebalancing",
            "[SUMMARY]".bright_green().bold(),
            "✓".green().bold()
        );
    } else {
        println!("{} {} Rebalanced {} NET position(s)",
            "[SUMMARY]".bright_green().bold(),
            "✓".green().bold(),
            rebalanced_count
        );
        println!("  Total NET notional: {}",
            format!("${:.2}", total_rebalanced_notional).cyan().bold()
        );

        if dry_run {
            println!();
            println!("{} This was a DRY RUN - no actual trades were executed",
                "⚠".yellow().bold()
            );
            println!("  Run without --dry-run to execute rebalancing");
        }
    }

    Ok(())
}


================================================================================
FILE: examples\simple_trade.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\simple_trade.rs
================================================================================

use xemm_rust::connector::pacifica::{
    OrderbookClient, OrderbookConfig, PacificaTrading, PacificaCredentials, OrderSide
};
use std::sync::{Arc, Mutex};
use tracing::info;
use tokio::time::{sleep, Duration};

/// Simple example: Get market price, place order, cancel after 10 seconds
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    info!("═══════════════════════════════════════════════════");
    info!("  PACIFICA Simple Trading Example");
    info!("  Place order → Wait 10s → Cancel");
    info!("═══════════════════════════════════════════════════\n");

    // Load credentials from .env
    let credentials = PacificaCredentials::from_env()?;
    info!("[PACIFICA] Account: {}", credentials.account);

    // Shared state for orderbook prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client
    let orderbook_config = OrderbookConfig {
        symbol: "SOL".to_string(),
        agg_level: 1,
        reconnect_attempts: 3,
        ping_interval_secs: 30,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    info!("[PACIFICA] Connecting to orderbook...");

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _symbol, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);

            let mut p = prices_clone.lock().unwrap();
            *p = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial orderbook data
    info!("[PACIFICA] Waiting for market data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();

    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to receive orderbook data");
    }

    let mid = (bid + ask) / 2.0;
    info!("[PACIFICA] Market: Bid=${:.2} Ask=${:.2} Mid=${:.2}\n", bid, ask, mid);

    // Create trading client (mainnet)
    let mut trading_client = PacificaTrading::new(credentials);

    // Place a buy order 1% below mid
    let symbol = "SOL";
    let size = 0.1; // 0.1 SOL

    info!("[PACIFICA] Placing BUY order:");
    info!("             Size: {} {}", size, symbol);
    info!("             Offset: 1% below mid");

    let order = trading_client.place_limit_order(
        symbol,
        OrderSide::Buy,
        size,
        None,         // Use mid price offset
        1.0,          // 1% below mid
        Some(bid),
        Some(ask),
    ).await?;

    let client_order_id = order.client_order_id
        .expect("Client order ID missing")
        .clone();

    info!("\n[PACIFICA] ✅ Order placed!");
    info!("             Order ID: {}", order.order_id.unwrap_or(0));
    info!("             Client ID: {}", client_order_id);

    // Countdown 10 seconds
    info!("\n[PACIFICA] ⏳ Waiting 10 seconds before cancelling...");
    for i in (1..=10).rev() {
        info!("             {} seconds remaining...", i);
        sleep(Duration::from_secs(1)).await;
    }

    // Cancel order
    info!("\n[PACIFICA] 🗑️  Cancelling order...");
    trading_client.cancel_order(symbol, &client_order_id).await?;

    info!("\n[PACIFICA] ✅ Order cancelled successfully!");
    info!("\n═══════════════════════════════════════════════════");
    info!("  Example Complete!");
    info!("═══════════════════════════════════════════════════\n");

    Ok(())
}


================================================================================
FILE: examples\test_aggressive_fill_detection.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_aggressive_fill_detection.rs
================================================================================

/// Test Aggressive Fill Detection - All 5 Methods
///
/// This test places an aggressive post-only limit order (0.05% spread) and monitors
/// all 5 fill detection methods to verify they work correctly and deduplicate properly.
///
/// Fill Detection Methods Tested:
/// 1. WebSocket Fill Detection (primary, real-time, via account_order_updates)
/// 2. WebSocket Position Detection (redundancy, real-time, via account_positions)
/// 3. REST API Order Polling (backup, 500ms)
/// 4. Position Monitor (ground truth, 500ms, REST-based)
/// 5. Monitor Task Pre-Cancel Check (defensive)
///
/// Usage:
/// ```bash
/// # Run with clean INFO-level logs
/// cargo run --example test_aggressive_fill_detection --release
///
/// # Run with verbose DEBUG logs (if needed for troubleshooting)
/// RUST_LOG=debug cargo run --example test_aggressive_fill_detection --release
/// ```
///
/// Expected Behavior:
/// - Order fills quickly due to aggressive price
/// - One or more detection methods trigger
/// - Only ONE hedge executes (deduplication works)
/// - Position returns to flat after hedge

use anyhow::{Context, Result};
use colored::Colorize;
use std::collections::HashSet;
use std::sync::Arc;
use tokio::sync::{mpsc, Mutex, RwLock};
use tokio::time::{interval, sleep, Duration, Instant};
use tracing::{debug, info, warn};

use xemm_rust::config::Config;
use xemm_rust::connector::pacifica::{
    FillDetectionClient, FillDetectionConfig, FillEvent,
    OpenOrderItem, OrderSide as PacificaOrderSide, PacificaCredentials, PacificaTrading, PacificaWsTrading,
};
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};
use xemm_rust::strategy::OrderSide;

/// Track which detection method found the fill first
#[derive(Debug, Clone)]
enum DetectionMethod {
    WebSocket,
    WebSocketPosition,  // Position-based fill detection via WebSocket
    RestOrderPoll,
    PositionMonitor,
    MonitorPreCancel,
}

/// Fill detection event
#[derive(Debug, Clone)]
struct FillDetectionEvent {
    method: DetectionMethod,
    timestamp: Instant,
    fill_size: f64,
    client_order_id: String,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging (INFO level to avoid verbose DEBUG logs)
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::INFO)
        .init();

    println!("{}", "═".repeat(80).bright_cyan());
    println!("{}", "  Test Aggressive Fill Detection - All 5 Methods".bright_white().bold());
    println!("{}", "═".repeat(80).bright_cyan());
    println!();

    // Load configuration
    let mut config = Config::load_default().context("Failed to load configuration")?;

    // Override notional for test (use $15 to ensure reasonable size)
    config.order_notional_usd = 15.0;

    info!("{} Symbol: {}, Notional: ${}",
        "[CONFIG]".blue().bold(),
        config.symbol.bright_white().bold(),
        config.order_notional_usd.to_string().bright_white()
    );

    // Load credentials
    let pacifica_creds = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials")?;
    let hyperliquid_creds = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;

    info!("{} Credentials loaded", "[INIT]".cyan().bold());

    // Create clients
    let pacifica_trading = Arc::new(PacificaTrading::new(pacifica_creds.clone())?);
    let pacifica_trading_rest = Arc::new(PacificaTrading::new(pacifica_creds.clone())?);
    let pacifica_trading_position = Arc::new(PacificaTrading::new(pacifica_creds.clone())?);
    let pacifica_ws_trading = Arc::new(PacificaWsTrading::new(pacifica_creds.clone(), false));
    let hyperliquid_trading = Arc::new(HyperliquidTrading::new(hyperliquid_creds.clone(), false)?);

    info!("{} Clients initialized", "[INIT]".cyan().bold());

    // Cancel all existing orders first
    info!("{} Cancelling all existing orders...", "[INIT]".cyan().bold());
    let cancelled = pacifica_trading.cancel_all_orders(false, Some(&config.symbol), false).await?;
    info!("{} Cancelled {} existing order(s)", "[INIT]".green().bold(), cancelled);

    // Wait a moment for cancellations to settle
    sleep(Duration::from_secs(1)).await;

    // Fetch current market price
    info!("{} Fetching current market price...", "[INIT]".cyan().bold());
    let (best_bid, best_ask) = pacifica_trading
        .get_best_bid_ask_rest(&config.symbol, 1)
        .await?
        .context("No bid/ask available")?;

    let mid_price = (best_bid + best_ask) / 2.0;
    let spread_bps = ((best_ask - best_bid) / mid_price) * 10000.0;

    info!("{} Market: Bid ${:.4}, Ask ${:.4}, Mid ${:.4}, Spread {:.2} bps",
        "[MARKET]".magenta().bold(),
        best_bid,
        best_ask,
        mid_price,
        spread_bps
    );

    // Calculate aggressive limit price (0.05% = 5 bps inside the spread)
    let target_spread_bps = 5.0; // 0.05% = 5 basis points
    let side = PacificaOrderSide::Buy; // We'll buy aggressively

    let aggressive_price = match side {
        PacificaOrderSide::Buy => {
            // Buy slightly below mid (aggressive)
            mid_price * (1.0 - target_spread_bps / 10000.0)
        }
        PacificaOrderSide::Sell => {
            // Sell slightly above mid (aggressive)
            mid_price * (1.0 + target_spread_bps / 10000.0)
        }
    };

    // Get market info for tick size
    let market_info = pacifica_trading.get_market_info().await?;
    let symbol_info = market_info
        .get(&config.symbol)
        .context("Symbol not found in market info")?;
    let tick_size: f64 = symbol_info.tick_size.parse()?;
    let lot_size: f64 = symbol_info.lot_size.parse()?;

    // Round price to tick size
    let rounded_price = (aggressive_price / tick_size).floor() * tick_size;

    // Calculate size
    let size = config.order_notional_usd / rounded_price;
    let rounded_size = (size / lot_size).floor() * lot_size;

    info!("{} Order: {} {} @ ${:.4} (notional: ${:.2})",
        "[ORDER]".bright_yellow().bold(),
        side.as_str().to_uppercase().green().bold(),
        rounded_size,
        rounded_price,
        rounded_size * rounded_price
    );

    let price_vs_mid_bps = ((rounded_price - mid_price) / mid_price) * 10000.0;
    info!("{} Price is {:.2} bps {} mid (aggressive for quick fill)",
        "[STRATEGY]".bright_green().bold(),
        price_vs_mid_bps.abs(),
        if price_vs_mid_bps < 0.0 { "below" } else { "above" }
    );

    // Shared state for tracking detections
    let detection_events = Arc::new(Mutex::new(Vec::<FillDetectionEvent>::new()));
    let processed_fills = Arc::new(Mutex::new(HashSet::<String>::new()));
    let hedge_triggered = Arc::new(Mutex::new(false));
    let (hedge_tx, mut hedge_rx) = mpsc::channel::<(OrderSide, f64, String)>(10);

    // Track client order ID
    let placed_order_id = Arc::new(RwLock::new(Option::<String>::None));

    // Track baseline position before order
    let baseline_position = Arc::new(Mutex::new(Option::<(f64, String)>::None));

    info!("{} Fetching baseline position...", "[INIT]".cyan().bold());
    match pacifica_trading_position.get_positions().await {
        Ok(positions) => {
            if let Some(pos) = positions.iter().find(|p| p.symbol == config.symbol) {
                let amount: f64 = pos.amount.parse().unwrap_or(0.0);
                let signed_amount = if pos.side == "bid" { amount } else { -amount };
                *baseline_position.lock().await = Some((signed_amount, pos.side.clone()));
                info!("{} Baseline position: {} {} (signed: {:.4})",
                    "[POSITION]".magenta().bold(),
                    amount,
                    pos.side.bright_white(),
                    signed_amount
                );
            } else {
                info!("{} No existing position for {}", "[POSITION]".magenta().bold(), config.symbol);
                *baseline_position.lock().await = Some((0.0, "none".to_string()));
            }
        }
        Err(e) => {
            warn!("{} Failed to fetch baseline position: {}", "[POSITION]".yellow().bold(), e);
            *baseline_position.lock().await = Some((0.0, "none".to_string()));
        }
    }

    println!();
    info!("{} Starting fill detection monitors...", "[INIT]".cyan().bold());
    println!();

    // ═══════════════════════════════════════════════════
    // Detection Method 1: WebSocket Fill Detection
    // ═══════════════════════════════════════════════════

    let detection_ws = detection_events.clone();
    let processed_ws = processed_fills.clone();
    let hedge_tx_ws = hedge_tx.clone();
    let placed_id_ws = placed_order_id.clone();
    let symbol_ws = config.symbol.clone();

    let fill_config = FillDetectionConfig {
        account: pacifica_creds.account.clone(),
        reconnect_attempts: 3,
        ping_interval_secs: 15,
        enable_position_fill_detection: true,  // Enable position-based fill detection
    };

    let mut fill_client = FillDetectionClient::new(fill_config, false)?;

    tokio::spawn(async move {
        fill_client
            .start(move |fill_event| {
                let detection_clone = detection_ws.clone();
                let processed_clone = processed_ws.clone();
                let hedge_tx = hedge_tx_ws.clone();
                let placed_id = placed_id_ws.clone();
                let symbol = symbol_ws.clone();

                tokio::spawn(async move {
                    match fill_event {
                        FillEvent::FullFill {
                            symbol: fill_symbol,
                            side,
                            filled_amount,
                            avg_price,
                            client_order_id,
                            ..
                        } if fill_symbol == symbol => {
                            let cloid = client_order_id.clone().unwrap_or_default();
                            let placed = placed_id.read().await;

                            if placed.as_ref().map(|id| id == &cloid).unwrap_or(false) {
                                drop(placed);

                                let fill_id = format!("ws_{}", cloid);
                                let mut processed = processed_clone.lock().await;

                                if !processed.contains(&fill_id) {
                                    processed.insert(fill_id);
                                    drop(processed);

                                    let fill_size: f64 = filled_amount.parse().unwrap_or(0.0);

                                    info!("{} {} DETECTED: {} {} @ {}",
                                        "[WS_FILL]".bright_magenta().bold(),
                                        "✓".green().bold(),
                                        side.bright_white(),
                                        fill_size,
                                        avg_price.cyan()
                                    );

                                    let mut events = detection_clone.lock().await;
                                    events.push(FillDetectionEvent {
                                        method: DetectionMethod::WebSocket,
                                        timestamp: Instant::now(),
                                        fill_size,
                                        client_order_id: cloid.clone(),
                                    });
                                    drop(events);

                                    let order_side = if side == "buy" || side == "bid" {
                                        OrderSide::Buy
                                    } else {
                                        OrderSide::Sell
                                    };

                                    hedge_tx.send((order_side, fill_size, cloid)).await.ok();
                                }
                            }
                        }
                        FillEvent::PositionFill {
                            symbol: fill_symbol,
                            side,
                            filled_amount,
                            avg_price,
                            cross_validated,
                            position_delta,
                            prev_position,
                            new_position,
                            ..
                        } if fill_symbol == symbol => {
                            // Position-based fill detection (redundancy layer)
                            let placed = placed_id.read().await;

                            // For position fills, we don't have client_order_id, so we trigger
                            // regardless if we have an active order and position changed
                            if placed.is_some() {
                                drop(placed);

                                let fill_id = format!("ws_pos_{}_{}", position_delta, new_position);
                                let mut processed = processed_clone.lock().await;

                                if !processed.contains(&fill_id) {
                                    processed.insert(fill_id.clone());
                                    drop(processed);

                                    let fill_size: f64 = filled_amount.parse().unwrap_or(0.0);

                                    if cross_validated {
                                        info!("{} {} POSITION FILL (cross-validated): {} {} @ {} | Δ: {} → {}",
                                            "[WS_POS_FILL]".bright_blue().bold(),
                                            "✓".green().bold(),
                                            side.bright_white(),
                                            fill_size,
                                            avg_price.cyan(),
                                            prev_position,
                                            new_position
                                        );
                                    } else {
                                        warn!("{} {} POSITION FILL (MISSED BY PRIMARY!): {} {} @ {} | Δ: {} → {}",
                                            "[WS_POS_FILL]".bright_yellow().bold(),
                                            "⚠".yellow().bold(),
                                            side.bright_white(),
                                            fill_size,
                                            avg_price.cyan(),
                                            prev_position,
                                            new_position
                                        );
                                    }

                                    let mut events = detection_clone.lock().await;
                                    events.push(FillDetectionEvent {
                                        method: DetectionMethod::WebSocketPosition,
                                        timestamp: Instant::now(),
                                        fill_size,
                                        client_order_id: fill_id.clone(),
                                    });
                                    drop(events);

                                    // Only trigger hedge if NOT cross-validated (safety net)
                                    if !cross_validated {
                                        let order_side = if side == "buy" {
                                            OrderSide::Buy
                                        } else {
                                            OrderSide::Sell
                                        };

                                        hedge_tx.send((order_side, fill_size, fill_id)).await.ok();
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                });
            })
            .await
            .ok();
    });

    // ═══════════════════════════════════════════════════
    // Detection Method 2: REST Order Polling
    // ═══════════════════════════════════════════════════

    let detection_rest = detection_events.clone();
    let processed_rest = processed_fills.clone();
    let hedge_tx_rest = hedge_tx.clone();
    let placed_id_rest = placed_order_id.clone();
    let symbol_rest = config.symbol.clone();
    let trading_rest = pacifica_trading_rest.clone();

    tokio::spawn(async move {
        let mut poll_interval = interval(Duration::from_millis(500));
        poll_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);
        let mut last_filled_amount = 0.0;

        loop {
            poll_interval.tick().await;

            let placed = placed_id_rest.read().await;
            if placed.is_none() {
                continue;
            }
            let cloid = placed.clone().unwrap();
            drop(placed);

            match trading_rest.get_open_orders().await {
                Ok(orders) => {
                    if let Some(order) = orders.iter().find(|o| o.client_order_id == cloid) {
                        let current_filled: f64 = order.filled_amount.parse().unwrap_or(0.0);

                        if current_filled > last_filled_amount + 0.0001 {
                            let delta = current_filled - last_filled_amount;
                            let fill_id = format!("rest_{}", cloid);
                            let mut processed = processed_rest.lock().await;

                            if !processed.contains(&fill_id) {
                                processed.insert(fill_id);
                                drop(processed);

                                info!("{} {} DETECTED: fill delta {:.4} (total {:.4})",
                                    "[REST_POLL]".bright_cyan().bold(),
                                    "✓".green().bold(),
                                    delta,
                                    current_filled
                                );

                                let mut events = detection_rest.lock().await;
                                events.push(FillDetectionEvent {
                                    method: DetectionMethod::RestOrderPoll,
                                    timestamp: Instant::now(),
                                    fill_size: delta,
                                    client_order_id: cloid.clone(),
                                });
                                drop(events);

                                let order_side = if order.side == "bid" {
                                    OrderSide::Buy
                                } else {
                                    OrderSide::Sell
                                };

                                hedge_tx_rest.send((order_side, delta, cloid.clone())).await.ok();
                            }

                            last_filled_amount = current_filled;
                        }
                    } else {
                        // Order not in open orders - might be fully filled
                        if last_filled_amount > 0.0 {
                            debug!("[REST_POLL] Order no longer in open orders (likely filled)");
                        }
                    }
                }
                Err(e) => {
                    debug!("[REST_POLL] Error fetching orders: {}", e);
                }
            }
        }
    });

    // ═══════════════════════════════════════════════════
    // Detection Method 3: Position Monitor
    // ═══════════════════════════════════════════════════

    let detection_pos = detection_events.clone();
    let processed_pos = processed_fills.clone();
    let hedge_tx_pos = hedge_tx.clone();
    let placed_id_pos = placed_order_id.clone();
    let symbol_pos = config.symbol.clone();
    let trading_pos = pacifica_trading_position.clone();
    let baseline_pos = baseline_position.clone();

    tokio::spawn(async move {
        let mut poll_interval = interval(Duration::from_millis(500));
        poll_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

        loop {
            poll_interval.tick().await;

            let placed = placed_id_pos.read().await;
            if placed.is_none() {
                continue;
            }
            let cloid = placed.clone().unwrap();
            drop(placed);

            match trading_pos.get_positions().await {
                Ok(positions) => {
                    let baseline = baseline_pos.lock().await.clone();
                    let (baseline_signed, _) = baseline.unwrap_or((0.0, "none".to_string()));

                    let current_position = positions.iter().find(|p| p.symbol == symbol_pos);
                    let current_signed = if let Some(pos) = current_position {
                        let amount: f64 = pos.amount.parse().unwrap_or(0.0);
                        if pos.side == "bid" { amount } else { -amount }
                    } else {
                        0.0
                    };

                    let delta = current_signed - baseline_signed;

                    if delta.abs() > 0.0001 {
                        let fill_id = format!("position_{}", cloid);
                        let mut processed = processed_pos.lock().await;

                        if !processed.contains(&fill_id) {
                            processed.insert(fill_id);
                            drop(processed);

                            info!("{} {} DETECTED: position delta {:.4} ({:.4} → {:.4})",
                                "[POSITION]".bright_cyan().bold(),
                                "✓".green().bold(),
                                delta.abs(),
                                baseline_signed,
                                current_signed
                            );

                            let mut events = detection_pos.lock().await;
                            events.push(FillDetectionEvent {
                                method: DetectionMethod::PositionMonitor,
                                timestamp: Instant::now(),
                                fill_size: delta.abs(),
                                client_order_id: cloid.clone(),
                            });
                            drop(events);

                            let order_side = if delta > 0.0 {
                                OrderSide::Buy
                            } else {
                                OrderSide::Sell
                            };

                            hedge_tx_pos.send((order_side, delta.abs(), cloid.clone())).await.ok();
                        }
                    }
                }
                Err(e) => {
                    debug!("[POSITION] Error fetching positions: {}", e);
                }
            }
        }
    });

    // Wait for monitors to initialize
    sleep(Duration::from_secs(2)).await;

    println!();
    info!("{}", "═".repeat(80).bright_cyan());
    info!("{} PLACING AGGRESSIVE ORDER", "[TEST]".bright_yellow().bold());
    info!("{}", "═".repeat(80).bright_cyan());
    println!();

    // Place the aggressive limit order
    let result = pacifica_trading
        .place_limit_order(
            &config.symbol,
            side,
            rounded_size,
            Some(rounded_price),  // Explicit price
            1.0,                   // mid_price_offset_pct (not used since price is Some)
            Some(best_bid),        // current_bid
            Some(best_ask),        // current_ask
        )
        .await?;

    let client_order_id = result.client_order_id.clone()
        .context("No client_order_id in response")?;
    *placed_order_id.write().await = Some(client_order_id.clone());

    info!("{} {} Order placed successfully!",
        "[ORDER]".bright_yellow().bold(),
        "✓".green().bold()
    );
    if let Some(oid) = result.order_id {
        info!("{} Order ID: {}",
            "[ORDER]".bright_yellow().bold(),
            oid.to_string().bright_white()
        );
    }
    info!("{} Client Order ID: {}",
        "[ORDER]".bright_yellow().bold(),
        client_order_id.bright_white()
    );

    println!();
    info!("{} Waiting for fill detection... (max 5 minutes)", "[TEST]".bright_cyan().bold());
    println!();

    // Wait for hedge trigger (with timeout)
    let test_start = Instant::now();
    let max_wait = Duration::from_secs(300); // 5 minutes

    let hedge_result = tokio::time::timeout(max_wait, async {
        hedge_rx.recv().await
    }).await;

    match hedge_result {
        Ok(Some((hedge_side, hedge_size, hedge_cloid))) => {
            let elapsed = test_start.elapsed();

            *hedge_triggered.lock().await = true;

            println!();
            info!("{}", "═".repeat(80).bright_green());
            info!("{} HEDGE TRIGGERED!", "[SUCCESS]".bright_green().bold());
            info!("{}", "═".repeat(80).bright_green());
            println!();

            info!("{} Side: {}, Size: {:.4}, Time: {:.3}s",
                "[HEDGE]".bright_magenta().bold(),
                hedge_side.as_str().to_uppercase().bright_white(),
                hedge_size,
                elapsed.as_secs_f64()
            );

            // Analyze which detection methods triggered
            sleep(Duration::from_millis(500)).await; // Let all methods process

            let events = detection_events.lock().await;

            println!();
            info!("{} Detection Methods Summary:", "[ANALYSIS]".bright_yellow().bold());
            info!("{}", "─".repeat(60).bright_black());

            if events.is_empty() {
                warn!("{} No detection events recorded (might have hedge triggered before tracking)",
                    "⚠".yellow().bold());
            } else {
                for (i, event) in events.iter().enumerate() {
                    let method_name = format!("{:?}", event.method);
                    let time_from_start = event.timestamp.duration_since(test_start);

                    let marker = if i == 0 {
                        "🥇 FIRST".green().bold()
                    } else {
                        format!("   #{}", i + 1).bright_black()
                    };

                    info!("{} {} detected fill at {:.3}s",
                        marker,
                        method_name.bright_white(),
                        time_from_start.as_secs_f64()
                    );
                }
            }

            let hedge_was_triggered = *hedge_triggered.lock().await;
            println!();
            info!("{} Hedge triggered: {}",
                "[RESULT]".bright_green().bold(),
                if hedge_was_triggered { "YES ✓".green().bold() } else { "NO ✗".red().bold() }
            );
            info!("{} Detection methods that fired: {}",
                "[RESULT]".bright_green().bold(),
                events.len().to_string().bright_white()
            );

            // Execute hedge on Hyperliquid
            println!();
            info!("{} Executing hedge on Hyperliquid...", "[HEDGE]".bright_magenta().bold());

            let hl_side = match hedge_side {
                OrderSide::Buy => OrderSide::Sell,
                OrderSide::Sell => OrderSide::Buy,
            };

            // Fetch current Hyperliquid prices for market order
            info!("{} Fetching current Hyperliquid prices...", "[HEDGE]".bright_magenta().bold());
            let (hl_bid, hl_ask) = match hyperliquid_trading.get_l2_snapshot(&config.symbol).await {
                Ok(Some((bid, ask))) => {
                    info!("{} Hyperliquid prices: Bid ${:.4}, Ask ${:.4}",
                        "[HEDGE]".bright_magenta().bold(),
                        bid,
                        ask
                    );
                    (Some(bid), Some(ask))
                }
                Ok(None) => {
                    warn!("{} No Hyperliquid prices available, using None (may fail)",
                        "[HEDGE]".yellow().bold()
                    );
                    (None, None)
                }
                Err(e) => {
                    warn!("{} Failed to fetch Hyperliquid prices: {}, using None",
                        "[HEDGE]".yellow().bold(),
                        e
                    );
                    (None, None)
                }
            };

            let is_buy = matches!(hl_side, OrderSide::Buy);
            match hyperliquid_trading.place_market_order(&config.symbol, is_buy, hedge_size, config.hyperliquid_slippage, false, hl_bid, hl_ask).await {
                Ok(hl_result) => {
                    info!("{} {} Hedge executed on Hyperliquid",
                        "[HEDGE]".bright_magenta().bold(),
                        "✓".green().bold()
                    );
                    info!("{} Hyperliquid status: {:?}",
                        "[HEDGE]".bright_magenta().bold(),
                        hl_result.status
                    );
                }
                Err(e) => {
                    warn!("{} {} Hedge failed: {}",
                        "[HEDGE]".bright_magenta().bold(),
                        "✗".red().bold(),
                        e
                    );
                }
            }

            // Verify positions after hedge (both exchanges)
            // Wait longer for positions to propagate to both APIs
            println!();
            info!("{} Waiting 8 seconds for positions to propagate...", "[VERIFY]".cyan().bold());
            sleep(Duration::from_secs(8)).await;

            info!("{} Verifying final positions on both exchanges...", "[VERIFY]".cyan().bold());

            // Check Pacifica position
            let pacifica_position = match pacifica_trading_position.get_positions().await {
                Ok(positions) => {
                    if let Some(pos) = positions.iter().find(|p| p.symbol == config.symbol) {
                        let amount: f64 = pos.amount.parse().unwrap_or(0.0);
                        let signed_amount = if pos.side == "bid" { amount } else { -amount };

                        info!("{} Pacifica: {} {} (signed: {:.4})",
                            "[VERIFY]".cyan().bold(),
                            amount,
                            pos.side.bright_white(),
                            signed_amount
                        );
                        Some(signed_amount)
                    } else {
                        info!("{} Pacifica: No position (flat)", "[VERIFY]".cyan().bold());
                        Some(0.0)
                    }
                }
                Err(e) => {
                    warn!("{} Failed to fetch Pacifica position: {}", "[VERIFY]".yellow().bold(), e);
                    None
                }
            };

            // Check Hyperliquid position (with retry logic)
            // Load wallet address from environment (same as other examples)
            let wallet_address = std::env::var("HL_WALLET")
                .context("HL_WALLET environment variable not set")
                .unwrap();

            info!("{} Checking Hyperliquid positions for wallet: {}",
                "[VERIFY]".cyan().bold(),
                wallet_address.bright_white());

            let mut hyperliquid_position: Option<f64> = None;

            // Try up to 3 times with delays if position not found
            for retry in 0..3 {
                if retry > 0 {
                    info!("{} Retry {} - waiting 3 more seconds for Hyperliquid position...",
                        "[VERIFY]".cyan().bold(), retry);
                    sleep(Duration::from_secs(3)).await;
                }

                match hyperliquid_trading.get_user_state(&wallet_address).await {
                    Ok(user_state) => {
                        info!("{} Hyperliquid returned {} position(s)",
                            "[VERIFY]".cyan().bold(),
                            user_state.asset_positions.len());

                        if let Some(asset_pos) = user_state.asset_positions.iter().find(|ap| ap.position.coin == config.symbol) {
                            let szi: f64 = asset_pos.position.szi.parse().unwrap_or(0.0);
                            info!("{} Hyperliquid: {} (signed: {:.4})",
                                "[VERIFY]".cyan().bold(),
                                if szi > 0.0 { "LONG".green() } else if szi < 0.0 { "SHORT".red() } else { "FLAT".bright_white() },
                                szi
                            );
                            hyperliquid_position = Some(szi);
                            break;
                        } else if retry == 2 {
                            info!("{} Hyperliquid: No position for {} found after 3 attempts",
                                "[VERIFY]".cyan().bold(),
                                config.symbol);
                            hyperliquid_position = Some(0.0);
                        }
                    }
                    Err(e) => {
                        warn!("{} Failed to fetch Hyperliquid position (attempt {}): {}",
                            "[VERIFY]".yellow().bold(), retry + 1, e);
                        if retry == 2 {
                            hyperliquid_position = None;
                        }
                    }
                }
            }

            // Calculate net position across both exchanges
            if let (Some(pac_pos), Some(hl_pos)) = (pacifica_position, hyperliquid_position) {
                let net_position = pac_pos + hl_pos;

                info!("{}", "─".repeat(60).bright_black());
                info!("{} Net Position: {:.4} (Pacifica: {:.4} + Hyperliquid: {:.4})",
                    "[VERIFY]".cyan().bold(),
                    net_position,
                    pac_pos,
                    hl_pos
                );

                let baseline = baseline_position.lock().await.clone();
                let (baseline_signed, _) = baseline.unwrap_or((0.0, "none".to_string()));

                // Check if net position is close to baseline
                if net_position.abs() < 0.01 {
                    info!("{} {} Net position is FLAT (properly hedged across both exchanges)",
                        "[VERIFY]".cyan().bold(),
                        "✓".green().bold()
                    );
                } else {
                    warn!("{} {} Net position NOT flat! Delta: {:.4}",
                        "[VERIFY]".cyan().bold(),
                        "⚠".yellow().bold(),
                        net_position
                    );

                    if (pac_pos - baseline_signed).abs() < 0.01 && hl_pos.abs() < 0.01 {
                        info!("{} {} Both exchanges individually flat (hedge executed but may have closed old position)",
                            "[VERIFY]".cyan().bold(),
                            "ℹ".bright_blue().bold()
                        );
                    }
                }
            } else {
                warn!("{} Could not verify net position (failed to fetch from one or both exchanges)",
                    "[VERIFY]".yellow().bold()
                );
            }

            println!();
            info!("{}", "═".repeat(80).bright_green());
            info!("{} TEST PASSED ✓", "[SUCCESS]".bright_green().bold());
            info!("{}", "═".repeat(80).bright_green());
        }
        Ok(None) => {
            warn!("{} Hedge channel closed unexpectedly", "[ERROR]".red().bold());
        }
        Err(_) => {
            warn!("{} Timeout waiting for fill ({}s)",
                "[TIMEOUT]".yellow().bold(),
                max_wait.as_secs()
            );

            info!("{} Checking if order is still open...", "[CHECK]".cyan().bold());
            match pacifica_trading.get_open_orders().await {
                Ok(orders) => {
                    if let Some(order) = orders.iter().find(|o| o.client_order_id == client_order_id) {
                        let filled: f64 = order.filled_amount.parse().unwrap_or(0.0);
                        warn!("{} Order still open. Filled: {}/{}",
                            "[CHECK]".yellow().bold(),
                            filled,
                            order.initial_amount
                        );

                        info!("{} Cancelling order...", "[CLEANUP]".cyan().bold());
                        pacifica_trading.cancel_order(&client_order_id, &config.symbol).await.ok();
                    } else {
                        info!("{} Order no longer in open orders", "[CHECK]".cyan().bold());
                    }
                }
                Err(e) => {
                    warn!("{} Failed to check orders: {}", "[CHECK]".yellow().bold(), e);
                }
            }
        }
    }

    Ok(())
}


================================================================================
FILE: examples\test_btc_orders.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_btc_orders.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{
    OrderbookClient, OrderbookConfig, HyperliquidTrading, HyperliquidCredentials,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test BTC market orders with $20 notional
#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  BTC Market Order Test (0.001 BTC min)");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    use ethers::signers::Signer;
    let wallet: ethers::signers::LocalWallet = credentials.private_key.parse()?;
    let wallet_address = format!("{:?}", wallet.address());
    info!("✓ Loaded credentials for wallet: {}", wallet_address);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client
    info!("Starting orderbook client for BTC...");
    let orderbook_config = OrderbookConfig {
        coin: "BTC".to_string(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
        request_interval_ms: 100,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current BTC prices - Bid: ${:.2}, Ask: ${:.2}, Mid: ${:.2}", bid, ask, mid);

    // Use minimum size 0.001 BTC (minimum notional requirement)
    let size = 0.001;
    let notional = size * mid;
    info!("Size: {:.6} BTC, Expected notional: ${:.2}", size, notional);

    // Create trading client
    let trading_client = HyperliquidTrading::new(credentials, false)?;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 1: BUY {:.6} BTC (~${})", size, notional as u32);
    info!("════════════════════════════════════════════════");
    info!("");

    // Buy BTC
    let (bid, ask) = *prices.lock().unwrap();
    let buy_result = trading_client
        .place_market_order(
            "BTC",
            true,          // is_buy = true
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ BUY order result: {:?}", buy_result);
    info!("");

    // Wait 5 seconds
    info!("Waiting 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 2: SELL {:.6} BTC (~${})", size, notional as u32);
    info!("════════════════════════════════════════════════");
    info!("");

    // Sell BTC (close position)
    let (bid, ask) = *prices.lock().unwrap();
    let sell_result = trading_client
        .place_market_order(
            "BTC",
            false,         // is_buy = false
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ SELL order result: {:?}", sell_result);
    info!("");

    info!("════════════════════════════════════════════════");
    info!("  All BTC tests completed!");
    info!("════════════════════════════════════════════════");
    info!("Exiting in 3 seconds...");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\test_eth_orders.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_eth_orders.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{
    OrderbookClient, OrderbookConfig, HyperliquidTrading, HyperliquidCredentials,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test ETH market orders with $20 notional
#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  ETH Market Order Test ($20 notional)");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    use ethers::signers::Signer;
    let wallet: ethers::signers::LocalWallet = credentials.private_key.parse()?;
    let wallet_address = format!("{:?}", wallet.address());
    info!("✓ Loaded credentials for wallet: {}", wallet_address);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client
    info!("Starting orderbook client for ETH...");
    let orderbook_config = OrderbookConfig {
        coin: "ETH".to_string(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
        request_interval_ms: 100,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current ETH prices - Bid: ${:.2}, Ask: ${:.2}, Mid: ${:.2}", bid, ask, mid);

    // Calculate size for $20 notional
    let target_notional = 20.0;
    let size = target_notional / mid;
    info!("Target notional: ${:.2}, Size: {:.6} ETH", target_notional, size);

    // Create trading client
    let trading_client = HyperliquidTrading::new(credentials, false)?;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 1: BUY {:.6} ETH (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Buy ETH
    let (bid, ask) = *prices.lock().unwrap();
    let buy_result = trading_client
        .place_market_order(
            "ETH",
            true,          // is_buy = true
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ BUY order result: {:?}", buy_result);
    info!("");

    // Wait 5 seconds
    info!("Waiting 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 2: SELL {:.6} ETH (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Sell ETH (close position)
    let (bid, ask) = *prices.lock().unwrap();
    let sell_result = trading_client
        .place_market_order(
            "ETH",
            false,         // is_buy = false
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ SELL order result: {:?}", sell_result);
    info!("");

    info!("════════════════════════════════════════════════");
    info!("  All ETH tests completed!");
    info!("════════════════════════════════════════════════");
    info!("Exiting in 3 seconds...");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\test_hl_l2_snapshot.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_hl_l2_snapshot.rs
================================================================================

/// Test Hyperliquid L2 snapshot REST API
///
/// This example tests fetching orderbook data via Hyperliquid's info endpoint.
/// Verifies that the REST API method works correctly for getting bid/ask prices.
///
/// Run with: cargo run --example test_hl_l2_snapshot --release

use anyhow::{Context, Result};
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("═══════════════════════════════════════════════════");
    println!("  Hyperliquid L2 Snapshot REST API Test");
    println!("═══════════════════════════════════════════════════");
    println!();

    // Load credentials
    dotenv::dotenv().ok();
    let hyperliquid_credentials = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials from environment")?;

    // Initialize trading client
    let hl_trading = HyperliquidTrading::new(hyperliquid_credentials, false)
        .context("Failed to create Hyperliquid trading client")?;

    println!("✓ Trading client initialized");
    println!();

    // Test symbols to fetch
    let test_symbols = vec!["BTC", "ETH", "SOL", "PUMP", "ENA"];

    for symbol in test_symbols {
        println!("Fetching L2 snapshot for {}...", symbol);

        match hl_trading.get_l2_snapshot(symbol).await {
            Ok(Some((bid, ask))) => {
                let mid = (bid + ask) / 2.0;
                let spread = ask - bid;
                let spread_bps = (spread / mid) * 10000.0;

                println!("  ✓ Success:");
                println!("    Bid:    ${:.6}", bid);
                println!("    Ask:    ${:.6}", ask);
                println!("    Mid:    ${:.6}", mid);
                println!("    Spread: ${:.6} ({:.2} bps)", spread, spread_bps);
            }
            Ok(None) => {
                println!("  ⚠ No orderbook data available");
            }
            Err(e) => {
                println!("  ✗ Error: {}", e);
            }
        }

        println!();

        // Small delay between requests to avoid rate limits
        tokio::time::sleep(tokio::time::Duration::from_millis(200)).await;
    }

    println!("═══════════════════════════════════════════════════");
    println!("  Test Complete!");
    println!("═══════════════════════════════════════════════════");

    Ok(())
}


================================================================================
FILE: examples\test_hyperliquid_trade_history.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_hyperliquid_trade_history.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("=== Hyperliquid Trade History Test ===\n");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;
    let wallet_address = std::env::var("HL_WALLET")?;

    println!("Wallet: {}", wallet_address);
    println!();

    // Create trading client (mainnet)
    let trading = HyperliquidTrading::new(credentials, false)?;

    // Get user fills (with aggregation enabled)
    println!("Fetching user fills (aggregated by time)...");
    let fills = trading.get_user_fills(&wallet_address, true).await?;

    println!("Retrieved {} fill(s)\n", fills.len());

    // Display fills (show up to 10 most recent)
    for (i, fill) in fills.iter().take(10).enumerate() {
        println!("--- Fill {} ---", i + 1);
        println!("  Coin: {}", fill.coin);
        println!("  Direction: {}", fill.dir);
        println!("  Side: {}", fill.side);
        println!("  Size: {} {}", fill.sz, fill.coin);
        println!("  Price: ${}", fill.px);

        // Calculate notional value
        let size: f64 = fill.sz.parse().unwrap_or(0.0);
        let price: f64 = fill.px.parse().unwrap_or(0.0);
        let notional = size * price;
        println!("  Notional: ${:.2}", notional);

        // Display fee with percentage
        let fee: f64 = fill.fee.parse().unwrap_or(0.0);
        let fee_bps = if notional > 0.0 { (fee / notional) * 10000.0 } else { 0.0 };
        println!("  Fee: {} {} ({:.2} bps)", fill.fee, fill.fee_token, fee_bps);

        if let Some(builder_fee) = &fill.builder_fee {
            let builder_fee_val: f64 = builder_fee.parse().unwrap_or(0.0);
            let builder_fee_bps = if notional > 0.0 { (builder_fee_val / notional) * 10000.0 } else { 0.0 };
            println!("  Builder Fee: {} {} ({:.2} bps)", builder_fee, fill.fee_token, builder_fee_bps);
        }

        // Convert timestamp to readable format
        let datetime = chrono::DateTime::from_timestamp_millis(fill.time as i64)
            .unwrap()
            .format("%Y-%m-%d %H:%M:%S UTC");
        println!("  Time: {}", datetime);

        println!("  Order ID: {}", fill.oid);
        println!("  Trade ID: {}", fill.tid);
        println!("  Crossed: {}", fill.crossed);
        println!("  Closed PnL: ${}", fill.closed_pnl);
        println!("  Start Position: {}", fill.start_position);

        println!("  Hash: {}", fill.hash);
        println!();
    }

    // Filter for ENA fills
    let ena_fills: Vec<_> = fills.iter()
        .filter(|f| f.coin == "ENA")
        .collect();

    if !ena_fills.is_empty() {
        println!("\n=== ENA Fills ({}) ===\n", ena_fills.len());
        for fill in ena_fills.iter().take(5) {
            let datetime = chrono::DateTime::from_timestamp_millis(fill.time as i64)
                .unwrap()
                .format("%Y-%m-%d %H:%M:%S");

            // Calculate fee in bps
            let size: f64 = fill.sz.parse().unwrap_or(0.0);
            let price: f64 = fill.px.parse().unwrap_or(0.0);
            let notional = size * price;
            let fee: f64 = fill.fee.parse().unwrap_or(0.0);
            let fee_bps = if notional > 0.0 { (fee / notional) * 10000.0 } else { 0.0 };

            println!("  {} - {} {} ENA @ ${} | Fee: {} {} ({:.2} bps)",
                datetime,
                fill.dir,
                fill.sz,
                fill.px,
                fill.fee,
                fill.fee_token,
                fee_bps
            );
        }
    }

    Ok(())
}


================================================================================
FILE: examples\test_meta.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_meta.rs
================================================================================

use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    let client = reqwest::Client::new();
    
    let response = client
        .post("https://api.hyperliquid.xyz/info")
        .json(&serde_json::json!({
            "type": "meta"
        }))
        .send()
        .await?;
    
    let text = response.text().await?;
    
    println!("Meta response:");
    println!("{}", &text[..text.len().min(1000)]);
    
    Ok(())
}


================================================================================
FILE: examples\test_meta_parse.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_meta_parse.rs
================================================================================

use xemm_rust::connector::hyperliquid::{HyperliquidTrading, HyperliquidCredentials};
use anyhow::Result;

#[tokio::main]
async fn main() -> Result<()> {
    dotenv::dotenv().ok();
    
    let credentials = HyperliquidCredentials::from_env()?;
    let trading = HyperliquidTrading::new(credentials, false)?;
    
    println!("Fetching meta...");
    let meta = trading.get_meta().await?;
    
    println!("Successfully parsed meta!");
    println!("Total assets: {}", meta.universe.len());
    println!("\nFirst 5 assets:");
    for (i, asset) in meta.universe.iter().take(5).enumerate() {
        println!("  {}: {} (szDecimals: {}, maxLeverage: {:?})", 
            i, asset.name, asset.sz_decimals, asset.max_leverage);
    }
    
    // Find XPL
    if let Some(xpl) = meta.universe.iter().find(|a| a.name == "XPL") {
        println!("\nFound XPL:");
        println!("  szDecimals: {}", xpl.sz_decimals);
        println!("  maxLeverage: {:?}", xpl.max_leverage);
        println!("  isDelisted: {:?}", xpl.is_delisted);
    }
    
    Ok(())
}


================================================================================
FILE: examples\test_pacifica_positions.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_pacifica_positions.rs
================================================================================

/// Test Pacifica Positions API
///
/// This example tests fetching current positions from Pacifica.
///
/// Usage:
/// ```bash
/// cargo run --example test_pacifica_positions --release
/// ```
///
/// Environment variables required:
/// - PACIFICA_API_KEY
/// - PACIFICA_SECRET_KEY
/// - PACIFICA_ACCOUNT

use anyhow::{Context, Result};
use colored::Colorize;
use xemm_rust::connector::pacifica::{PacificaCredentials, PacificaTrading};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("{}", "═".repeat(60).bright_cyan());
    println!("{}", "  Test Pacifica Positions API".bright_white().bold());
    println!("{}", "═".repeat(60).bright_cyan());
    println!();

    // Load credentials from environment
    let credentials = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials from .env")?;

    println!("{} {}: {}",
        "[INFO]".cyan().bold(),
        "Account".bright_white(),
        credentials.account.yellow()
    );
    println!();

    // Create trading client
    let trading_client = PacificaTrading::new(credentials)
        .context("Failed to create Pacifica trading client")?;

    // Fetch current positions
    println!("{} Fetching positions...", "→".cyan().bold());
    let positions = trading_client.get_positions().await
        .context("Failed to fetch positions")?;

    if positions.is_empty() {
        println!("{} {}",
            "✓".green().bold(),
            "No open positions".bright_white()
        );
    } else {
        println!("{} Found {} position(s):\n",
            "✓".green().bold(),
            positions.len().to_string().bright_white().bold()
        );

        for pos in &positions {
            let side_display = if pos.side == "bid" {
                "LONG".green().bold()
            } else {
                "SHORT".red().bold()
            };

            let amount: f64 = pos.amount.parse().unwrap_or(0.0);
            let entry: f64 = pos.entry_price.parse().unwrap_or(0.0);
            let funding: f64 = pos.funding.parse().unwrap_or(0.0);
            let notional = amount * entry;

            println!("  {} {}",
                pos.symbol.bright_white().bold(),
                side_display
            );
            println!("    Size:     {}", amount.to_string().bright_white());
            println!("    Entry:    ${:.4}", entry.to_string().cyan());
            println!("    Notional: ${:.2}", notional.to_string().bright_white());
            println!("    Funding:  ${:.4}", funding.to_string().yellow());
            println!("    Isolated: {}", pos.isolated);
            println!();
        }

        // Summary
        let total_notional: f64 = positions.iter()
            .map(|p| {
                let amount: f64 = p.amount.parse().unwrap_or(0.0);
                let entry: f64 = p.entry_price.parse().unwrap_or(0.0);
                amount * entry
            })
            .sum();

        println!("{}", "─".repeat(40).bright_black());
        println!("  Total Notional: ${:.2}", total_notional.to_string().bright_white().bold());
    }

    println!();
    println!("{} Test completed successfully", "✓".green().bold());

    Ok(())
}


================================================================================
FILE: examples\test_pacifica_trade_history.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_pacifica_trade_history.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::pacifica::{PacificaCredentials, PacificaTrading};

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("=== Pacifica Trade History Test ===\n");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = PacificaCredentials::from_env()?;

    println!("Account: {}", credentials.account);
    println!();

    // Create trading client
    let trading = PacificaTrading::new(credentials);

    // Get recent trade history for ENA
    println!("Fetching recent ENA trade history...");
    let trades = trading.get_trade_history(
        Some("ENA"),  // symbol
        Some(10),     // limit to 10 most recent trades
        None,         // no start time filter
        None,         // no end time filter
    ).await?;

    println!("Retrieved {} trade(s)\n", trades.len());

    // Display trades
    for (i, trade) in trades.iter().enumerate() {
        println!("--- Trade {} ---", i + 1);
        println!("  History ID: {}", trade.history_id);
        println!("  Order ID: {}", trade.order_id);
        println!("  Symbol: {}", trade.symbol);
        println!("  Side: {}", trade.side);
        println!("  Event Type: {}", trade.event_type);
        println!("  Amount: {} {}", trade.amount, trade.symbol);
        println!("  Fill Price: ${}", trade.entry_price);
        println!("  Market Price: ${}", trade.price);

        // Calculate notional value
        let amount: f64 = trade.amount.parse().unwrap_or(0.0);
        let price: f64 = trade.entry_price.parse().unwrap_or(0.0);
        let notional = amount * price;
        println!("  Notional: ${:.2}", notional);

        // Display fee with percentage
        let fee: f64 = trade.fee.parse().unwrap_or(0.0);
        let fee_bps = if notional > 0.0 { (fee / notional) * 10000.0 } else { 0.0 };
        println!("  Fee: ${} ({:.2} bps)", trade.fee, fee_bps);

        println!("  PnL: ${}", trade.pnl);

        // Convert timestamp to readable format
        let datetime = chrono::DateTime::from_timestamp_millis(trade.created_at as i64)
            .unwrap()
            .format("%Y-%m-%d %H:%M:%S UTC");
        println!("  Time: {}", datetime);
        println!("  Cause: {}", trade.cause);
        println!();
    }

    // Get all recent trades (no symbol filter)
    println!("\nFetching all recent trades (limit 5)...");
    let all_trades = trading.get_trade_history(
        None,     // all symbols
        Some(5),  // limit to 5
        None,
        None,
    ).await?;

    println!("Retrieved {} trade(s) across all symbols\n", all_trades.len());

    for trade in all_trades.iter() {
        let amount: f64 = trade.amount.parse().unwrap_or(0.0);
        let price: f64 = trade.entry_price.parse().unwrap_or(0.0);
        let notional = amount * price;
        let fee: f64 = trade.fee.parse().unwrap_or(0.0);
        let fee_bps = if notional > 0.0 { (fee / notional) * 10000.0 } else { 0.0 };

        println!("  {} - {} {} @ ${} ({}) | Fee: ${} ({:.2} bps)",
            trade.symbol,
            trade.side,
            trade.amount,
            trade.entry_price,
            trade.event_type,
            trade.fee,
            fee_bps
        );
    }

    Ok(())
}


================================================================================
FILE: examples\test_pengu_orders.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_pengu_orders.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{
    OrderbookClient, OrderbookConfig, HyperliquidTrading, HyperliquidCredentials,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test PENGU market orders with $20 notional
#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  PENGU Market Order Test ($20 notional)");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    use ethers::signers::Signer;
    let wallet: ethers::signers::LocalWallet = credentials.private_key.parse()?;
    let wallet_address = format!("{:?}", wallet.address());
    info!("✓ Loaded credentials for wallet: {}", wallet_address);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client
    info!("Starting orderbook client for PENGU...");
    let orderbook_config = OrderbookConfig {
        coin: "PENGU".to_string(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
        request_interval_ms: 100,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current PENGU prices - Bid: ${:.6}, Ask: ${:.6}, Mid: ${:.6}", bid, ask, mid);

    // Calculate size for $20 notional
    let target_notional = 20.0;
    let size = target_notional / mid;
    info!("Target notional: ${:.2}, Size: {:.2} PENGU", target_notional, size);

    // Create trading client
    let trading_client = HyperliquidTrading::new(credentials, false)?;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 1: BUY {:.2} PENGU (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Buy PENGU
    let (bid, ask) = *prices.lock().unwrap();
    let buy_result = trading_client
        .place_market_order(
            "PENGU",
            true,          // is_buy = true
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ BUY order result: {:?}", buy_result);
    info!("");

    // Wait 5 seconds
    info!("Waiting 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 2: SELL {:.2} PENGU (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Sell PENGU (close position)
    let (bid, ask) = *prices.lock().unwrap();
    let sell_result = trading_client
        .place_market_order(
            "PENGU",
            false,         // is_buy = false
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ SELL order result: {:?}", sell_result);
    info!("");

    info!("════════════════════════════════════════════════");
    info!("  All PENGU tests completed!");
    info!("════════════════════════════════════════════════");
    info!("Exiting in 3 seconds...");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\test_price_rounding.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_price_rounding.rs
================================================================================

/// Test price rounding function
fn round_price(price: f64, sz_decimals: i32, is_spot: bool) -> String {
    let max_decimals = ((if is_spot { 8 } else { 6 }) - sz_decimals).max(0);

    // Round to 5 significant figures
    // Calculate the scale factor for 5 sig figs
    let magnitude = price.abs().log10().floor();
    let scale = 10_f64.powf(magnitude - 4.0);
    let rounded_sig_figs = (price / scale).round() * scale;

    // Then limit decimal places
    let capped = format!("{:.prec$}", rounded_sig_figs, prec = max_decimals as usize)
        .parse::<f64>()
        .unwrap();

    // Remove trailing zeros
    let result = capped.to_string();

    // Remove trailing zeros after decimal point
    if result.contains('.') {
        result.trim_end_matches('0').trim_end_matches('.').to_string()
    } else {
        result
    }
}

fn main() {
    println!("Testing price rounding with szDecimals=2 (SOL perp):");
    println!();

    let test_cases = vec![
        (186.66 * 1.05, "BUY with 5% slippage"),
        (186.66 * 0.95, "SELL with 5% slippage"),
        (1234.56, "1234.56"),
        (1234.5, "1234.5"),
        (0.001234, "0.001234"),
        (0.0012345, "0.0012345"),
        (123456.0, "123456 (integer)"),
        (12345.6, "12345.6"),
        (195.998, "195.998 (6 sig figs)"),
        (177.322, "177.322 (6 sig figs)"),
    ];

    for (price, label) in test_cases {
        let rounded = round_price(price, 2, false); // SOL has szDecimals=2, is perp
        println!("{:12} -> {:12} ({})", format!("{:.6}", price), rounded, label);
    }
}


================================================================================
FILE: examples\test_pump_orders.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_pump_orders.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{
    OrderbookClient, OrderbookConfig, HyperliquidTrading, HyperliquidCredentials,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test PUMP market orders with $20 notional
#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  PUMP Market Order Test ($20 notional)");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    use ethers::signers::Signer;
    let wallet: ethers::signers::LocalWallet = credentials.private_key.parse()?;
    let wallet_address = format!("{:?}", wallet.address());
    info!("✓ Loaded credentials for wallet: {}", wallet_address);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client
    info!("Starting orderbook client for PUMP...");
    let orderbook_config = OrderbookConfig {
        coin: "PUMP".to_string(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
        request_interval_ms: 100,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current PUMP prices - Bid: ${:.6}, Ask: ${:.6}, Mid: ${:.6}", bid, ask, mid);

    // Calculate size for $20 notional
    let target_notional = 20.0;
    let size = target_notional / mid;
    info!("Target notional: ${:.2}, Size: {:.2} PUMP", target_notional, size);

    // Create trading client
    let trading_client = HyperliquidTrading::new(credentials, false)?;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 1: BUY {:.2} PUMP (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Buy PUMP
    let (bid, ask) = *prices.lock().unwrap();
    let buy_result = trading_client
        .place_market_order(
            "PUMP",
            true,          // is_buy = true
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ BUY order result: {:?}", buy_result);
    info!("");

    // Wait 5 seconds
    info!("Waiting 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 2: SELL {:.2} PUMP (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Sell PUMP (close position)
    let (bid, ask) = *prices.lock().unwrap();
    let sell_result = trading_client
        .place_market_order(
            "PUMP",
            false,         // is_buy = false
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ SELL order result: {:?}", sell_result);
    info!("");

    info!("════════════════════════════════════════════════");
    info!("  All PUMP tests completed!");
    info!("════════════════════════════════════════════════");
    info!("Exiting in 3 seconds...");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\test_rest_fill_detection.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_rest_fill_detection.rs
================================================================================

/// Test REST API Fill Detection (Backup System)
///
/// This test simulates WebSocket fill detection failure and verifies that
/// REST API polling correctly detects fills and triggers hedges.
///
/// Test Scenario:
/// 1. Place a limit order on Pacifica
/// 2. Simulate WebSocket failure (don't start WebSocket task)
/// 3. Wait for order to fill
/// 4. Verify REST API detects fill within 500ms-1s
/// 5. Verify hedge executes correctly
/// 6. Verify no duplicate hedges
///
/// Usage:
/// ```
/// cargo run --example test_rest_fill_detection --release
/// ```

use anyhow::{Context, Result};
use std::sync::{Arc, Mutex};
use std::time::Duration;
use tokio::sync::mpsc;
use tokio::time::interval;
use tracing::{info, debug};
use colored::Colorize;

use xemm_rust::config::Config;
use xemm_rust::connector::pacifica::{
    OpenOrderItem, PacificaCredentials, PacificaTrading, PacificaWsTrading,
};
use xemm_rust::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};
use xemm_rust::strategy::OrderSide;

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .init();

    println!("\n{}", "═".repeat(80).bright_cyan());
    println!("{}", "REST API Fill Detection Test".bright_white().bold());
    println!("{}", "═".repeat(80).bright_cyan());
    println!();

    // Load configuration
    let config = Config::load().context("Failed to load configuration")?;
    println!("{} Configuration loaded: symbol={}, notional=${}",
        "[TEST]".bright_yellow().bold(),
        config.symbol.bright_white().bold(),
        config.order_notional_usd
    );

    // Load credentials
    let pacifica_credentials = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials")?;
    let hyperliquid_credentials = HyperliquidCredentials::from_env()
        .context("Failed to load Hyperliquid credentials")?;

    println!("{} Credentials loaded", "[TEST]".bright_yellow().bold());

    // Initialize trading clients
    let pacifica_trading = Arc::new(tokio::sync::Mutex::new(
        PacificaTrading::new(pacifica_credentials.clone())
    ));
    let pacifica_ws_trading = Arc::new(
        PacificaWsTrading::new(pacifica_credentials.clone())
    );
    let hyperliquid_trading = Arc::new(
        HyperliquidTrading::new(hyperliquid_credentials, false)?
    );

    println!("{} Trading clients initialized", "[TEST]".bright_yellow().bold());
    println!();

    // Cancel all existing orders first
    println!("{} Cancelling all existing orders...", "[TEST]".bright_yellow().bold());
    match pacifica_trading.lock().await.cancel_all_orders(false, Some(&config.symbol), false).await {
        Ok(count) => println!("{} {} Cancelled {} order(s)", "[TEST]".bright_yellow().bold(), "✓".green().bold(), count),
        Err(e) => println!("{} {} Failed to cancel: {}", "[TEST]".bright_yellow().bold(), "⚠".yellow().bold(), e),
    }
    println!();

    // ═════════════════════════════════════════════════════
    // CRITICAL: Simulating WebSocket Failure
    // We deliberately DO NOT start WebSocket fill detection
    // ═════════════════════════════════════════════════════
    println!("{} {} WebSocket fill detection DISABLED (simulating failure)",
        "[TEST]".bright_yellow().bold(),
        "⚠".red().bold()
    );
    println!("{} REST API is the ONLY fill detection mechanism",
        "[TEST]".bright_yellow().bold()
    );
    println!();

    // ═════════════════════════════════════════════════════
    // REST API Fill Detection (Task 5)
    // ═════════════════════════════════════════════════════

    let processed_fills = Arc::new(tokio::sync::Mutex::new(std::collections::HashSet::<String>::new()));
    let fill_detected = Arc::new(Mutex::new(false));
    let fill_detected_clone = fill_detected.clone();

    let pacifica_trading_rest = pacifica_trading.clone();
    let pacifica_ws_trading_rest = pacifica_ws_trading.clone();
    let symbol_rest = config.symbol.clone();
    let processed_fills_rest = processed_fills.clone();
    let min_hedge_notional = 10.0;

    // Track the order we place
    let active_order_cloid = Arc::new(Mutex::new(Option::<String>::None));
    let active_order_cloid_rest = active_order_cloid.clone();
    let active_order_side = Arc::new(Mutex::new(Option::<OrderSide>::None));
    let active_order_side_rest = active_order_side.clone();

    // Hedge channel
    let (hedge_tx, mut hedge_rx) = mpsc::channel::<(OrderSide, f64, f64)>(1);
    let hedge_tx_rest = hedge_tx.clone();

    tokio::spawn(async move {
        let mut poll_interval = interval(Duration::from_millis(500)); // Poll every 500ms
        poll_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

        let mut consecutive_errors = 0u32;
        let mut last_known_filled_amount: f64 = 0.0;

        loop {
            poll_interval.tick().await;

            // Get active order info
            let cloid_opt = active_order_cloid_rest.lock().unwrap().clone();
            let side_opt = active_order_side_rest.lock().unwrap().clone();

            if cloid_opt.is_none() {
                // No active order yet
                continue;
            }

            let client_order_id = cloid_opt.unwrap();
            let order_side = side_opt.unwrap();

            // Fetch open orders via REST API
            let open_orders_result = pacifica_trading_rest.lock().await.get_open_orders().await;

            match open_orders_result {
                Ok(orders) => {
                    consecutive_errors = 0;

                    // Find our order by client_order_id
                    let our_order = orders.iter().find(|o| o.client_order_id == client_order_id);

                    if let Some(order) = our_order {
                        let filled_amount: f64 = order.filled_amount.parse().unwrap_or(0.0);
                        let initial_amount: f64 = order.initial_amount.parse().unwrap_or(0.0);
                        let price: f64 = order.price.parse().unwrap_or(0.0);

                        // Check if there's a NEW fill
                        if filled_amount > last_known_filled_amount && filled_amount > 0.0 {
                            let new_fill_amount = filled_amount - last_known_filled_amount;
                            let notional_value = new_fill_amount * price;

                            println!("{} {} FILL DETECTED via REST API: {} -> {} (new: {}) | Notional: ${:.2}",
                                "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                "✓".green().bold(),
                                last_known_filled_amount,
                                filled_amount,
                                new_fill_amount,
                                notional_value
                            );

                            last_known_filled_amount = filled_amount;

                            let is_full_fill = (filled_amount - initial_amount).abs() < 0.0001;

                            if is_full_fill || notional_value > min_hedge_notional {
                                let fill_type = if is_full_fill { "full" } else { "partial" };
                                let fill_id = format!("{}_{}_rest", fill_type, client_order_id);

                                // Check duplicate
                                let mut processed = processed_fills_rest.lock().await;
                                if processed.contains(&fill_id) {
                                    debug!("[REST_FILL_DETECTION] Fill already processed, skipping");
                                    continue;
                                }
                                processed.insert(fill_id);
                                drop(processed);

                                *fill_detected_clone.lock().unwrap() = true;

                                println!("{} {} {} FILL: {} {} | Notional: ${}",
                                    "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                    "✓".green().bold(),
                                    if is_full_fill { "FULL" } else { "PARTIAL" },
                                    order.side.bright_yellow(),
                                    filled_amount,
                                    format!("{:.2}", notional_value).cyan().bold()
                                );

                                // Trigger hedge
                                println!("{} Triggering hedge...", "[REST_FILL_DETECTION]".bright_cyan().bold());
                                hedge_tx_rest.send((order_side, filled_amount, price)).await.ok();
                            }
                        }
                    } else {
                        // Order no longer in open orders
                        if last_known_filled_amount > 0.0 {
                            debug!("[REST_FILL_DETECTION] Order no longer in open orders");
                            last_known_filled_amount = 0.0;
                        }
                    }
                }
                Err(e) => {
                    consecutive_errors += 1;
                    debug!("[REST_FILL_DETECTION] Error: {}", e);
                }
            }
        }
    });

    println!("{} REST API fill detection started (polling every 500ms)",
        "[TEST]".bright_yellow().bold()
    );
    println!();

    // ═════════════════════════════════════════════════════
    // Step 1: Place a limit order
    // ═════════════════════════════════════════════════════

    println!("{}", "═".repeat(80).bright_cyan());
    println!("{} {} Place a limit order on Pacifica", "[TEST]".bright_yellow().bold(), "STEP 1:".bright_white().bold());
    println!("{}", "═".repeat(80).bright_cyan());
    println!();

    // Get market info
    let mut trading = pacifica_trading.lock().await;
    let market_info = trading.get_market_info().await?;
    drop(trading);

    // For testing, we'll use a buy order at current bid (likely to fill quickly)
    println!("{} This test requires MANUAL interaction:", "[TEST]".bright_yellow().bold());
    println!("{} 1. The bot will place a LIMIT order", "[TEST]".bright_yellow().bold());
    println!("{} 2. You need to FILL the order manually (use another account)", "[TEST]".bright_yellow().bold());
    println!("{} 3. Or wait for the market to fill it", "[TEST]".bright_yellow().bold());
    println!();
    println!("{} Press ENTER when ready to place order...", "[TEST]".bright_yellow().bold());

    let mut input = String::new();
    std::io::stdin().read_line(&mut input).unwrap();

    // Simplified: Just place a small order and let user fill it
    println!("{} Order placement not implemented in this test stub", "[TEST]".bright_yellow().bold());
    println!("{} To complete this test:", "[TEST]".bright_yellow().bold());
    println!("  1. Run the main bot with a modified version that has a WebSocket kill switch");
    println!("  2. Place an order normally");
    println!("  3. Kill WebSocket fill detection");
    println!("  4. Manually fill the order");
    println!("  5. Observe REST API detecting the fill within 500ms-1s");
    println!();

    println!("{}", "═".repeat(80).bright_cyan());
    println!("{} Test stub complete", "[TEST]".bright_yellow().bold());
    println!("{} Implement full test by adding kill switch to main bot", "[TEST]".bright_yellow().bold());
    println!("{}", "═".repeat(80).bright_cyan());

    Ok(())
}


================================================================================
FILE: examples\test_xpl_orders.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\test_xpl_orders.rs
================================================================================

use anyhow::Result;
use xemm_rust::connector::hyperliquid::{
    OrderbookClient, OrderbookConfig, HyperliquidTrading, HyperliquidCredentials,
};
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::info;

/// Test XPL market orders with $20 notional
#[tokio::main]
async fn main() -> Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    info!("════════════════════════════════════════════════");
    info!("  XPL Market Order Test ($20 notional)");
    info!("════════════════════════════════════════════════");
    info!("");

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = HyperliquidCredentials::from_env()?;

    use ethers::signers::Signer;
    let wallet: ethers::signers::LocalWallet = credentials.private_key.parse()?;
    let wallet_address = format!("{:?}", wallet.address());
    info!("✓ Loaded credentials for wallet: {}", wallet_address);

    // Shared state for current prices
    let prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let prices_clone = prices.clone();

    // Start orderbook client
    info!("Starting orderbook client for XPL...");
    let orderbook_config = OrderbookConfig {
        coin: "XPL".to_string(),
        reconnect_attempts: 5,
        ping_interval_secs: 30,
        request_interval_ms: 100,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    // Spawn orderbook client in background
    tokio::spawn(async move {
        orderbook_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);
            *prices_clone.lock().unwrap() = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial price data
    info!("Waiting for price data...");
    sleep(Duration::from_secs(3)).await;

    // Get current prices
    let (bid, ask) = *prices.lock().unwrap();
    if bid == 0.0 || ask == 0.0 {
        anyhow::bail!("Failed to get valid prices from orderbook");
    }

    let mid = (bid + ask) / 2.0;
    info!("Current XPL prices - Bid: ${:.6}, Ask: ${:.6}, Mid: ${:.6}", bid, ask, mid);

    // Calculate size for $20 notional
    let target_notional = 20.0;
    let size = target_notional / mid;
    info!("Target notional: ${:.2}, Size: {:.2} XPL", target_notional, size);

    // Create trading client
    let trading_client = HyperliquidTrading::new(credentials, false)?;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 1: BUY {:.2} XPL (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Buy XPL
    let (bid, ask) = *prices.lock().unwrap();
    let buy_result = trading_client
        .place_market_order(
            "XPL",
            true,          // is_buy = true
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ BUY order result: {:?}", buy_result);
    info!("");

    // Wait 5 seconds
    info!("Waiting 5 seconds...");
    sleep(Duration::from_secs(5)).await;

    info!("");
    info!("════════════════════════════════════════════════");
    info!("  Test 2: SELL {:.2} XPL (~$20)", size);
    info!("════════════════════════════════════════════════");
    info!("");

    // Sell XPL (close position)
    let (bid, ask) = *prices.lock().unwrap();
    let sell_result = trading_client
        .place_market_order(
            "XPL",
            false,         // is_buy = false
            size,          // size
            0.05,          // 5% slippage
            false,         // reduce_only = false (NEVER true on Hyperliquid)
            Some(bid),
            Some(ask),
        )
        .await?;

    info!("✓ SELL order result: {:?}", sell_result);
    info!("");

    info!("════════════════════════════════════════════════");
    info!("  All XPL tests completed!");
    info!("════════════════════════════════════════════════");
    info!("Exiting in 3 seconds...");

    sleep(Duration::from_secs(3)).await;

    Ok(())
}


================================================================================
FILE: examples\trading_example.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\trading_example.rs
================================================================================

use xemm_rust::connector::pacifica::{
    OrderbookClient, OrderbookConfig, PacificaTrading, PacificaCredentials, OrderSide
};
use tracing::info;
use tokio::time::{sleep, Duration};

/// Example: Place a limit order and cancel it after 10 seconds
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    info!("═══════════════════════════════════════════════════");
    info!("  PACIFICA Trading Example");
    info!("═══════════════════════════════════════════════════");
    info!("This example demonstrates placing and cancelling orders");
    info!("═══════════════════════════════════════════════════");
    info!("");

    // Load credentials from .env
    let credentials = PacificaCredentials::from_env()?;
    info!("[PACIFICA] Loaded credentials for account: {}", credentials.account);

    // Create trading client (mainnet)
    let mut trading_client = PacificaTrading::new(credentials);

    // Create orderbook client to get current prices
    let orderbook_config = OrderbookConfig {
        symbol: "SOL".to_string(),
        agg_level: 1,
        reconnect_attempts: 3,
        ping_interval_secs: 30,
    };

    let mut orderbook_client = OrderbookClient::new(orderbook_config)?;

    info!("[PACIFICA] Connecting to orderbook WebSocket...");

    // Connect to orderbook
    tokio::spawn(async move {
        orderbook_client.start(|_bid, _ask, _symbol, _timestamp| {
            // Just consume updates, don't log
        }).await.ok();
    });

    // Wait for initial orderbook data
    sleep(Duration::from_secs(3)).await;

    // Get current market data
    info!("[PACIFICA] Fetching current SOL prices...");

    // For this example, we'll need to get bid/ask from another source
    // In production, you'd pass the orderbook data from the client above
    // For now, let's use a simple approach with exact price

    let symbol = "SOL";
    let order_size = 0.1; // 0.1 SOL

    // Example 1: Place buy order at 1% below current mid price
    info!("");
    info!("═══════════════════════════════════════════════════");
    info!("  Example 1: Place BUY order with mid price offset");
    info!("═══════════════════════════════════════════════════");

    // You would get these from your orderbook client in production
    let current_bid = 150.0; // Example bid price
    let current_ask = 150.2; // Example ask price

    info!("[PACIFICA] Current market: Bid=${} Ask=${}", current_bid, current_ask);

    let buy_order = trading_client.place_limit_order(
        symbol,
        OrderSide::Buy,
        order_size,
        None,  // Use mid price offset
        1.0,   // 1% below mid price
        Some(current_bid),
        Some(current_ask),
    ).await?;

    let buy_client_order_id = buy_order.client_order_id
        .as_ref()
        .expect("Client order ID should be present")
        .clone();

    info!("[PACIFICA] ✅ Buy order placed successfully!");
    info!("[PACIFICA]    Order ID: {}", buy_order.order_id.unwrap_or(0));
    info!("[PACIFICA]    Client Order ID: {}", buy_client_order_id);
    info!("");

    // Wait 10 seconds
    info!("[PACIFICA] ⏳ Waiting 10 seconds before cancelling...");
    sleep(Duration::from_secs(10)).await;

    // Cancel the buy order
    info!("[PACIFICA] 🗑️  Cancelling buy order...");
    trading_client.cancel_order(symbol, &buy_client_order_id).await?;
    info!("[PACIFICA] ✅ Buy order cancelled successfully!");
    info!("");

    // Example 2: Place sell order at exact price
    info!("═══════════════════════════════════════════════════");
    info!("  Example 2: Place SELL order at exact price");
    info!("═══════════════════════════════════════════════════");

    let exact_sell_price = 151.0; // Specific price
    info!("[PACIFICA] Placing sell order at exact price: ${}", exact_sell_price);

    let sell_order = trading_client.place_limit_order(
        symbol,
        OrderSide::Sell,
        order_size,
        Some(exact_sell_price),  // Exact price
        1.0,   // Not used when exact price is provided
        None,  // Not needed
        None,  // Not needed
    ).await?;

    let sell_client_order_id = sell_order.client_order_id
        .as_ref()
        .expect("Client order ID should be present")
        .clone();

    info!("[PACIFICA] ✅ Sell order placed successfully!");
    info!("[PACIFICA]    Order ID: {}", sell_order.order_id.unwrap_or(0));
    info!("[PACIFICA]    Client Order ID: {}", sell_client_order_id);
    info!("");

    // Wait 10 seconds
    info!("[PACIFICA] ⏳ Waiting 10 seconds before cancelling...");
    sleep(Duration::from_secs(10)).await;

    // Cancel the sell order
    info!("[PACIFICA] 🗑️  Cancelling sell order...");
    trading_client.cancel_order(symbol, &sell_client_order_id).await?;
    info!("[PACIFICA] ✅ Sell order cancelled successfully!");
    info!("");

    info!("═══════════════════════════════════════════════════");
    info!("  Trading Example Complete!");
    info!("═══════════════════════════════════════════════════");

    Ok(())
}


================================================================================
FILE: examples\verify_wallet.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\verify_wallet.rs
================================================================================

use ethers::signers::{LocalWallet, Signer};
use std::str::FromStr;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Load .env
    dotenv::dotenv().ok();

    let hl_wallet = std::env::var("HL_WALLET")?;
    let hl_private_key = std::env::var("HL_PRIVATE_KEY")?;

    println!("HL_WALLET from .env: {}", hl_wallet);
    println!("HL_PRIVATE_KEY from .env: {}", hl_private_key);
    println!();

    // Try parsing with LocalWallet::from_str
    let wallet1 = LocalWallet::from_str(&hl_private_key)?;
    println!("Method 1 - LocalWallet::from_str:");
    println!("  Derived address: {:?}", wallet1.address());
    println!();

    // Try parsing with parse
    let wallet2: LocalWallet = hl_private_key.parse()?;
    println!("Method 2 - parse:");
    println!("  Derived address: {:?}", wallet2.address());
    println!();

    // Check if they match
    let derived_addr = format!("{:?}", wallet1.address());
    println!("Match with HL_WALLET: {}", derived_addr.to_lowercase() == hl_wallet.to_lowercase());

    Ok(())
}


================================================================================
FILE: examples\ws_cancel_all_test.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\ws_cancel_all_test.rs
================================================================================

use anyhow::{Context, Result};
use colored::Colorize;
use tracing::{error, info};
use xemm_rust::config::Config;
use xemm_rust::connector::pacifica::{OrderSide, PacificaCredentials, PacificaTrading, PacificaWsTrading};

/// Test the WebSocket cancel_all_orders functionality
///
/// This test will:
/// 1. Place 2-3 limit orders on Pacifica (using REST API)
/// 2. Use WebSocket cancel_all_orders to cancel them (WEBSOCKET!)
/// 3. Verify that all orders are cancelled
/// 4. Compare with REST API cancel_all_orders
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  WebSocket Cancel All Orders Test".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("");

    // Load configuration
    let config = Config::load_default().context("Failed to load config.json")?;

    // Load credentials
    dotenv::dotenv().ok();
    let credentials = PacificaCredentials::from_env()
        .context("Failed to load Pacifica credentials from environment")?;

    // Create trading clients
    let mut rest_trading = PacificaTrading::new(credentials.clone());
    let ws_trading = PacificaWsTrading::new(credentials.clone(), false); // false = mainnet

    info!("{} Trading clients initialized", "✓".green().bold());

    // Get market info
    let market_info = rest_trading
        .get_market_info()
        .await
        .context("Failed to fetch market info")?;

    let symbol_info = market_info
        .get(&config.symbol)
        .with_context(|| format!("Symbol {} not found", config.symbol))?;

    let tick_size: f64 = symbol_info
        .tick_size
        .parse()
        .context("Failed to parse tick size")?;

    info!(
        "{} Using symbol: {} (tick size: {})",
        "✓".green().bold(),
        config.symbol.bright_white().bold(),
        tick_size
    );

    // Get current market price via REST API
    info!("{} Fetching current market price...", "✓".green().bold());
    let (current_bid, current_ask) = rest_trading
        .get_best_bid_ask_rest(&config.symbol, config.agg_level)
        .await
        .context("Failed to get orderbook")?
        .context("No bid/ask available")?;

    let mid_price = (current_bid + current_ask) / 2.0;
    info!(
        "{} Current market: bid=${:.6}, ask=${:.6}, mid=${:.6}",
        "✓".green().bold(),
        current_bid,
        current_ask,
        mid_price
    );

    println!("");

    // ═══════════════════════════════════════════════════
    // PART 1: Test WebSocket cancel_all_orders
    // ═══════════════════════════════════════════════════

    println!("{}", "═══ PART 1: WebSocket Cancel All Orders ═══".bright_yellow().bold());
    println!("");

    // Step 1: Clear existing orders with REST API
    info!("{} Clearing existing orders (REST API)...", "[SETUP]".cyan().bold());
    match rest_trading
        .cancel_all_orders(false, Some(&config.symbol), false)
        .await
    {
        Ok(count) => info!("{} {} Cleared {} existing order(s)", "[SETUP]".cyan().bold(), "✓".green().bold(), count),
        Err(e) => error!("{} {} Failed: {}", "[SETUP]".cyan().bold(), "✗".red().bold(), e),
    }
    println!("");

    // Step 2: Place test orders via REST API
    info!("{} Placing 3 test orders (REST API)...", "[STEP 1]".blue().bold());

    // Use prices 5% away from market to avoid fills but stay within exchange limits
    let safe_buy_price = current_bid * 0.95; // 5% below current bid
    let safe_sell_price = current_ask * 1.05; // 5% above current ask

    // Calculate size to ensure $11+ notional (safety margin above $10 minimum)
    let min_notional = 11.0;
    let buy_size = (min_notional / safe_buy_price).ceil();
    let sell_size = (min_notional / safe_sell_price).ceil();

    info!(
        "{} Using safe prices: buy=${:.6}, sell=${:.6}",
        "[STEP 1]".blue().bold(),
        safe_buy_price,
        safe_sell_price
    );

    // Place 2 BUY orders
    for i in 1..=2 {
        let price = safe_buy_price - (i as f64 * tick_size * 10.0); // Slightly different prices
        let size = buy_size;

        match rest_trading
            .place_limit_order(
                &config.symbol,
                OrderSide::Buy,
                size,
                Some(price),
                0.0,
                None,
                None,
            )
            .await
        {
            Ok(order_data) => {
                info!(
                    "{} {} BUY order {}: ID={:?}",
                    "[STEP 1]".blue().bold(),
                    "✓".green().bold(),
                    i,
                    order_data.order_id
                );
            }
            Err(e) => {
                error!("{} {} BUY order {} failed: {}", "[STEP 1]".blue().bold(), "✗".red().bold(), i, e);
            }
        }
    }

    // Place 1 SELL order
    match rest_trading
        .place_limit_order(
            &config.symbol,
            OrderSide::Sell,
            sell_size,
            Some(safe_sell_price),
            0.0,
            None,
            None,
        )
        .await
    {
        Ok(order_data) => {
            info!(
                "{} {} SELL order: ID={:?}",
                "[STEP 1]".blue().bold(),
                "✓".green().bold(),
                order_data.order_id
            );
        }
        Err(e) => {
            error!("{} {} SELL order failed: {}", "[STEP 1]".blue().bold(), "✗".red().bold(), e);
        }
    }

    info!("{} {} All test orders placed", "[STEP 1]".blue().bold(), "✓".green().bold());
    println!("");

    // Wait for orders to be registered
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    // Step 3: Cancel all orders via WEBSOCKET
    info!("{} {} Cancelling via WebSocket...", "[STEP 2]".bright_magenta().bold(), "⚡".yellow().bold());
    match ws_trading
        .cancel_all_orders_ws(false, Some(&config.symbol), false)
        .await
    {
        Ok(count) => {
            println!(
                "{} {} {} Successfully cancelled {} order(s)",
                "[STEP 2]".bright_magenta().bold(),
                "⚡".yellow().bold(),
                "✓".green().bold(),
                count.to_string().bright_white().bold()
            );
            if count >= 3 {
                println!("{} {} WebSocket test PASSED!", "[RESULT]".green().bold(), "✓✓✓".green().bold());
            } else {
                error!(
                    "{} {} Expected 3 orders, cancelled {}",
                    "[RESULT]".red().bold(),
                    "✗✗✗".red().bold(),
                    count
                );
            }
        }
        Err(e) => {
            error!("{} {} WebSocket cancel failed: {}", "[STEP 2]".bright_magenta().bold(), "✗".red().bold(), e);
            error!("{} {} WebSocket test FAILED", "[RESULT]".red().bold(), "✗✗✗".red().bold());
        }
    }

    println!("");
    println!("");

    // ═══════════════════════════════════════════════════
    // PART 2: Compare with REST API (for verification)
    // ═══════════════════════════════════════════════════

    println!("{}", "═══ PART 2: REST API Comparison ═══".bright_yellow().bold());
    println!("");

    // Place another set of orders
    info!("{} Placing 3 more test orders (REST API)...", "[STEP 3]".blue().bold());

    for i in 1..=2 {
        let price = safe_buy_price - (i as f64 * tick_size * 10.0);

        rest_trading
            .place_limit_order(
                &config.symbol,
                OrderSide::Buy,
                buy_size,
                Some(price),
                0.0,
                None,
                None,
            )
            .await
            .ok();
    }

    rest_trading
        .place_limit_order(
            &config.symbol,
            OrderSide::Sell,
            sell_size,
            Some(safe_sell_price),
            0.0,
            None,
            None,
        )
        .await
        .ok();

    info!("{} {} Orders placed", "[STEP 3]".blue().bold(), "✓".green().bold());
    println!("");

    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;

    // Cancel via REST API for comparison
    info!("{} Cancelling via REST API...", "[STEP 4]".cyan().bold());
    match rest_trading
        .cancel_all_orders(false, Some(&config.symbol), false)
        .await
    {
        Ok(count) => {
            println!(
                "{} {} Successfully cancelled {} order(s)",
                "[STEP 4]".cyan().bold(),
                "✓".green().bold(),
                count.to_string().bright_white().bold()
            );
            if count >= 3 {
                println!("{} {} REST API test PASSED!", "[RESULT]".green().bold(), "✓✓✓".green().bold());
            }
        }
        Err(e) => {
            error!("{} {} REST API cancel failed: {}", "[STEP 4]".cyan().bold(), "✗".red().bold(), e);
        }
    }

    println!("");
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());
    println!("{}", "  Test Complete".bright_cyan().bold());
    println!("{}", "  Both WebSocket and REST API methods tested".bright_cyan().bold());
    println!("{}", "═══════════════════════════════════════════════════".bright_cyan().bold());

    Ok(())
}


================================================================================
FILE: examples\xemm_calculator.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\examples\xemm_calculator.rs
================================================================================

use xemm_rust::connector::pacifica::{OrderbookClient as PacificaClient, OrderbookConfig as PacificaConfig};
use xemm_rust::connector::hyperliquid::{OrderbookClient as HyperliquidClient, OrderbookConfig as HyperliquidConfig};
use xemm_rust::Config;
use std::sync::{Arc, Mutex};
use tracing::info;
use tokio::time::{sleep, Duration};

/// Cross-Exchange Market Making (XEMM) Price Calculator
/// Continuously calculates optimal limit prices for arbitrage between Pacifica and Hyperliquid
#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info"))
        )
        .init();

    // Load configuration
    let config = Config::load_default()?;
    config.validate()?;

    info!("═══════════════════════════════════════════════════");
    info!("  XEMM Price Calculator");
    info!("═══════════════════════════════════════════════════");
    info!("Symbol: {}", config.symbol);
    info!("Pacifica Maker Fee: {} bps", config.pacifica_maker_fee_bps);
    info!("Hyperliquid Taker Fee: {} bps", config.hyperliquid_taker_fee_bps);
    info!("Target Profit: {} bps", config.profit_rate_bps);
    info!("═══════════════════════════════════════════════════");
    info!("");

    // Convert fees from bps to decimal
    let maker_fee = config.pacifica_maker_fee_bps / 10000.0;
    let taker_fee = config.hyperliquid_taker_fee_bps / 10000.0;
    let profit_rate = config.profit_rate_bps / 10000.0;

    // Shared state for orderbook prices
    let pacifica_prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
    let hyperliquid_prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)

    let pac_prices_clone = pacifica_prices.clone();
    let hl_prices_clone = hyperliquid_prices.clone();

    // Start Pacifica orderbook client
    let pacifica_config = PacificaConfig {
        symbol: config.symbol.clone(),
        agg_level: config.agg_level,
        reconnect_attempts: config.reconnect_attempts,
        ping_interval_secs: config.ping_interval_secs,
    };

    let mut pacifica_client = PacificaClient::new(pacifica_config)?;

    tokio::spawn(async move {
        pacifica_client.start(move |bid, ask, _symbol, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);

            let mut p = pac_prices_clone.lock().unwrap();
            *p = (bid_price, ask_price);
        }).await.ok();
    });

    // Start Hyperliquid orderbook client
    let hyperliquid_config = HyperliquidConfig {
        coin: config.symbol.clone(),
        reconnect_attempts: config.reconnect_attempts,
        ping_interval_secs: config.ping_interval_secs,
        request_interval_ms: 50,  // Request every 50ms (20 Hz)
    };

    let mut hyperliquid_client = HyperliquidClient::new(hyperliquid_config)?;

    tokio::spawn(async move {
        hyperliquid_client.start(move |bid, ask, _coin, _timestamp| {
            let bid_price: f64 = bid.parse().unwrap_or(0.0);
            let ask_price: f64 = ask.parse().unwrap_or(0.0);

            let mut p = hl_prices_clone.lock().unwrap();
            *p = (bid_price, ask_price);
        }).await.ok();
    });

    // Wait for initial data
    info!("[XEMM] Waiting for orderbook data...");
    sleep(Duration::from_secs(3)).await;

    info!("[XEMM] Starting continuous calculation...");
    info!("Update frequency: ~100 Hz (every 10ms)");
    info!("Display: Updates shown when opportunity changes or every 100 iterations");
    info!("");

    // Track last state for change detection
    let mut last_direction = String::new();
    let mut last_price = 0.0;
    let mut iteration_count = 0u64;

    // Main calculation loop - runs every 10ms
    loop {
        sleep(Duration::from_millis(10)).await;
        iteration_count += 1;

        // Get current prices
        let (pac_bid, pac_ask) = *pacifica_prices.lock().unwrap();
        let (hl_bid, hl_ask) = *hyperliquid_prices.lock().unwrap();

        // Validate prices
        if pac_bid == 0.0 || pac_ask == 0.0 || hl_bid == 0.0 || hl_ask == 0.0 {
            continue;
        }

        let pac_mid = (pac_bid + pac_ask) / 2.0;

        // Calculate BUY limit price on Pacifica
        // BUY on Pacifica → SELL (taker) on Hyperliquid
        // buyLimitPrice = (HL_bid * (1 - takerFee)) / (1 + makerFee + profitRate)
        let buy_limit_price = (hl_bid * (1.0 - taker_fee)) / (1.0 + maker_fee + profit_rate);
        let buy_limit_rounded = round_price_down(buy_limit_price, 0.01); // Assuming 0.01 tick size

        // Calculate SELL limit price on Pacifica
        // SELL on Pacifica → BUY (taker) on Hyperliquid
        // sellLimitPrice = (HL_ask * (1 + takerFee)) / (1 - makerFee - profitRate)
        let sell_limit_price = (hl_ask * (1.0 + taker_fee)) / (1.0 - maker_fee - profit_rate);
        let sell_limit_rounded = round_price_up(sell_limit_price, 0.01); // Assuming 0.01 tick size

        // Calculate actual profitability after rounding (in bps)
        // BUY on Pacifica → SELL on Hyperliquid
        let buy_cost = buy_limit_rounded * (1.0 + maker_fee); // Cost to buy on Pacifica
        let buy_revenue = hl_bid * (1.0 - taker_fee); // Revenue from selling on Hyperliquid
        let buy_profit_rate = (buy_revenue - buy_cost) / buy_cost;
        let buy_profit_bps = buy_profit_rate * 10000.0;

        // SELL on Pacifica → BUY on Hyperliquid
        let sell_revenue = sell_limit_rounded * (1.0 - maker_fee); // Revenue from selling on Pacifica
        let sell_cost = hl_ask * (1.0 + taker_fee); // Cost to buy on Hyperliquid
        let sell_profit_rate = (sell_revenue - sell_cost) / sell_cost;
        let sell_profit_bps = sell_profit_rate * 10000.0;

        // Determine which is closer to mid price
        let buy_distance = (pac_mid - buy_limit_rounded).abs();
        let sell_distance = (sell_limit_rounded - pac_mid).abs();

        let (selected_direction, selected_price, selected_profit_bps) = if buy_distance < sell_distance {
            ("BUY", buy_limit_rounded, buy_profit_bps)
        } else {
            ("SELL", sell_limit_rounded, sell_profit_bps)
        };

        // Calculate spreads
        let pac_spread = pac_ask - pac_bid;
        let hl_spread = hl_ask - hl_bid;

        // Only display if something meaningful changed or every 100 iterations (~1 second)
        let direction_changed = selected_direction != last_direction;
        let price_changed = (selected_price - last_price).abs() > 0.01;
        let should_display = direction_changed || price_changed || iteration_count % 100 == 0;

        if should_display {
            info!("═══════════════════════════════════════════════════");
            info!("PACIFICA   | Bid: ${:.2} | Ask: ${:.2} | Mid: ${:.2} | Spread: ${:.3}",
                  pac_bid, pac_ask, pac_mid, pac_spread);
            info!("HYPERLIQUID| Bid: ${:.2} | Ask: ${:.2} | Mid: ${:.2} | Spread: ${:.3}",
                  hl_bid, hl_ask, (hl_bid + hl_ask) / 2.0, hl_spread);
            info!("───────────────────────────────────────────────────");
            info!("BUY  Limit: ${:.2} | Distance: ${:.3} | Profit: {:.2} bps",
                  buy_limit_rounded, buy_distance, buy_profit_bps);
            info!("SELL Limit: ${:.2} | Distance: ${:.3} | Profit: {:.2} bps",
                  sell_limit_rounded, sell_distance, sell_profit_bps);
            info!("───────────────────────────────────────────────────");
            info!(">>> SELECTED: {} @ ${:.2} | Profit: {:.2} bps | Iter: {} <<<",
                  selected_direction, selected_price, selected_profit_bps, iteration_count);
            info!("═══════════════════════════════════════════════════");
            info!("");
        }

        // Update last state
        last_direction = selected_direction.to_string();
        last_price = selected_price;
    }
}

/// Round price down to nearest tick size (for BUY orders)
fn round_price_down(price: f64, tick_size: f64) -> f64 {
    (price / tick_size).floor() * tick_size
}

/// Round price up to nearest tick size (for SELL orders)
fn round_price_up(price: f64, tick_size: f64) -> f64 {
    (price / tick_size).ceil() * tick_size
}


================================================================================
FILE: src\app.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\app.rs
================================================================================

use anyhow::{Context, Result};
use colored::Colorize;
use std::collections::HashSet;
use std::sync::Arc;
use std::sync::atomic::AtomicU8;
use parking_lot::Mutex;
use std::time::{Duration, Instant};
use tokio::signal;
use tokio::sync::{mpsc, RwLock};
use tokio::time::interval;
use tracing::debug;

use crate::bot::{ActiveOrder, BotState, BotStatus};
use crate::config::Config;
use crate::connector::hyperliquid::{HyperliquidCredentials, HyperliquidTrading};
use crate::connector::pacifica::{
    FillDetectionClient, FillDetectionConfig, PacificaCredentials, PacificaTrading,
    PacificaWsTrading, OrderSide as PacificaOrderSide,
};
use crate::services::{
    fill_detection::FillDetectionService, hedge::HedgeService,
    order_monitor::{AtomicBotStatus, OrderMonitorService, SharedOrderSnapshot, spawn_monitor_tasks, sync_atomic_status, update_order_snapshot},
    orderbook::{HyperliquidOrderbookService, PacificaOrderbookService},
    position_monitor::PositionMonitorService, rest_fill_detection::RestFillDetectionService,
    rest_poll::{HyperliquidRestPollService, PacificaRestPollService}, HedgeEvent,
};
use crate::strategy::{OpportunityEvaluator, OrderSide};
use crate::util::rate_limit::{is_rate_limit_error, RateLimitTracker};

// Macro for timestamped colored output
macro_rules! tprintln {
    ($($arg:tt)*) => {{
        println!("{} {}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string().bright_black(),
            format!($($arg)*)
        );
    }};
}

/// Position snapshot for tracking position deltas
#[derive(Debug, Clone)]
pub struct PositionSnapshot {
    pub amount: f64,
    pub side: String, // "bid" or "ask"
    pub last_check: Instant,
}

/// XemmBot - Main application structure that encapsulates all bot components
pub struct XemmBot {
    pub config: Config,
    pub bot_state: Arc<RwLock<BotState>>,

    // Trading clients (each task gets its own instance to avoid lock contention)
    pub pacifica_trading_main: Arc<PacificaTrading>,
    pub pacifica_trading_fill: Arc<PacificaTrading>,
    pub pacifica_trading_rest_fill: Arc<PacificaTrading>,
    pub pacifica_trading_monitor: Arc<PacificaTrading>,
    pub pacifica_trading_hedge: Arc<PacificaTrading>,
    pub pacifica_trading_rest_poll: Arc<PacificaTrading>,
    pub pacifica_ws_trading: Arc<PacificaWsTrading>,
    pub hyperliquid_trading: Arc<HyperliquidTrading>,

    // Shared state (prices)
    pub pacifica_prices: Arc<Mutex<(f64, f64)>>, // (bid, ask)
    pub hyperliquid_prices: Arc<Mutex<(f64, f64)>>, // (bid, ask)

    // Opportunity evaluator
    pub evaluator: OpportunityEvaluator,

    // Fill tracking state
    pub processed_fills: Arc<parking_lot::Mutex<HashSet<String>>>,
    pub last_position_snapshot: Arc<parking_lot::Mutex<Option<PositionSnapshot>>>,

    // Order monitor state (lock-free)
    pub atomic_status: Arc<AtomicU8>,
    pub order_snapshot: Arc<SharedOrderSnapshot>,

    // Channels
    pub hedge_tx: mpsc::UnboundedSender<HedgeEvent>,
    pub hedge_rx: Option<mpsc::UnboundedReceiver<HedgeEvent>>,
    pub shutdown_tx: mpsc::Sender<()>,
    pub shutdown_rx: Option<mpsc::Receiver<()>>,

    // Credentials (needed for spawning services)
    pub pacifica_credentials: PacificaCredentials,
}

impl XemmBot {
    /// Create and initialize a new XemmBot instance
    ///
    /// This performs all the wiring:
    /// - Loads config and validates it
    /// - Loads credentials from environment
    /// - Creates all trading clients
    /// - Pre-fetches Hyperliquid metadata
    /// - Cancels existing orders
    /// - Fetches Pacifica tick size
    /// - Creates OpportunityEvaluator
    /// - Initializes shared state and channels
    pub async fn new() -> Result<Self> {
        use colored::Colorize;

        println!(
            "{} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "═══════════════════════════════════════════════════"
                .bright_cyan()
                .bold()
        );
        println!(
            "{} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "  XEMM Bot - Cross-Exchange Market Making"
                .bright_cyan()
                .bold()
        );
        println!(
            "{} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "═══════════════════════════════════════════════════"
                .bright_cyan()
                .bold()
        );
        println!();

        // Load configuration
        let config = Config::load_default().context("Failed to load config.json")?;
        config.validate().context("Invalid configuration")?;

        println!(
            "{} {} Symbol: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            config.symbol.bright_white().bold()
        );
        println!(
            "{} {} Order Notional: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("${:.2}", config.order_notional_usd).bright_white()
        );
        println!(
            "{} {} Pacifica Maker Fee: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} bps", config.pacifica_maker_fee_bps).bright_white()
        );
        println!(
            "{} {} Hyperliquid Taker Fee: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} bps", config.hyperliquid_taker_fee_bps).bright_white()
        );
        println!(
            "{} {} Target Profit: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} bps", config.profit_rate_bps).green().bold()
        );
        println!(
            "{} {} Profit Cancel Threshold: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} bps", config.profit_cancel_threshold_bps).yellow()
        );
        println!(
            "{} {} Order Refresh Interval: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} secs", config.order_refresh_interval_secs).bright_white()
        );
        println!(
            "{} {} Pacifica REST Poll Interval: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} secs", config.pacifica_rest_poll_interval_secs).bright_white()
        );
        println!(
            "{} {} Active Order REST Poll Interval: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{} ms", config.pacifica_active_order_rest_poll_interval_ms).bright_white()
        );
        println!(
            "{} {} Hyperliquid Market Order maximum allowed Slippage: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[CONFIG]".blue().bold(),
            format!("{}%", config.hyperliquid_slippage * 100.0).bright_white()
        );
        println!();

        // Load credentials
        dotenv::dotenv().ok();
        let pacifica_credentials =
            PacificaCredentials::from_env().context("Failed to load Pacifica credentials from environment")?;
        let hyperliquid_credentials =
            HyperliquidCredentials::from_env().context("Failed to load Hyperliquid credentials from environment")?;

        println!(
            "{} {} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            "Credentials loaded successfully".green()
        );

        // Initialize trading clients
        let pacifica_trading_main = Arc::new(
            PacificaTrading::new(pacifica_credentials.clone())
                .context("Failed to create main Pacifica trading client")?,
        );
        let pacifica_trading_fill = Arc::new(
            PacificaTrading::new(pacifica_credentials.clone())
                .context("Failed to create fill detection Pacifica trading client")?,
        );
        let pacifica_trading_rest_fill = Arc::new(
            PacificaTrading::new(pacifica_credentials.clone())
                .context("Failed to create REST fill detection Pacifica trading client")?,
        );
        let pacifica_trading_monitor = Arc::new(
            PacificaTrading::new(pacifica_credentials.clone())
                .context("Failed to create monitor Pacifica trading client")?,
        );
        let pacifica_trading_hedge = Arc::new(
            PacificaTrading::new(pacifica_credentials.clone())
                .context("Failed to create hedge Pacifica trading client")?,
        );
        let pacifica_trading_rest_poll = Arc::new(
            PacificaTrading::new(pacifica_credentials.clone())
                .context("Failed to create REST polling Pacifica trading client")?,
        );

        // Initialize WebSocket trading client for ultra-fast cancellations
        let pacifica_ws_trading = Arc::new(PacificaWsTrading::new(pacifica_credentials.clone(), false)); // false = mainnet

        let hyperliquid_trading = Arc::new(
            HyperliquidTrading::new(hyperliquid_credentials, false)
                .context("Failed to create Hyperliquid trading client")?,
        );

        println!(
            "{} {} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            "Trading clients initialized (6 REST instances + WebSocket)".green()
        );

        // Pre-fetch Hyperliquid metadata (szDecimals, etc.) to reduce hedge latency
        println!(
            "{} {} Pre-fetching Hyperliquid metadata for {}...",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            config.symbol.bright_white()
        );
        hyperliquid_trading
            .get_meta()
            .await
            .context("Failed to pre-fetch Hyperliquid metadata")?;
        println!(
            "{} {} {} Hyperliquid metadata cached",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            "✓".green().bold()
        );

        // Cancel any existing orders on Pacifica at startup
        println!(
            "{} {} Cancelling any existing orders on Pacifica...",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold()
        );
        match pacifica_trading_main
            .cancel_all_orders(false, Some(&config.symbol), false)
            .await
        {
            Ok(count) => println!(
                "{} {} {} Cancelled {} existing order(s)",
                chrono::Utc::now()
                    .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                    .to_string()
                    .bright_black(),
                "[INIT]".cyan().bold(),
                "✓".green().bold(),
                count
            ),
            Err(e) => println!(
                "{} {} {} Failed to cancel existing orders: {}",
                chrono::Utc::now()
                    .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                    .to_string()
                    .bright_black(),
                "[INIT]".cyan().bold(),
                "⚠".yellow().bold(),
                e
            ),
        }

        // Get market info to determine tick size
        let pacifica_tick_size: f64 = {
            let market_info = pacifica_trading_main
                .get_market_info()
                .await
                .context("Failed to fetch Pacifica market info")?;
            let symbol_info = market_info
                .get(&config.symbol)
                .with_context(|| format!("Symbol {} not found in market info", config.symbol))?;
            symbol_info.tick_size.parse().context("Failed to parse tick size")?
        };

        println!(
            "{} {} Pacifica tick size for {}: {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            config.symbol.bright_white(),
            format!("{}", pacifica_tick_size).bright_white()
        );

        // Create opportunity evaluator
        let evaluator = OpportunityEvaluator::new(
            config.pacifica_maker_fee_bps,
            config.hyperliquid_taker_fee_bps,
            config.profit_rate_bps,
            pacifica_tick_size,
        );

        println!(
            "{} {} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            "Opportunity evaluator created".green()
        );

        // Shared state for orderbook prices
        let pacifica_prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)
        let hyperliquid_prices = Arc::new(Mutex::new((0.0, 0.0))); // (bid, ask)

        // Shared bot state
        let bot_state = Arc::new(RwLock::new(BotState::new()));

        // Channels for communication
        // Unbounded hedge event queue: producers never block when enqueueing,
        // hedge executor processes events sequentially.
        let (hedge_tx, hedge_rx) = mpsc::unbounded_channel::<HedgeEvent>(); // (side, size, avg_price, fill_timestamp)
        let (shutdown_tx, shutdown_rx) = mpsc::channel::<()>(1);

        // Fill tracking state
        let processed_fills = Arc::new(parking_lot::Mutex::new(HashSet::<String>::new()));
        let last_position_snapshot = Arc::new(parking_lot::Mutex::new(Option::<PositionSnapshot>::None));

        println!(
            "{} {} {}",
            chrono::Utc::now()
                .format("%Y-%m-%dT%H:%M:%S%.6fZ")
                .to_string()
                .bright_black(),
            "[INIT]".cyan().bold(),
            "State and channels initialized".green()
        );
        println!();

        // Initialize order monitor state
        let atomic_status = Arc::new(AtomicU8::new(AtomicBotStatus::Idle as u8));
        let order_snapshot = Arc::new(SharedOrderSnapshot::new());

        Ok(XemmBot {
            config,
            bot_state,
            pacifica_trading_main,
            pacifica_trading_fill,
            pacifica_trading_rest_fill,
            pacifica_trading_monitor,
            pacifica_trading_hedge,
            pacifica_trading_rest_poll,
            pacifica_ws_trading,
            hyperliquid_trading,
            pacifica_prices,
            hyperliquid_prices,
            evaluator,
            processed_fills,
            last_position_snapshot,
            atomic_status,
            order_snapshot,
            hedge_tx,
            hedge_rx: Some(hedge_rx),
            shutdown_tx,
            shutdown_rx: Some(shutdown_rx),
            pacifica_credentials,
        })
    }

    /// Run the bot - spawn all services and execute main loop
    pub async fn run(mut self) -> Result<()> {
        // ═══════════════════════════════════════════════════
        // SPAWN ALL SERVICES
        // ═══════════════════════════════════════════════════

        // Service 1: Pacifica Orderbook (WebSocket)
        let pacifica_ob_service = PacificaOrderbookService {
            prices: self.pacifica_prices.clone(),
            symbol: self.config.symbol.clone(),
            agg_level: self.config.agg_level,
            reconnect_attempts: self.config.reconnect_attempts,
            ping_interval_secs: self.config.ping_interval_secs,
        };
        tokio::spawn(async move {
            pacifica_ob_service.run().await.ok();
        });

        // Service 2: Hyperliquid Orderbook (WebSocket)
        let hyperliquid_ob_service = HyperliquidOrderbookService {
            prices: self.hyperliquid_prices.clone(),
            symbol: self.config.symbol.clone(),
            reconnect_attempts: self.config.reconnect_attempts,
            ping_interval_secs: self.config.ping_interval_secs,
        };
        tokio::spawn(async move {
            hyperliquid_ob_service.run().await.ok();
        });
        let fill_config = FillDetectionConfig {
            account: self.pacifica_credentials.account.clone(),
            reconnect_attempts: self.config.reconnect_attempts,
            ping_interval_secs: self.config.ping_interval_secs,
            enable_position_fill_detection: true,
        };
        let fill_client = FillDetectionClient::new(fill_config.clone(), false)
            .context("Failed to create fill detection client")?;
        let baseline_updater = fill_client.get_baseline_updater();

        let fill_service = FillDetectionService {
            bot_state: self.bot_state.clone(),
            hedge_tx: self.hedge_tx.clone(),
            pacifica_trading: self.pacifica_trading_fill.clone(),
            pacifica_ws_trading: self.pacifica_ws_trading.clone(),
            fill_config,
            symbol: self.config.symbol.clone(),
            processed_fills: self.processed_fills.clone(),
            baseline_updater,
            atomic_status: self.atomic_status.clone(),
            order_snapshot: self.order_snapshot.clone(),
        };
        tokio::spawn(async move {
            fill_service.run().await;
        });

        // Service 4: Pacifica REST Poll (price redundancy)
        let pacifica_rest_poll_service = PacificaRestPollService {
            prices: self.pacifica_prices.clone(),
            pacifica_trading: self.pacifica_trading_rest_poll.clone(),
            symbol: self.config.symbol.clone(),
            agg_level: self.config.agg_level,
            poll_interval_secs: self.config.pacifica_rest_poll_interval_secs,
        };
        tokio::spawn(async move {
            pacifica_rest_poll_service.run().await;
        });

        // Service 4.5: Hyperliquid REST Poll (price redundancy)
        let hyperliquid_rest_poll_service = HyperliquidRestPollService {
            prices: self.hyperliquid_prices.clone(),
            hyperliquid_trading: self.hyperliquid_trading.clone(),
            symbol: self.config.symbol.clone(),
            poll_interval_secs: 2,
        };
        tokio::spawn(async move {
            hyperliquid_rest_poll_service.run().await;
        });

        // Wait for initial orderbook data
        tprintln!("{} Waiting for orderbook data...", "[INIT]".cyan().bold());
        tokio::time::sleep(Duration::from_secs(3)).await;

        // Service 5: REST Fill Detection (backup)
        let rest_fill_service = RestFillDetectionService {
            bot_state: self.bot_state.clone(),
            hedge_tx: self.hedge_tx.clone(),
            pacifica_trading: self.pacifica_trading_rest_fill.clone(),
            pacifica_ws_trading: self.pacifica_ws_trading.clone(),
            symbol: self.config.symbol.clone(),
            processed_fills: self.processed_fills.clone(),
            min_hedge_notional: 10.0,
            poll_interval_ms: self.config.pacifica_active_order_rest_poll_interval_ms,
        };
        tokio::spawn(async move {
            rest_fill_service.run().await;
        });
        tokio::time::sleep(Duration::from_millis(100)).await;

        // Service 5.5: Position Monitor (ground truth)
        let pacifica_trading_position = Arc::new(
            PacificaTrading::new(self.pacifica_credentials.clone())
                .context("Failed to create position monitor trading client")?
        );
        let position_monitor_service = PositionMonitorService {
            bot_state: self.bot_state.clone(),
            hedge_tx: self.hedge_tx.clone(),
            pacifica_trading: pacifica_trading_position,
            pacifica_ws_trading: self.pacifica_ws_trading.clone(),
            symbol: self.config.symbol.clone(),
            processed_fills: self.processed_fills.clone(),
            last_position_snapshot: self.last_position_snapshot.clone(),
        };
        tokio::spawn(async move {
            position_monitor_service.run().await;
        });
        tokio::time::sleep(Duration::from_millis(100)).await;

        // Service 6: Order Monitor (age/profit monitoring)
        let (order_monitor_service, cancel_rx) = OrderMonitorService::new(
            self.bot_state.clone(),
            self.atomic_status.clone(),
            self.order_snapshot.clone(),
            self.pacifica_prices.clone(),
            self.hyperliquid_prices.clone(),
            self.config.clone(),
            self.evaluator.clone(),
            self.pacifica_trading_monitor.clone(),
            self.hyperliquid_trading.clone(),
        );
        let order_monitor_service = Arc::new(order_monitor_service);
        spawn_monitor_tasks(order_monitor_service, cancel_rx);

        // Service 7: Hedge Execution
        let hedge_service = HedgeService {
            bot_state: self.bot_state.clone(),
            hedge_rx: self.hedge_rx.take().unwrap(),
            hyperliquid_prices: self.hyperliquid_prices.clone(),
            config: self.config.clone(),
            hyperliquid_trading: self.hyperliquid_trading.clone(),
            pacifica_trading: self.pacifica_trading_hedge.clone(),
            shutdown_tx: self.shutdown_tx.clone(),
        };
        tokio::spawn(async move {
            hedge_service.run().await;
        });

        // ═══════════════════════════════════════════════════
        // MAIN OPPORTUNITY EVALUATION LOOP
        // ═══════════════════════════════════════════════════

        tprintln!("{} Starting opportunity evaluation loop",
            format!("[{} MAIN]", self.config.symbol).bright_white().bold()
        );
        tprintln!("");

        let mut eval_interval = interval(Duration::from_millis(1));
        let mut order_placement_rate_limit = RateLimitTracker::new();

        // Helper async function to wait for SIGTERM
        async fn wait_for_sigterm() {
            #[cfg(unix)]
            {
                let mut sigterm = tokio::signal::unix::signal(tokio::signal::unix::SignalKind::terminate())
                    .expect("Failed to setup SIGTERM handler");
                sigterm.recv().await;
            }

            #[cfg(not(unix))]
            {
                std::future::pending::<()>().await;
            }
        }

        let mut shutdown_rx = self.shutdown_rx.take().unwrap();

        loop {
            tokio::select! {
                _ = signal::ctrl_c() => {
                    tprintln!("{} {} Received SIGINT (Ctrl+C), initiating graceful shutdown...",
                        format!("[{} MAIN]", self.config.symbol).bright_white().bold(),
                        "⚠".yellow().bold()
                    );
                    break;
                }

                _ = wait_for_sigterm() => {
                    tprintln!("{} {} Received SIGTERM (Docker shutdown), initiating graceful shutdown...",
                        format!("[{} MAIN]", self.config.symbol).bright_white().bold(),
                        "⚠".yellow().bold()
                    );
                    break;
                }

                _ = eval_interval.tick() => {
                    // Check if we should exit
                    let state = self.bot_state.read().await;
                    if state.is_terminal() {
                        break;
                    }

                    // Only evaluate if idle
                    if !state.is_idle() {
                        continue;
                    }

                    // Check grace period
                    if !state.grace_period_elapsed(3) {
                        continue;
                    }
                    drop(state);

                    // Check rate limit backoff
                    if order_placement_rate_limit.should_skip() {
                        let remaining = order_placement_rate_limit.remaining_backoff_secs();
                        if remaining as u64 % 5 == 0 || remaining < 1.0 {
                            debug!("[MAIN] Skipping order placement (rate limit backoff, {:.1}s remaining)", remaining);
                        }
                        continue;
                    }

                    // Get current prices
                    let (pac_bid, pac_ask) = *self.pacifica_prices.lock();
                    let (hl_bid, hl_ask) = *self.hyperliquid_prices.lock();

                    // Validate prices
                    if pac_bid == 0.0 || pac_ask == 0.0 || hl_bid == 0.0 || hl_ask == 0.0 {
                        continue;
                    }

                    // Get timestamp once for this evaluation cycle
                    let now_ms = std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap()
                        .as_millis() as u64;

                    // Evaluate opportunities
                    let buy_opp = self.evaluator.evaluate_buy_opportunity(hl_bid, self.config.order_notional_usd, now_ms);
                    let sell_opp = self.evaluator.evaluate_sell_opportunity(hl_ask, self.config.order_notional_usd, now_ms);

                    let pac_mid = (pac_bid + pac_ask) / 2.0;
                    let best_opp = OpportunityEvaluator::pick_best_opportunity(buy_opp, sell_opp, pac_mid);

                    if let Some(opp) = best_opp {
                        // Double-check bot is still idle
                        let mut state = self.bot_state.write().await;
                        if !state.is_idle() {
                            continue;
                        }

                        tprintln!(
                            "{} {} @ {} → HL {} | Size: {} | Profit: {} | PAC: {}/{} | HL: {}/{}",
                            format!("[{} OPPORTUNITY]", self.config.symbol).bright_green().bold(),
                            opp.direction.as_str().bright_yellow().bold(),
                            format!("${:.6}", opp.pacifica_price).cyan().bold(),
                            format!("${:.6}", opp.hyperliquid_price).cyan(),
                            format!("{:.4}", opp.size).bright_white(),
                            format!("{:.2} bps", opp.initial_profit_bps).green().bold(),
                            format!("${:.6}", pac_bid).cyan(),
                            format!("${:.6}", pac_ask).cyan(),
                            format!("${:.6}", hl_bid).cyan(),
                            format!("${:.6}", hl_ask).cyan()
                        );

                        // Place order
                        tprintln!("{} Placing {} on Pacifica...",
                            format!("[{} ORDER]", self.config.symbol).bright_yellow().bold(),
                            opp.direction.as_str().bright_yellow().bold()
                        );

                        let pacifica_side = match opp.direction {
                            OrderSide::Buy => PacificaOrderSide::Buy,
                            OrderSide::Sell => PacificaOrderSide::Sell,
                        };

                        match self.pacifica_trading_main
                            .place_limit_order(
                                &self.config.symbol,
                                pacifica_side,
                                opp.size,
                                Some(opp.pacifica_price),
                                0.0,
                                Some(pac_bid),
                                Some(pac_ask),
                            )
                            .await
                        {
                            Ok(order_data) => {
                                order_placement_rate_limit.record_success();

                                if let Some(client_order_id) = order_data.client_order_id {
                                    let order_id = order_data.order_id.unwrap_or(0);
                                    tprintln!(
                                        "{} {} Placed {} #{} @ {} | cloid: {}...{}",
                                        format!("[{} ORDER]", self.config.symbol).bright_yellow().bold(),
                                        "✓".green().bold(),
                                        opp.direction.as_str().bright_yellow(),
                                        order_id,
                                        format!("${:.4}", opp.pacifica_price).cyan().bold(),
                                        &client_order_id[..8],
                                        &client_order_id[client_order_id.len()-4..]
                                    );

                                    let active_order = ActiveOrder {
                                        client_order_id,
                                        symbol: self.config.symbol.clone(),
                                        side: opp.direction,
                                        price: opp.pacifica_price,
                                        size: opp.size,
                                        initial_profit_bps: opp.initial_profit_bps,
                                        placed_at: Instant::now(),
                                    };

                                    state.set_active_order(active_order);

                                    // Sync atomic status and order snapshot for order monitor
                                    sync_atomic_status(&self.atomic_status, &state.status);
                                    update_order_snapshot(
                                        &self.order_snapshot,
                                        opp.direction,
                                        opp.pacifica_price,
                                        opp.size,
                                        opp.initial_profit_bps,
                                    );
                                } else {
                                    tprintln!("{} {} Order placed but no client_order_id returned",
                                        format!("[{} ORDER]", self.config.symbol).bright_yellow().bold(),
                                        "✗".red().bold()
                                    );
                                }
                            }
                            Err(e) => {
                                if is_rate_limit_error(&e) {
                                    order_placement_rate_limit.record_error();
                                    let backoff_secs = order_placement_rate_limit.get_backoff_secs();
                                    tprintln!(
                                        "{} {} Failed to place order: Rate limit exceeded. Backing off for {}s (attempt #{})",
                                        format!("[{} ORDER]", self.config.symbol).bright_yellow().bold(),
                                        "⚠".yellow().bold(),
                                        backoff_secs,
                                        order_placement_rate_limit.consecutive_errors()
                                    );
                                } else {
                                    tprintln!("{} {} Failed to place order: {}",
                                        format!("[{} ORDER]", self.config.symbol).bright_yellow().bold(),
                                        "✗".red().bold(),
                                        e.to_string().red()
                                    );
                                }
                            }
                        }
                    }
                }

                _ = shutdown_rx.recv() => {
                    tprintln!("{} Shutdown signal received",
                        format!("[{} MAIN]", self.config.symbol).bright_white().bold()
                    );
                    break;
                }
            }
        }

        // ═══════════════════════════════════════════════════
        // SHUTDOWN CLEANUP
        // ═══════════════════════════════════════════════════

        tprintln!("");
        tprintln!("{} Cancelling any remaining orders...",
            format!("[{} SHUTDOWN]", self.config.symbol).yellow().bold()
        );

        match self.pacifica_trading_main.cancel_all_orders(false, Some(&self.config.symbol), false).await {
            Ok(count) => tprintln!("{} {} Cancelled {} order(s)",
                format!("[{} SHUTDOWN]", self.config.symbol).yellow().bold(),
                "✓".green().bold(),
                count
            ),
            Err(e) => tprintln!("{} {} Failed to cancel orders: {}",
                format!("[{} SHUTDOWN]", self.config.symbol).yellow().bold(),
                "⚠".yellow().bold(),
                e
            ),
        }

        // Final state check
        let final_state = self.bot_state.read().await;
        match &final_state.status {
            BotStatus::Complete => {
                tprintln!("");
                tprintln!("{} {}", "✓".green().bold(), "Bot completed successfully!".green().bold());
                tprintln!("Final position: {}", final_state.position);
                Ok(())
            }
            BotStatus::Error(e) => {
                tprintln!("");
                tprintln!("{} {}: {}", "✗".red().bold(), "Bot terminated with error".red().bold(), e.to_string().red());
                anyhow::bail!("Bot failed: {}", e)
            }
            _ => {
                tprintln!("");
                tprintln!("{} Bot terminated in unexpected state: {:?}", "⚠".yellow().bold(), final_state.status);
                Ok(())
            }
        }
    }
}


================================================================================
FILE: src\bin\check_balance.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\bin\check_balance.rs
================================================================================

use anyhow::{Context, Result};
use dotenv::dotenv;
use serde::Deserialize;
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::{error, info, warn, Level};
use tracing_subscriber::FmtSubscriber;

use xemm_rust::connector::hyperliquid::{
    client::{OrderbookClient as HlOrderbookClient, OrderbookConfig as HlOrderbookConfig},
    trading::{HyperliquidCredentials, HyperliquidTrading},
};
use xemm_rust::connector::pacifica::{
    OrderbookClient as PacOrderbookClient, OrderbookConfig as PacOrderbookConfig,
    trading::{PacificaCredentials, PacificaTrading},
};

#[derive(Debug, Deserialize)]
struct Config {
    symbol: String,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber).expect("setting default subscriber failed");

    // Load .env
    dotenv().ok();

    // Load config
    let mut file = File::open("config.json").context("Failed to open config.json")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let config: Config = serde_json::from_str(&contents)?;

    info!("Starting balance check for symbol: {}", config.symbol);

    // Initialize clients
    let hl_creds = HyperliquidCredentials::from_env()?;
    let hl_trading = HyperliquidTrading::new(hl_creds, false)?; // Mainnet

    let pac_creds = PacificaCredentials::from_env()?;
    let pac_trading = PacificaTrading::new(pac_creds)?;

    // Initialize orderbook clients for price feeds (needed for value calculation)
    let hl_price = Arc::new(Mutex::new(None));
    let pac_price = Arc::new(Mutex::new(None));

    let hl_price_clone = hl_price.clone();
    let mut hl_ob_client = HlOrderbookClient::new(HlOrderbookConfig {
        coin: config.symbol.clone(),
        ..Default::default()
    })?;

    let pac_price_clone = pac_price.clone();
    let mut pac_ob_client = PacOrderbookClient::new(PacOrderbookConfig {
        symbol: config.symbol.clone(),
        ..Default::default()
    })?;

    // Spawn orderbook tasks
    tokio::spawn(async move {
        if let Err(e) = hl_ob_client.start(move |bid, ask, _, _| {
            let bid_f: f64 = bid.parse().unwrap_or(0.0);
            let ask_f: f64 = ask.parse().unwrap_or(0.0);
            if bid_f > 0.0 && ask_f > 0.0 {
                let mid = (bid_f + ask_f) / 2.0;
                if let Ok(mut lock) = hl_price_clone.lock() {
                    *lock = Some(mid);
                }
            }
        }).await {
            error!("HL Orderbook error: {}", e);
        }
    });

    tokio::spawn(async move {
        if let Err(e) = pac_ob_client.start(move |bid, ask, _, _| {
            let bid_f: f64 = bid.parse().unwrap_or(0.0);
            let ask_f: f64 = ask.parse().unwrap_or(0.0);
            if bid_f > 0.0 && ask_f > 0.0 {
                let mid = (bid_f + ask_f) / 2.0;
                if let Ok(mut lock) = pac_price_clone.lock() {
                    *lock = Some(mid);
                }
            }
        }).await {
            error!("Pacifica Orderbook error: {}", e);
        }
    });

    // Wait for prices
    info!("Waiting for price data...");
    loop {
        let hl_p = *hl_price.lock().unwrap();
        let pac_p = *pac_price.lock().unwrap();
        if hl_p.is_some() && pac_p.is_some() {
            break;
        }
        sleep(Duration::from_millis(100)).await;
    }

    info!("Price data received. Checking positions...");

    check_balance(&config, &hl_trading, &pac_trading, &hl_price, &pac_price).await?;

    Ok(())
}

async fn check_balance(
    config: &Config,
    hl_trading: &HyperliquidTrading,
    pac_trading: &PacificaTrading,
    hl_price_store: &Arc<Mutex<Option<f64>>>,
    pac_price_store: &Arc<Mutex<Option<f64>>>,
) -> Result<()> {
    // 1. Fetch Positions
    let wallet_address = std::env::var("HL_WALLET").unwrap_or_else(|_| hl_trading.get_wallet_address());
    let hl_state = hl_trading.get_user_state(&wallet_address).await?;
    let pac_positions = pac_trading.get_positions().await?;

    // Find target positions
    let hl_pos = hl_state.asset_positions.iter()
        .find(|p| p.position.coin == config.symbol)
        .map(|p| p.position.szi.parse::<f64>().unwrap_or(0.0))
        .unwrap_or(0.0);

    let pac_pos = pac_positions.iter()
        .find(|p| p.symbol == config.symbol)
        .map(|p| {
            let amt = p.amount.parse::<f64>().unwrap_or(0.0);
            if p.side == "bid" { amt } else { -amt }
        })
        .unwrap_or(0.0);

    // 2. Get Prices
    let hl_mid = (*hl_price_store.lock().unwrap()).context("No HL price")?;
    let pac_mid = (*pac_price_store.lock().unwrap()).context("No Pacifica price")?;
    let avg_price = (hl_mid + pac_mid) / 2.0;

    // 3. Calculate Imbalance
    let net_delta = hl_pos + pac_pos;
    let threshold = 0.005; 

    info!("--------------------------------------------------");
    info!("📊 POSITION REPORT: {}", config.symbol);
    info!("--------------------------------------------------");
    info!("Hyperliquid: {:>10.4} (Value: ${:.2})", hl_pos, hl_pos.abs() * hl_mid);
    info!("Pacifica:    {:>10.4} (Value: ${:.2})", pac_pos, pac_pos.abs() * pac_mid);
    info!("--------------------------------------------------");
    info!("Net Delta:   {:>10.4} (Value: ${:.2})", net_delta, net_delta.abs() * avg_price);
    info!("--------------------------------------------------");

    if net_delta.abs() < threshold {
        info!("✅ STATUS: BALANCED (Delta < {})", threshold);
    } else {
        warn!("⚠️ STATUS: IMBALANCED");
        info!("Action Required: {} {:.4} to reach neutral.", 
            if net_delta > 0.0 { "SELL" } else { "BUY" }, 
            net_delta.abs()
        );
    }

    Ok(())
}


================================================================================
FILE: src\bin\rebalance.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\bin\rebalance.rs
================================================================================

use anyhow::{Context, Result};
use dotenv::dotenv;
use serde::Deserialize;
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, Mutex};
use tokio::time::{sleep, Duration};
use tracing::{error, info, warn, Level};
use tracing_subscriber::FmtSubscriber;

use xemm_rust::connector::hyperliquid::{
    client::{OrderbookClient as HlOrderbookClient, OrderbookConfig as HlOrderbookConfig},
    trading::{HyperliquidCredentials, HyperliquidTrading},
};
use xemm_rust::connector::pacifica::{
    OrderbookClient as PacOrderbookClient, OrderbookConfig as PacOrderbookConfig,
    trading::{PacificaCredentials, PacificaTrading, OrderSide},
};

#[derive(Debug, Deserialize)]
struct Config {
    symbol: String,
    hyperliquid_slippage: f64,
}

#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    let subscriber = FmtSubscriber::builder()
        .with_max_level(Level::INFO)
        .finish();
    tracing::subscriber::set_global_default(subscriber).expect("setting default subscriber failed");

    // Load .env
    dotenv().ok();

    // Load config
    let mut file = File::open("config.json").context("Failed to open config.json")?;
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    let config: Config = serde_json::from_str(&contents)?;

    info!("Starting rebalancer for symbol: {}", config.symbol);

    // Initialize clients
    let hl_creds = HyperliquidCredentials::from_env()?;
    let hl_trading = HyperliquidTrading::new(hl_creds, false)?; // Mainnet

    let pac_creds = PacificaCredentials::from_env()?;
    let pac_trading = PacificaTrading::new(pac_creds)?;

    // Initialize orderbook clients for price feeds
    // Use std::sync::Mutex for synchronous access in callbacks
    let hl_price = Arc::new(Mutex::new(None));
    let pac_price = Arc::new(Mutex::new(None));

    let hl_price_clone = hl_price.clone();
    let mut hl_ob_client = HlOrderbookClient::new(HlOrderbookConfig {
        coin: config.symbol.clone(),
        ..Default::default()
    })?;

    let pac_price_clone = pac_price.clone();
    let mut pac_ob_client = PacOrderbookClient::new(PacOrderbookConfig {
        symbol: config.symbol.clone(),
        ..Default::default()
    })?;

    // Spawn orderbook tasks
    tokio::spawn(async move {
        if let Err(e) = hl_ob_client.start(move |bid, ask, _, _| {
            let bid_f: f64 = bid.parse().unwrap_or(0.0);
            let ask_f: f64 = ask.parse().unwrap_or(0.0);
            if bid_f > 0.0 && ask_f > 0.0 {
                let mid = (bid_f + ask_f) / 2.0;
                if let Ok(mut lock) = hl_price_clone.lock() {
                    *lock = Some(mid);
                }
            }
        }).await {
            error!("HL Orderbook error: {}", e);
        }
    });

    tokio::spawn(async move {
        if let Err(e) = pac_ob_client.start(move |bid, ask, _, _| {
            let bid_f: f64 = bid.parse().unwrap_or(0.0);
            let ask_f: f64 = ask.parse().unwrap_or(0.0);
            if bid_f > 0.0 && ask_f > 0.0 {
                let mid = (bid_f + ask_f) / 2.0;
                if let Ok(mut lock) = pac_price_clone.lock() {
                    *lock = Some(mid);
                }
            }
        }).await {
            error!("Pacifica Orderbook error: {}", e);
        }
    });

    // Wait for prices
    info!("Waiting for price data...");
    loop {
        let hl_p = *hl_price.lock().unwrap();
        let pac_p = *pac_price.lock().unwrap();
        if hl_p.is_some() && pac_p.is_some() {
            break;
        }
        sleep(Duration::from_millis(100)).await;
    }

    info!("Price data received. Starting rebalance sequence.");

    let max_retries = 5;
    for i in 1..=max_retries {
        info!("--- Rebalance Attempt {}/{} ---", i, max_retries);
        match rebalance_step(&config, &hl_trading, &pac_trading, &hl_price, &pac_price).await {
            Ok(is_balanced) => {
                if is_balanced {
                    info!("✅ System is balanced. Exiting successfully.");
                    return Ok(());
                } else {
                    info!("Action taken. Waiting 6s for state propagation before verification...");
                    sleep(Duration::from_secs(6)).await;
                }
            }
            Err(e) => {
                error!("Error during rebalance step: {}", e);
                sleep(Duration::from_secs(5)).await;
            }
        }
    }

    warn!("⚠️ Max retries reached. System may still be imbalanced. Please check manually.");
    Ok(())
}

async fn rebalance_step(
    config: &Config,
    hl_trading: &HyperliquidTrading,
    pac_trading: &PacificaTrading,
    hl_price_store: &Arc<Mutex<Option<f64>>>,
    pac_price_store: &Arc<Mutex<Option<f64>>>,
) -> Result<bool> {
    // 1. Fetch Positions
    let wallet_address = std::env::var("HL_WALLET").unwrap_or_else(|_| hl_trading.get_wallet_address());
    let hl_state = hl_trading.get_user_state(&wallet_address).await?;
    let pac_positions = pac_trading.get_positions().await?;

    // Find target positions
    let hl_pos = hl_state.asset_positions.iter()
        .find(|p| p.position.coin == config.symbol)
        .map(|p| p.position.szi.parse::<f64>().unwrap_or(0.0))
        .unwrap_or(0.0);

    let pac_pos = pac_positions.iter()
        .find(|p| p.symbol == config.symbol)
        .map(|p| {
            let amt = p.amount.parse::<f64>().unwrap_or(0.0);
            if p.side == "bid" { amt } else { -amt }
        })
        .unwrap_or(0.0);

    info!("Positions - HL: {:.4}, Pacifica: {:.4}", hl_pos, pac_pos);

    // 2. Calculate Imbalance
    let net_delta = hl_pos + pac_pos;
    let threshold = 0.005; // Ignore dust, but catch 0.01 imbalances

    if net_delta.abs() < threshold {
        info!("Net delta {:.4} is negligible. No action needed.", net_delta);
        return Ok(true);
    }

    // 3. Get Prices
    let hl_mid = (*hl_price_store.lock().unwrap()).context("No HL price")?;
    let pac_mid = (*pac_price_store.lock().unwrap()).context("No Pacifica price")?;

    // Safety check: Price deviation
    let price_diff_pct = (hl_mid - pac_mid).abs() / pac_mid;
    if price_diff_pct > 0.05 {
        warn!("Price deviation too high ({:.2}%). Aborting rebalance.", price_diff_pct * 100.0);
        return Ok(false); // Not balanced, but aborted
    }

    let avg_price = (hl_mid + pac_mid) / 2.0;
    
    info!("Imbalance detected: Net Delta = {:.4}. Rebalancing needed.", net_delta);

    // 4. Determine Action Plan
    // We need to change Net Delta by -net_delta (to get to 0).
    // Let target_change = -net_delta.
    
    let target_change = -net_delta;
    let min_hl_value = 12.0; // Buffer for $10 limit
    let min_hl_size = min_hl_value / avg_price;

    let mut hl_trade: Option<(f64, bool)> = None; // (size, is_buy)
    let mut pac_trade: Option<(f64, bool)> = None; // (size, is_buy)

    // Helper to check if a trade is reduce-only
    let is_reduce_hl = |change: f64| -> bool {
        if hl_pos > 0.0 { change < 0.0 } else { change > 0.0 }
    };
    let is_reduce_pac = |change: f64| -> bool {
        if pac_pos > 0.0 { change < 0.0 } else { change > 0.0 }
    };

    // Strategy 1: Single Leg on HL
    // Requirement: |target_change| > min_hl_size AND is_reduce_hl(target_change)
    if target_change.abs() > min_hl_size && is_reduce_hl(target_change) {
        info!("Strategy: Single Leg HL");
        hl_trade = Some((target_change.abs(), target_change > 0.0));
    }
    // Strategy 2: Single Leg on Pac
    // Requirement: is_reduce_pac(target_change) (Strict reduce-only for Pac as requested)
    else if is_reduce_pac(target_change) {
        info!("Strategy: Single Leg Pacifica");
        pac_trade = Some((target_change.abs(), target_change > 0.0));
    }
    // Strategy 3: Dual Leg (Unwind/Rebalance)
    // We want Change_HL + Change_Pac = target_change.
    // And we want both to be reduce-only.
    // And |Change_HL| > min_hl_size.
    else {
        // Try to construct a dual leg trade
        // Direction of HL trade to be reduce-only:
        let hl_reduce_dir = if hl_pos > 0.0 { -1.0 } else { 1.0 }; // -1 for Sell, 1 for Buy
        
        // Min size for HL
        let x_size = min_hl_size.max(target_change.abs() * 2.0); // Start with min size or double target
        let x = x_size * hl_reduce_dir;
        
        // Calculate necessary Y on Pac
        let y = target_change - x;
        
        // Check if Y is reduce-only on Pac
        if is_reduce_pac(y) {
             // Check if we have enough position to reduce
             let hl_enough = hl_pos.abs() >= x.abs();
             let pac_enough = pac_pos.abs() >= y.abs();
             
             if hl_enough && pac_enough {
                 info!("Strategy: Dual Leg Rebalance (HL: {:.4}, Pac: {:.4})", x, y);
                 hl_trade = Some((x.abs(), x > 0.0));
                 pac_trade = Some((y.abs(), y > 0.0));
             } else {
                 warn!("Dual leg strategy found but insufficient positions (HL: {}, Pac: {}).", hl_enough, pac_enough);
             }
        } else {
            warn!("Could not find valid dual-leg rebalance strategy.");
        }
    }

    // 6. Execute Trades
    // We need to handle the dependency: In Dual Leg, Pac depends on HL.
    // We can track if we are in Dual Leg mode by checking if both are Some.
    let is_dual_leg = hl_trade.is_some() && pac_trade.is_some();

    let mut hl_success = false;

    if let Some((size, is_buy)) = hl_trade {
        info!("Executing HL: {} {:.4}", if is_buy { "BUY" } else { "SELL" }, size);
        let bid = Some(hl_mid); 
        let ask = Some(hl_mid);
        
        // Cap size to position if reduce_only to avoid rejection
        // Although we checked `hl_enough`, slight precision diffs could cause rejection.
        // HL API `reduce_only` might reject if size > position.
        // Let's use the minimum of size and current position abs if we are reducing.
        // (We know we are reducing because of our strategy logic).
        let safe_size = if hl_pos.abs() < size { hl_pos.abs() } else { size };
        
        let res = hl_trading.place_market_order(
            &config.symbol,
            is_buy,
            safe_size,
            config.hyperliquid_slippage,
            true, // reduce_only
            bid,
            ask
        ).await;
        
        match res {
            Ok(r) => {
                info!("HL Order sent: {:?}", r);
                // Check if response indicates success (order_id present)
                // The struct has `response: OrderResponseContent`.
                // We need to check if it's Success.
                // `place_market_order` returns `OrderResponse`.
                // We should inspect it.
                // Assuming `place_market_order` throws error if API returns error (it does bail on "error" status).
                // But let's be sure.
                hl_success = true;
            },
            Err(e) => {
                error!("HL Order failed: {}", e);
                hl_success = false;
            }
        }
    } else {
        // No HL trade, so "HL success" is irrelevant or implicitly true for the purpose of "proceeding" 
        // if we were independent. But here we only care if is_dual_leg.
        hl_success = true; 
    }

    if let Some((size, is_buy)) = pac_trade {
        // If Dual Leg, only proceed if HL succeeded
        if is_dual_leg && !hl_success {
            warn!("Skipping Pacifica leg because Hyperliquid leg failed in Dual Leg strategy.");
        } else {
            info!("Executing Pac: {} {:.4}", if is_buy { "BUY" } else { "SELL" }, size);
            
            // Cap size for Pacifica reduce_only as well
            let safe_size = if pac_pos.abs() < size { pac_pos.abs() } else { size };
            
            let res = pac_trading.place_market_order(
                &config.symbol,
                if is_buy { OrderSide::Buy } else { OrderSide::Sell },
                safe_size,
                config.hyperliquid_slippage,
                true, // reduce_only - enforced
            ).await;
            match res {
                Ok(r) => info!("Pac Order sent: {:?}", r),
                Err(e) => error!("Pac Order failed: {}", e),
            }
        }
    }

    Ok(false) // Action taken (or attempted), so not "already balanced"
}


================================================================================
FILE: src\bot\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\bot\mod.rs
================================================================================

pub mod state;

pub use state::{ActiveOrder, BotState, BotStatus};


================================================================================
FILE: src\bot\state.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\bot\state.rs
================================================================================

use crate::strategy::OrderSide;
use std::sync::atomic::{AtomicU8, Ordering};
use std::sync::Arc;
use std::time::Instant;

/// Bot status enumeration
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum BotStatus {
    /// Bot is idle, waiting for an opportunity
    Idle,
    /// Order has been placed on Pacifica
    OrderPlaced,
    /// Order has been filled on Pacifica
    Filled,
    /// Hedge is being executed on Hyperliquid
    Hedging,
    /// Full cycle complete (order filled + hedged)
    Complete,
    /// Error occurred
    Error(String),
}

/// Active order information
#[derive(Debug, Clone)]
pub struct ActiveOrder {
    /// Client order ID
    pub client_order_id: String,
    /// Trading symbol (e.g., "SOL")
    pub symbol: String,
    /// Order side (Buy or Sell)
    pub side: OrderSide,
    /// Limit price
    pub price: f64,
    /// Order size
    pub size: f64,
    /// Initial calculated profit in basis points
    pub initial_profit_bps: f64,
    /// When the order was placed
    pub placed_at: Instant,
}

/// Bot state (thread-safe via Arc<RwLock<BotState>>)
#[derive(Debug)]
pub struct BotState {
    /// Currently active order (if any)
    pub active_order: Option<ActiveOrder>,
    /// Current position size (+ for long, - for short, 0 for flat)
    pub position: f64,
    /// Current bot status
    pub status: BotStatus,
    /// Atomic status for fast lock-free checks (0=Idle, 1=OrderPlaced, 2=Filled, 3=Hedging, 4=Complete, 5=Error)
    pub status_atomic: Arc<AtomicU8>,
    /// Last time an order was cancelled (for grace period enforcement)
    pub last_cancellation_time: Option<Instant>,
}

impl BotState {
    /// Create a new bot state in Idle status
    pub fn new() -> Self {
        Self {
            active_order: None,
            position: 0.0,
            status: BotStatus::Idle,
            status_atomic: Arc::new(AtomicU8::new(0)), // 0 = Idle
            last_cancellation_time: None,
        }
    }

    /// Set active order and update status
    pub fn set_active_order(&mut self, order: ActiveOrder) {
        self.active_order = Some(order);
        self.status = BotStatus::OrderPlaced;
        self.status_atomic.store(1, Ordering::Release); // 1 = OrderPlaced
    }

    /// Clear active order and return to Idle
    pub fn clear_active_order(&mut self) {
        self.active_order = None;
        self.status = BotStatus::Idle;
        self.status_atomic.store(0, Ordering::Release); // 0 = Idle
        self.last_cancellation_time = Some(Instant::now());
    }

    /// Mark order as filled
    pub fn mark_filled(&mut self, filled_size: f64, side: OrderSide) {
        self.status = BotStatus::Filled;
        self.status_atomic.store(2, Ordering::Release); // 2 = Filled

        // Update position
        match side {
            OrderSide::Buy => self.position += filled_size,
            OrderSide::Sell => self.position -= filled_size,
        }
    }

    /// Mark as hedging
    pub fn mark_hedging(&mut self) {
        self.status = BotStatus::Hedging;
        self.status_atomic.store(3, Ordering::Release); // 3 = Hedging
    }

    /// Mark as complete
    pub fn mark_complete(&mut self) {
        self.status = BotStatus::Complete;
        self.status_atomic.store(4, Ordering::Release); // 4 = Complete
        self.active_order = None;
    }

    /// Set error status
    pub fn set_error(&mut self, error: String) {
        self.status = BotStatus::Error(error);
        self.status_atomic.store(5, Ordering::Release); // 5 = Error
    }

    /// Check if bot is in a terminal state
    pub fn is_terminal(&self) -> bool {
        matches!(self.status, BotStatus::Complete | BotStatus::Error(_))
    }

    /// Check if bot is idle
    pub fn is_idle(&self) -> bool {
        self.status == BotStatus::Idle
    }

    /// Fast lock-free check if bot is idle (using atomic status)
    pub fn is_idle_fast(&self) -> bool {
        self.status_atomic.load(Ordering::Acquire) == 0
    }

    /// Fast lock-free check if bot has an active order (OrderPlaced status)
    pub fn has_active_order_fast(&self) -> bool {
        self.status_atomic.load(Ordering::Acquire) == 1
    }

    /// Fast lock-free get current status as u8
    pub fn get_status_atomic(&self) -> u8 {
        self.status_atomic.load(Ordering::Acquire)
    }

    /// Check if the grace period has passed since last cancellation
    /// Returns true if no cancellation or if grace_period_secs has elapsed
    pub fn grace_period_elapsed(&self, grace_period_secs: u64) -> bool {
        match self.last_cancellation_time {
            None => true, // No previous cancellation
            Some(last_cancel) => last_cancel.elapsed().as_secs() >= grace_period_secs,
        }
    }
}

impl Default for BotState {
    fn default() -> Self {
        Self::new()
    }
}


================================================================================
FILE: src\config.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\config.rs
================================================================================

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

/// Application configuration loaded from config.json
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    /// Trading symbol (e.g., "SOL", "BTC", "ETH")
    pub symbol: String,

    /// Orderbook aggregation level (1, 2, 5, 10, 100, 1000)
    #[serde(default = "default_agg_level")]
    pub agg_level: u32,

    /// Maximum number of reconnection attempts
    #[serde(default = "default_reconnect_attempts")]
    pub reconnect_attempts: u32,

    /// Ping interval in seconds (keep below 60 to avoid timeout)
    #[serde(default = "default_ping_interval")]
    pub ping_interval_secs: u64,

    /// Low-latency mode: minimal logging and processing
    #[serde(default = "default_low_latency")]
    pub low_latency_mode: bool,

    /// Pacifica maker fee in basis points (e.g., 1.0 = 0.01%)
    #[serde(default = "default_pacifica_maker_fee")]
    pub pacifica_maker_fee_bps: f64,

    /// Hyperliquid taker fee in basis points (e.g., 2.5 = 0.025%)
    #[serde(default = "default_hyperliquid_taker_fee")]
    pub hyperliquid_taker_fee_bps: f64,

    /// Target profit rate in basis points (e.g., 10.0 = 0.1%)
    #[serde(default = "default_profit_rate")]
    pub profit_rate_bps: f64,

    /// Order notional size in USD (e.g., 20.0 = $20)
    #[serde(default = "default_order_notional")]
    pub order_notional_usd: f64,

    /// Profit cancel threshold in basis points (cancel if profit drops by this much)
    #[serde(default = "default_profit_cancel_threshold")]
    pub profit_cancel_threshold_bps: f64,

    /// Order refresh interval in seconds (cancel and replace if order is this old)
    #[serde(default = "default_order_refresh_interval")]
    pub order_refresh_interval_secs: u64,

    /// Hyperliquid slippage tolerance for market orders (e.g., 0.05 = 5%)
    #[serde(default = "default_hyperliquid_slippage")]
    pub hyperliquid_slippage: f64,

    /// Use Hyperliquid WebSocket for hedge market orders (default: true).
    /// When disabled, REST API is used for hedge execution.
    #[serde(default = "default_hyperliquid_use_ws_for_hedge")]
    pub hyperliquid_use_ws_for_hedge: bool,

    /// Pacifica REST API polling interval in seconds (complement to WebSocket)
    #[serde(default = "default_pacifica_rest_poll_interval")]
    pub pacifica_rest_poll_interval_secs: u64,

    /// Pacifica REST poll interval for active orders (ms).
    /// Used by REST fill detection to poll more frequently when an order is active.
    #[serde(default = "default_pacifica_active_order_rest_poll_interval")]
    pub pacifica_active_order_rest_poll_interval_ms: u64,
}

// Default values
fn default_agg_level() -> u32 {
    1
}

fn default_reconnect_attempts() -> u32 {
    5
}

fn default_ping_interval() -> u64 {
    15 // 15 seconds
}

fn default_low_latency() -> bool {
    false
}

fn default_pacifica_maker_fee() -> f64 {
    1.5 // 1.5 bps = 0.015%
}

fn default_hyperliquid_taker_fee() -> f64 {
    4.0 // 4 bps = 0.04%
}

fn default_profit_rate() -> f64 {
    15.0 // 15 bps = 0.15%
}

fn default_order_notional() -> f64 {
    20.0 // $20 USD
}

fn default_profit_cancel_threshold() -> f64 {
    3.0 // 3 bps = 0.03%
}

fn default_order_refresh_interval() -> u64 {
    60 // 60 seconds
}

fn default_hyperliquid_slippage() -> f64 {
    0.05 // 5%
}

fn default_hyperliquid_use_ws_for_hedge() -> bool {
    true
}

fn default_pacifica_rest_poll_interval() -> u64 {
    2 // 2 seconds
}

fn default_pacifica_active_order_rest_poll_interval() -> u64 {
    500 // 500 ms (safer than 100ms to avoid rate limits)
}

impl Default for Config {
    fn default() -> Self {
        Self {
            symbol: "SOL".to_string(),
            agg_level: default_agg_level(),
            reconnect_attempts: default_reconnect_attempts(),
            ping_interval_secs: default_ping_interval(),
            low_latency_mode: default_low_latency(),
            pacifica_maker_fee_bps: default_pacifica_maker_fee(),
            hyperliquid_taker_fee_bps: default_hyperliquid_taker_fee(),
            profit_rate_bps: default_profit_rate(),
            order_notional_usd: default_order_notional(),
            profit_cancel_threshold_bps: default_profit_cancel_threshold(),
            order_refresh_interval_secs: default_order_refresh_interval(),
            hyperliquid_slippage: default_hyperliquid_slippage(),
            hyperliquid_use_ws_for_hedge: default_hyperliquid_use_ws_for_hedge(),
            pacifica_rest_poll_interval_secs: default_pacifica_rest_poll_interval(),
            pacifica_active_order_rest_poll_interval_ms: default_pacifica_active_order_rest_poll_interval(),
        }
    }
}

impl Config {
    /// Load configuration from a JSON file
    pub fn from_file<P: AsRef<Path>>(path: P) -> Result<Self> {
        let path = path.as_ref();
        let content = fs::read_to_string(path)
            .with_context(|| format!("Failed to read config file: {}", path.display()))?;

        let config: Config = serde_json::from_str(&content)
            .with_context(|| format!("Failed to parse config file: {}", path.display()))?;

        Ok(config)
    }

    /// Load configuration from default location (config.json)
    pub fn load_default() -> Result<Self> {
        Self::from_file("config.json")
    }

    /// Save configuration to a JSON file
    pub fn save_to_file<P: AsRef<Path>>(&self, path: P) -> Result<()> {
        let path = path.as_ref();
        let content = serde_json::to_string_pretty(self)
            .context("Failed to serialize config")?;

        fs::write(path, content)
            .with_context(|| format!("Failed to write config file: {}", path.display()))?;

        Ok(())
    }

    /// Validate configuration values
    pub fn validate(&self) -> Result<()> {
        // Check symbol is not empty
        anyhow::ensure!(!self.symbol.is_empty(), "Symbol cannot be empty");

        // Check aggregation level is valid
        let valid_agg_levels = [1, 2, 5, 10, 100, 1000];
        anyhow::ensure!(
            valid_agg_levels.contains(&self.agg_level),
            "Invalid aggregation level: {}. Must be one of: 1, 2, 5, 10, 100, 1000",
            self.agg_level
        );

        // Check ping interval is reasonable
        anyhow::ensure!(
            self.ping_interval_secs > 0 && self.ping_interval_secs <= 30,
            "Ping interval must be between 1 and 30 seconds"
        );

        // Check reconnect attempts is reasonable
        anyhow::ensure!(
            self.reconnect_attempts > 0,
            "Reconnect attempts must be greater than 0"
        );

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = Config::default();
        assert_eq!(config.symbol, "SOL");
        assert_eq!(config.agg_level, 1);
        assert_eq!(config.reconnect_attempts, 5);
        assert_eq!(config.ping_interval_secs, 15);
    }

    #[test]
    fn test_config_validation() {
        let mut config = Config::default();
        assert!(config.validate().is_ok());

        // Test invalid aggregation level
        config.agg_level = 3;
        assert!(config.validate().is_err());

        // Test invalid ping interval
        config.agg_level = 1;
        config.ping_interval_secs = 0;
        assert!(config.validate().is_err());

        config.ping_interval_secs = 60;
        assert!(config.validate().is_err());
    }
}


================================================================================
FILE: src\connector\hyperliquid\client.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\hyperliquid\client.rs
================================================================================

use anyhow::{Context, Result};
use futures_util::{SinkExt, StreamExt};
use tokio::time::{interval, sleep, Duration};
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message};
use tracing::{debug, error, info, warn};

use super::types::*;

const MAINNET_WS_URL: &str = "wss://api.hyperliquid.xyz/ws";

/// Configuration for the orderbook client
#[derive(Debug, Clone)]
pub struct OrderbookConfig {
    pub coin: String,
    pub reconnect_attempts: u32,
    pub ping_interval_secs: u64,
}

impl Default for OrderbookConfig {
    fn default() -> Self {
        Self {
            coin: "BTC".to_string(),
            reconnect_attempts: 5,
            ping_interval_secs: 30,
        }
    }
}

/// Hyperliquid orderbook WebSocket client
pub struct OrderbookClient {
    config: OrderbookConfig,
    ws_url: String,
}

impl OrderbookClient {
    /// Create a new orderbook client
    pub fn new(config: OrderbookConfig) -> Result<Self> {
        info!(
            "[HYPERLIQUID] Initializing orderbook client for {} on mainnet",
            config.coin
        );

        Ok(Self {
            config,
            ws_url: MAINNET_WS_URL.to_string(),
        })
    }

    /// Start the client and call the callback for each top-of-book update
    ///
    /// # Arguments
    /// * `callback` - Function called on each update with (best_bid, best_ask, coin, timestamp)
    pub async fn start<F>(&mut self, mut callback: F) -> Result<()>
    where
        F: FnMut(String, String, String, u64) + Send + 'static,
    {
        let mut reconnect_count = 0;

        loop {
            match self.connect_and_run(&mut callback).await {
                Ok(_) => {
                    info!("[HYPERLIQUID] Connection closed gracefully");
                    break;
                }
                Err(e) => {
                    reconnect_count += 1;
                    error!(
                        "[HYPERLIQUID] Connection error (attempt {}/{}): {}",
                        reconnect_count, self.config.reconnect_attempts, e
                    );

                    if reconnect_count >= self.config.reconnect_attempts {
                        error!("[HYPERLIQUID] Max reconnection attempts reached");
                        return Err(e);
                    }

                    // Fast first reconnect (1s), then exponential backoff, capped at 30s
                    let backoff_secs = if reconnect_count == 1 {
                        1
                    } else {
                        std::cmp::min(2_u64.pow(reconnect_count - 1), 30)
                    };
                    warn!(
                        "[HYPERLIQUID] Reconnecting in {} seconds...",
                        backoff_secs
                    );
                    sleep(Duration::from_secs(backoff_secs)).await;
                }
            }
        }

        Ok(())
    }

    /// Connect to WebSocket and run the main loop
    async fn connect_and_run<F>(&mut self, callback: &mut F) -> Result<()>
    where
        F: FnMut(String, String, String, u64) + Send + 'static,
    {
        info!("[HYPERLIQUID] Connecting to {}", self.ws_url);

        let (ws_stream, _) = connect_async(&self.ws_url)
            .await
            .context("Failed to connect to WebSocket")?;

        info!("[HYPERLIQUID] WebSocket connected successfully");

        let (mut write, mut read) = ws_stream.split();

        // Subscribe to L2 book
        let subscribe_msg = SubscriptionMessage {
            method: "subscribe".to_string(),
            subscription: SubscriptionParams {
                type_: "l2Book".to_string(),
                coin: self.config.coin.clone(),
            },
        };
        let subscribe_json = serde_json::to_string(&subscribe_msg)?;
        debug!("[HYPERLIQUID] Sending subscription: {}", subscribe_json);
        write.send(Message::Text(subscribe_json)).await?;
        info!("[HYPERLIQUID] Subscribed to l2Book for {}", self.config.coin);

        // Create interval for ping
        let mut ping_interval = interval(Duration::from_secs(self.config.ping_interval_secs));
        ping_interval.tick().await; // Skip first tick

        loop {
            tokio::select! {
                // Handle incoming messages
                Some(msg) = read.next() => {
                    match msg {
                        Ok(Message::Text(text)) => {
                            // Errors are already handled gracefully in handle_message
                            self.handle_message(&text, callback).await.ok();
                        }
                        Ok(Message::Ping(data)) => {
                            debug!("[HYPERLIQUID] Received ping, sending pong");
                            write.send(Message::Pong(data)).await?;
                        }
                        Ok(Message::Pong(_)) => {
                            debug!("[HYPERLIQUID] Received pong");
                        }
                        Ok(Message::Close(_)) => {
                            info!("[HYPERLIQUID] Received close message");
                            break;
                        }
                        Err(e) => {
                            error!("[HYPERLIQUID] WebSocket error: {}", e);
                            return Err(e.into());
                        }
                        _ => {}
                    }
                }

                // Send ping periodically
                _ = ping_interval.tick() => {
                    debug!("[HYPERLIQUID] Sending ping");
                    debug!("[HYPERLIQUID] Sending ping");
                    write.send(Message::Ping(vec![])).await?;
                }
            }
        }

        Ok(())
    }

    /// Handle incoming WebSocket message
    async fn handle_message<F>(&self, text: &str, callback: &mut F) -> Result<()>
    where
        F: FnMut(String, String, String, u64) + Send + 'static,
    {
        // Try to parse as generic response first
        let response: WebSocketResponse = match serde_json::from_str(text) {
            Ok(r) => r,
            Err(e) => {
                // Log at debug level - not all messages have a "channel" field
                debug!("[HYPERLIQUID] Skipping non-standard message: {}", e);
                return Ok(());
            }
        };

        match response.channel.as_str() {
            "l2Book" => {
                // Parse L2 book subscription response
                match serde_json::from_str::<L2BookSubscriptionResponse>(text) {
                    Ok(l2_response) => {
                        let book_data = &l2_response.data;

                        // Extract top of book
                        if let Some(tob) = book_data.get_top_of_book() {
                            debug!(
                                "[HYPERLIQUID] TOB: Bid={} Ask={} ({} @ {})",
                                tob.best_bid, tob.best_ask, tob.coin, tob.timestamp
                            );

                            callback(tob.best_bid, tob.best_ask, tob.coin, tob.timestamp);
                        }
                    }
                    Err(e) => {
                        debug!("[HYPERLIQUID] Failed to parse L2 book subscription: {}", e);
                    }
                }
            }
            "post" => {
                // Keep for backward compatibility or other post requests
                debug!("[HYPERLIQUID] Received post response (unexpected for subscription model)");
            }
            "pong" => {
                debug!("[HYPERLIQUID] Received pong response");
            }
            "subscriptionResponse" => {
                debug!("[HYPERLIQUID] Subscription confirmed");
            }
            _ => {
                debug!("[HYPERLIQUID] Unknown channel: {}", response.channel);
            }
        }

        Ok(())
    }
}

impl Drop for OrderbookClient {
    fn drop(&mut self) {
        info!("[HYPERLIQUID] OrderbookClient dropped for coin: {}", self.config.coin);
    }
}


================================================================================
FILE: src\connector\hyperliquid\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\hyperliquid\mod.rs
================================================================================

pub mod types;
pub mod client;
pub mod trading;

pub use client::{OrderbookClient, OrderbookConfig};
pub use trading::{HyperliquidTrading, HyperliquidCredentials};
pub use types::{L2BookData, BookLevel, TopOfBook, OrderResponse, OrderResponseContent, OrderStatus, UserFill, UserState, AssetPosition, Position, Leverage, CumFunding, MarginSummary, CrossMarginSummary};


================================================================================
FILE: src\connector\hyperliquid\trading.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\hyperliquid\trading.rs
================================================================================

use anyhow::{Context, Result};
use ethers::signers::{LocalWallet, Signer};
use ethers::types::transaction::eip712::TypedData;
use ethers::types::H256;
use ethers::utils::keccak256;
use reqwest::Client;
use serde_json::json;
use std::str::FromStr;
use std::sync::Arc;
use tokio::sync::RwLock;
use tracing::{debug, info};

use super::types::*;

const MAINNET_INFO_URL: &str = "https://api.hyperliquid.xyz/info";
const MAINNET_EXCHANGE_URL: &str = "https://api.hyperliquid.xyz/exchange";
const TESTNET_INFO_URL: &str = "https://api.hyperliquid-testnet.xyz/info";
const TESTNET_EXCHANGE_URL: &str = "https://api.hyperliquid-testnet.xyz/exchange";

/// Credentials for Hyperliquid trading
#[derive(Clone)]
pub struct HyperliquidCredentials {
    pub private_key: String,
}

impl HyperliquidCredentials {
    /// Load credentials from environment variables
    /// Expects HL_PRIVATE_KEY
    pub fn from_env() -> Result<Self> {
        let private_key = std::env::var("HL_PRIVATE_KEY")
            .context("HL_PRIVATE_KEY environment variable not set")?;

        Ok(Self {
            private_key,
        })
    }
}

    /// Hyperliquid trading client
    pub struct HyperliquidTrading {
        credentials: HyperliquidCredentials,
        info_url: String,
        exchange_url: String,
    client: Client,
    wallet: LocalWallet,
    meta_cache: Arc<RwLock<Option<MetaResponse>>>,
    is_testnet: bool,
}

impl HyperliquidTrading {
    /// Create a new trading client
    ///
    /// # Arguments
    /// * `credentials` - Hyperliquid credentials (wallet address and private key)
    /// * `is_testnet` - Whether to use testnet (false = mainnet)
    pub fn new(credentials: HyperliquidCredentials, is_testnet: bool) -> Result<Self> {
        let (info_url, exchange_url) = if is_testnet {
            (TESTNET_INFO_URL.to_string(), TESTNET_EXCHANGE_URL.to_string())
        } else {
            (MAINNET_INFO_URL.to_string(), MAINNET_EXCHANGE_URL.to_string())
        };

        // Create wallet from private key
        let wallet = LocalWallet::from_str(&credentials.private_key)
            .context("Failed to create wallet from private key")?;

        Ok(Self {
            credentials,
            info_url,
            exchange_url,
            client: Client::new(),
            wallet,
            meta_cache: Arc::new(RwLock::new(None)),
            is_testnet,
        })
    }

    /// Returns true when this client is configured for testnet.
    pub fn is_testnet(&self) -> bool {
        self.is_testnet
    }

    /// Fetch asset metadata (for asset IDs and szDecimals)
    pub async fn get_meta(&self) -> Result<MetaResponse> {
        // Check cache first
        {
            let cache = self.meta_cache.read().await;
            if let Some(cached) = cache.as_ref() {
                return Ok(cached.clone());
            }
        }

        info!("[HYPERLIQUID] Fetching asset metadata");

        let response = self
            .client
            .post(&self.info_url)
            .json(&json!({
                "type": "meta"
            }))
            .send()
            .await
            .context("Failed to fetch meta")?;

        // Get response text for debugging
        let response_text = response
            .text()
            .await
            .context("Failed to read response text")?;

        debug!("[HYPERLIQUID] Meta response (first 500 chars): {}",
            &response_text.chars().take(500).collect::<String>());

        let meta: MetaResponse = serde_json::from_str(&response_text)
            .context(format!("Failed to parse meta response. First 200 chars: {}",
                &response_text.chars().take(200).collect::<String>()))?;

        // Cache the result
        {
            let mut cache = self.meta_cache.write().await;
            *cache = Some(meta.clone());
        }

        debug!("[HYPERLIQUID] Loaded {} assets", meta.universe.len());
        Ok(meta)
    }

    /// Get asset ID from coin name
    pub async fn get_asset_id(&self, coin: &str) -> Result<u32> {
        let meta = self.get_meta().await?;

        let asset_index = meta
            .universe
            .iter()
            .position(|asset| asset.name == coin)
            .with_context(|| format!("Asset {} not found in meta", coin))?;

        Ok(asset_index as u32)
    }

    /// Get asset metadata (szDecimals, etc.)
    pub async fn get_asset_info(&self, coin: &str) -> Result<AssetMeta> {
        let meta = self.get_meta().await?;

        meta.universe
            .iter()
            .find(|asset| asset.name == coin)
            .cloned()
            .with_context(|| format!("Asset {} not found in meta", coin))
    }

    /// Get L2 orderbook snapshot via info endpoint
    pub async fn get_l2_snapshot(&self, coin: &str) -> Result<Option<(f64, f64)>> {
        debug!("[HYPERLIQUID] Fetching L2 snapshot for {}", coin);

        let request_body = serde_json::json!({
            "type": "l2Book",
            "coin": coin
        });

        let response = self.client
            .post(&self.info_url)
            .json(&request_body)
            .send()
            .await
            .context("Failed to fetch L2 snapshot")?;

        if !response.status().is_success() {
            anyhow::bail!("L2 snapshot request failed: {}", response.status());
        }

        let response_text = response.text().await.context("Failed to read L2 response")?;

        // Parse response to extract levels
        let data: serde_json::Value = serde_json::from_str(&response_text)
            .context("Failed to parse L2 response")?;

        // Extract best bid and ask from levels
        // levels[0] = array of bid levels [{px, sz, n}, ...]
        // levels[1] = array of ask levels [{px, sz, n}, ...]
        let levels = data.get("levels")
            .and_then(|v| v.as_array())
            .context("Missing levels array in L2 response")?;

        if levels.len() < 2 {
            return Ok(None);
        }

        // Get best bid (first element of bids array)
        let best_bid = levels.get(0)
            .and_then(|bids| bids.as_array())
            .and_then(|bids| bids.first())
            .and_then(|bid| bid.get("px"))
            .and_then(|px| px.as_str())
            .and_then(|s| s.parse::<f64>().ok());

        // Get best ask (first element of asks array)
        let best_ask = levels.get(1)
            .and_then(|asks| asks.as_array())
            .and_then(|asks| asks.first())
            .and_then(|ask| ask.get("px"))
            .and_then(|px| px.as_str())
            .and_then(|s| s.parse::<f64>().ok());

        match (best_bid, best_ask) {
            (Some(bid), Some(ask)) => {
                debug!("[HYPERLIQUID] L2 snapshot: bid=${:.6}, ask=${:.6}", bid, ask);
                Ok(Some((bid, ask)))
            }
            _ => Ok(None),
        }
    }

    /// Round price to proper tick size
    /// Prices can have up to 5 significant figures
    /// Max decimals = MAX_DECIMALS - szDecimals (6 for perps, 8 for spot)
    ///
    /// Reference: hyperliquid.js roundPrice() - EXACT MATCH
    fn round_price(price: f64, sz_decimals: i32, is_spot: bool, _is_buy: bool, _aggressive: bool) -> String {
        let max_decimals = (if is_spot { 8 } else { 6 }) - sz_decimals;

        // Step 1: Round to 5 significant figures
        // Equivalent to JavaScript's toPrecision(5) then parseFloat
        let rounded = if price > 0.0 {
            // Calculate the magnitude (power of 10)
            let magnitude = price.log10().floor();
            let scale = 10_f64.powf(magnitude - 4.0); // 5 sig figs = magnitude - 4

            // Round to 5 significant figures
            (price / scale).round() * scale
        } else {
            price
        };

        // Step 2: Limit to max decimal places
        // Equivalent to JavaScript's toFixed(maxDecimals) then parseFloat
        let rounded = if max_decimals >= 0 {
            let decimal_multiplier = 10_f64.powi(max_decimals);
            (rounded * decimal_multiplier).round() / decimal_multiplier
        } else {
            rounded
        };

        // Step 3: Format with max_decimals precision
        let max_decimals_clamped = max_decimals.max(0) as usize;
        let result = format!("{:.prec$}", rounded, prec = max_decimals_clamped);

        // Step 4: Remove trailing zeros (like JavaScript's toString())
        if result.contains('.') {
            result.trim_end_matches('0').trim_end_matches('.').to_string()
        } else {
            result
        }
    }

    /// Round size to proper lot size (szDecimals)
    fn round_size(size: f64, sz_decimals: i32) -> String {
        let rounded = format!("{:.prec$}", size, prec = sz_decimals.max(0) as usize)
            .parse::<f64>()
            .unwrap();

        rounded.to_string()
    }

    /// Construct connection ID for EIP-712 signing
    /// This is a keccak256 hash of msgpack-encoded action + nonce + vault indicator
    fn construct_connection_id(
        action: &Action,
        nonce: u64,
        vault_address: Option<&str>,
    ) -> Result<H256> {
        // Encode action with msgpack (using named encoding for maps, not arrays)
        let action_bytes = rmp_serde::encode::to_vec_named(action)
            .context("Failed to encode action with msgpack")?;

        let mut data_to_hash = Vec::new();

        // Add action bytes
        data_to_hash.extend_from_slice(&action_bytes);

        // Add nonce as 8-byte big-endian
        data_to_hash.extend_from_slice(&nonce.to_be_bytes());

        // Add vault address indicator (1 if vault, 0 if not)
        data_to_hash.push(if vault_address.is_some() { 1 } else { 0 });

        // Hash the combined data
        let hash = keccak256(&data_to_hash);

        Ok(H256::from(hash))
    }

    /// Sign an action using EIP-712
    async fn sign_action(
        &self,
        action: &Action,
        nonce: u64,
        vault_address: Option<&str>,
    ) -> Result<Signature> {
        // Construct connection ID
        let connection_id = Self::construct_connection_id(action, nonce, vault_address)?;

        // Construct EIP-712 domain
        let domain = json!({
            "chainId": 1337,
            "name": "Exchange",
            "verifyingContract": "0x0000000000000000000000000000000000000000",
            "version": "1"
        });

        // Construct EIP-712 types
        let types = json!({
            "Agent": [
                { "name": "source", "type": "string" },
                { "name": "connectionId", "type": "bytes32" }
            ]
        });

        // Construct phantom agent
        // source: "a" for mainnet, "b" for testnet
        let source = if self.is_testnet { "b" } else { "a" };

        let message = json!({
            "source": source,
            "connectionId": format!("0x{}", hex::encode(connection_id.as_bytes()))
        });

        // Create EIP-712 typed data
        let typed_data = TypedData {
            domain: serde_json::from_value(domain)?,
            types: serde_json::from_value(types)?,
            primary_type: "Agent".to_string(),
            message: serde_json::from_value(message)?,
        };

        // Sign the typed data
        let sig = self.wallet.sign_typed_data(&typed_data).await?;

        // Convert r and s from U256 to 32-byte arrays
        let mut r_bytes = [0u8; 32];
        let mut s_bytes = [0u8; 32];
        sig.r.to_big_endian(&mut r_bytes);
        sig.s.to_big_endian(&mut s_bytes);

        Ok(Signature {
            r: format!("0x{}", hex::encode(r_bytes)),
            s: format!("0x{}", hex::encode(s_bytes)),
            v: sig.v as u32,
        })
    }

    /// Build a signed market order request (IOC limit order with slippage).
    ///
    /// This constructs and signs the order payload that can be sent either via
    /// REST (`/exchange`) or via WebSocket `post` (type: "action").
    pub async fn build_market_order_request(
        &self,
        coin: &str,
        is_buy: bool,
        size: f64,
        slippage: f64,
        reduce_only: bool,
        bid: Option<f64>,
        ask: Option<f64>,
    ) -> Result<OrderRequest> {
        // Get asset ID and metadata
        let asset_id = self.get_asset_id(coin).await?;
        let asset_info = self.get_asset_info(coin).await?;

        // Check if we have bid/ask prices
        if bid.is_none() || ask.is_none() {
            anyhow::bail!("Bid and ask prices are required. Please provide them from the orderbook client.");
        }

        let bid_price = bid.unwrap();
        let ask_price = ask.unwrap();
        let mid_price = (bid_price + ask_price) / 2.0;

        // Calculate limit price with slippage
        // For buy: midPrice * (1 + slippage)
        // For sell: midPrice * (1 - slippage)
        let limit_price = if is_buy {
            mid_price * (1.0 + slippage)
        } else {
            mid_price * (1.0 - slippage)
        };

        // Round price and size
        let is_spot = asset_id >= 10000;
        let limit_price_str = Self::round_price(limit_price, asset_info.sz_decimals, is_spot, is_buy, true); // aggressive=true for market orders
        let size_str = Self::round_size(size, asset_info.sz_decimals);

        info!(
            "[HYPERLIQUID] Market order {} {} {} at limit {} (mid: {:.2}, slippage: {}%, szDecimals: {})",
            if is_buy { "BUY" } else { "SELL" },
            size_str,
            coin,
            limit_price_str,
            mid_price,
            slippage * 100.0,
            asset_info.sz_decimals
        );

        // Construct order
        let order = Order {
            a: asset_id,
            b: is_buy,
            p: limit_price_str,
            s: size_str,
            r: reduce_only,
            t: OrderType {
                limit: LimitOrderType {
                    tif: TimeInForce::Ioc,
                },
            },
            c: None,
        };

        // Construct action
        let action = Action {
            type_: "order".to_string(),
            orders: vec![order],
            grouping: "na".to_string(),
        };

        // Get nonce (current timestamp in milliseconds)
        let nonce = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)?
            .as_millis() as u64;

        // Sign the action
        let signature = self.sign_action(&action, nonce, None).await?;

        // Construct request payload
        Ok(OrderRequest {
            action,
            nonce,
            signature,
            vaultAddress: None,
        })
    }

    /// Place a market order (IOC limit order with slippage)
    ///
    /// # Arguments
    /// * `coin` - Coin symbol (e.g., "SOL", "BTC")
    /// * `is_buy` - True for buy, false for sell
    /// * `size` - Order size
    /// * `slippage` - Slippage tolerance (default 0.05 = 5%)
    /// * `reduce_only` - Whether this is a reduce-only order
    /// * `bid` - Current bid price (if None, will fetch from orderbook client)
    /// * `ask` - Current ask price (if None, will fetch from orderbook client)
    ///
    /// # Returns
    /// Order response with status and order ID
    pub async fn place_market_order(
        &self,
        coin: &str,
        is_buy: bool,
        size: f64,
        slippage: f64,
        reduce_only: bool,
        bid: Option<f64>,
        ask: Option<f64>,
    ) -> Result<OrderResponse> {
        // Build signed order payload (shared with WebSocket execution path)
        let payload = self
            .build_market_order_request(coin, is_buy, size, slippage, reduce_only, bid, ask)
            .await?;

        // Send order via REST API
        debug!("[HYPERLIQUID] Sending order to exchange");
        let response = self
            .client
            .post(&self.exchange_url)
            .json(&payload)
            .send()
            .await
            .context("Failed to send order")?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            anyhow::bail!("Order failed: {}", error_text);
        }

        // Get response text for debugging
        let response_text = response
            .text()
            .await
            .context("Failed to read response text")?;

        debug!("[HYPERLIQUID] Order response (first 500 chars): {}",
            &response_text.chars().take(500).collect::<String>());

        let order_response: OrderResponse = serde_json::from_str(&response_text)
            .context(format!("Failed to parse order response. Response text: {}",
                &response_text.chars().take(300).collect::<String>()))?;

        // Check if response indicates error
        match &order_response.response {
            crate::connector::hyperliquid::OrderResponseContent::Error(error_msg) => {
                anyhow::bail!("Order rejected by exchange: {}", error_msg);
            }
            crate::connector::hyperliquid::OrderResponseContent::Success(_) => {
                info!("[HYPERLIQUID] Order response: {:?}", order_response);
            }
        }

        Ok(order_response)
    }

    /// Get user fills (trade history)
    ///
    /// # Arguments
    /// * `user` - User wallet address in 42-character hexadecimal format
    /// * `aggregate_by_time` - When true, partial fills are combined when a crossing order
    ///                         gets filled by multiple different resting orders
    ///
    /// # Returns
    /// Vector of user fills (up to 2000 most recent fills)
    pub async fn get_user_fills(&self, user: &str, aggregate_by_time: bool) -> Result<Vec<UserFill>> {
        info!("[HYPERLIQUID] Fetching user fills for {} (aggregate: {})", user, aggregate_by_time);

        let payload = json!({
            "type": "userFills",
            "user": user,
            "aggregateByTime": aggregate_by_time
        });

        let response = self
            .client
            .post(&self.info_url)
            .json(&payload)
            .send()
            .await
            .context("Failed to fetch user fills")?;

        let response_text = response.text().await?;
        debug!("[HYPERLIQUID] User fills response: {}", response_text);

        let fills: Vec<UserFill> = serde_json::from_str(&response_text)
            .with_context(|| format!("Failed to parse user fills response: {}", response_text))?;

        debug!("[HYPERLIQUID] Retrieved {} fill(s)", fills.len());

        Ok(fills)
    }

    /// Get user state (positions and margin summary)
    ///
    /// # Arguments
    /// * `user` - User wallet address in 42-character hexadecimal format
    ///
    /// # Returns
    /// User state with positions, margin summary, and account info
    pub async fn get_user_state(&self, user: &str) -> Result<UserState> {
        debug!("[HYPERLIQUID] Fetching user state for {}", user);

        let payload = json!({
            "type": "clearinghouseState",
            "user": user
        });

        let response = self
            .client
            .post(&self.info_url)
            .json(&payload)
            .send()
            .await
            .context("Failed to fetch user state")?;

        let response_text = response.text().await?;
        debug!("[HYPERLIQUID] User state response (first 500 chars): {}",
            &response_text.chars().take(500).collect::<String>());

        let user_state: UserState = serde_json::from_str(&response_text)
            .with_context(|| format!("Failed to parse user state response: {}", response_text))?;

        debug!("[HYPERLIQUID] Retrieved {} position(s)", user_state.asset_positions.len());

        Ok(user_state)
    }

    /// Get wallet address from the internal wallet
    pub fn get_wallet_address(&self) -> String {
        format!("{:?}", self.wallet.address())
    }
}


================================================================================
FILE: src\connector\hyperliquid\types.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\hyperliquid\types.rs
================================================================================

use serde::{Deserialize, Serialize};

/// WebSocket subscription message
#[derive(Debug, Serialize)]
pub struct SubscriptionMessage {
    pub method: String,
    pub subscription: SubscriptionParams,
}

#[derive(Debug, Serialize)]
pub struct SubscriptionParams {
    #[serde(rename = "type")]
    pub type_: String,
    pub coin: String,
}

/// L2 Book request (POST over WebSocket)
#[derive(Debug, Serialize)]
pub struct L2BookRequest {
    pub method: String,
    pub id: u64,
    pub request: L2BookRequestInner,
}

#[derive(Debug, Serialize)]
pub struct L2BookRequestInner {
    #[serde(rename = "type")]
    pub type_: String,
    pub payload: L2BookPayload,
}

#[derive(Debug, Serialize)]
pub struct L2BookPayload {
    #[serde(rename = "type")]
    pub type_: String,
    pub coin: String,
    #[serde(rename = "nSigFigs")]
    pub n_sig_figs: Option<u32>,
    pub mantissa: Option<u32>,
}

/// WebSocket response wrapper
#[derive(Debug, Deserialize)]
pub struct WebSocketResponse {
    pub channel: String,
    #[serde(default)]
    pub data: Option<serde_json::Value>,
}

/// Generic WebSocket POST request wrapper (info or action)
#[derive(Debug, Serialize)]
pub struct WsPostRequest<T> {
    pub method: String,
    pub id: u64,
    pub request: WsPostRequestInner<T>,
}

#[derive(Debug, Serialize)]
pub struct WsPostRequestInner<T> {
    #[serde(rename = "type")]
    pub type_: String,
    pub payload: T,
}

/// Generic WebSocket POST response (for info/action/error)
#[derive(Debug, Deserialize)]
pub struct WsPostResponse {
    pub channel: String,
    pub data: WsPostResponseData,
}

#[derive(Debug, Deserialize)]
pub struct WsPostResponseData {
    pub id: u64,
    pub response: WsPostResponseInner,
}

#[derive(Debug, Deserialize)]
pub struct WsPostResponseInner {
    #[serde(rename = "type")]
    pub type_: String,
    pub payload: serde_json::Value,
}

/// L2 Book response
#[derive(Debug, Deserialize)]
pub struct L2BookResponse {
    pub channel: String,
    pub data: L2BookResponseData,
}

#[derive(Debug, Deserialize)]
pub struct L2BookResponseData {
    pub id: u64,
    pub response: L2BookResponseInner,
}

#[derive(Debug, Deserialize)]
pub struct L2BookResponseInner {
    #[serde(rename = "type")]
    pub type_: String,
    pub payload: L2BookResponsePayload,
}

#[derive(Debug, Deserialize)]
pub struct L2BookResponsePayload {
    #[serde(rename = "type")]
    pub type_: String,
    pub data: L2BookData,
}

/// L2 orderbook data
#[derive(Debug, Clone, Deserialize)]
pub struct L2BookData {
    pub coin: String,
    pub time: u64,
    pub levels: Vec<Vec<BookLevel>>, // [bids, asks]
}

/// Subscription response for l2Book
#[derive(Debug, Deserialize)]
pub struct L2BookSubscriptionResponse {
    pub channel: String,
    pub data: L2BookData,
}

/// Book level with price, size, and number of orders
#[derive(Debug, Clone, Deserialize)]
pub struct BookLevel {
    pub px: String,  // Price
    pub sz: String,  // Size
    pub n: u32,      // Number of orders
}

/// Top of book (best bid and ask)
#[derive(Debug, Clone)]
pub struct TopOfBook {
    pub best_bid: String,
    pub best_ask: String,
    pub coin: String,
    pub timestamp: u64,
}

impl L2BookData {
    /// Extract top of book (best bid and best ask)
    pub fn get_top_of_book(&self) -> Option<TopOfBook> {
        if self.levels.len() < 2 {
            return None;
        }

        let bids = &self.levels[0];
        let asks = &self.levels[1];

        if bids.is_empty() || asks.is_empty() {
            return None;
        }

        // First level is the best price
        let best_bid = &bids[0];
        let best_ask = &asks[0];

        Some(TopOfBook {
            best_bid: best_bid.px.clone(),
            best_ask: best_ask.px.clone(),
            coin: self.coin.clone(),
            timestamp: self.time,
        })
    }
}



/// Time in force for orders
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "PascalCase")]
pub enum TimeInForce {
    Gtc,  // Good till cancel
    Ioc,  // Immediate or cancel (for market orders)
    Alo,  // Add liquidity only (post-only)
}

/// Order type configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderType {
    pub limit: LimitOrderType,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LimitOrderType {
    pub tif: TimeInForce,
}

/// Order for placement
#[derive(Debug, Clone, Serialize)]
pub struct Order {
    pub a: u32,           // Asset ID
    pub b: bool,          // Is buy
    pub p: String,        // Limit price
    pub s: String,        // Size
    pub r: bool,          // Reduce only
    pub t: OrderType,     // Order type
    #[serde(skip_serializing_if = "Option::is_none")]
    pub c: Option<String>, // Client order ID
}

/// Action to be signed
#[derive(Debug, Clone, Serialize)]
pub struct Action {
    #[serde(rename = "type")]
    pub type_: String,
    pub orders: Vec<Order>,
    pub grouping: String,
}

/// EIP-712 signature
#[derive(Debug, Clone, Serialize)]
pub struct Signature {
    pub r: String,
    pub s: String,
    pub v: u32,
}

/// Signed order request payload
#[derive(Debug, Clone, Serialize)]
pub struct OrderRequest {
    pub action: Action,
    pub nonce: u64,
    pub signature: Signature,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub vaultAddress: Option<String>,
}

/// Asset metadata from meta endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct AssetMeta {
    pub name: String,
    #[serde(rename = "szDecimals")]
    pub sz_decimals: i32,
    #[serde(rename = "maxLeverage")]
    pub max_leverage: Option<u32>,
    #[serde(rename = "marginTableId")]
    pub margin_table_id: Option<u32>,
    #[serde(rename = "isDelisted")]
    pub is_delisted: Option<bool>,
}

/// Meta response
#[derive(Debug, Clone, Deserialize)]
pub struct MetaResponse {
    pub universe: Vec<AssetMeta>,
}

/// Order placement response
#[derive(Debug, Clone, Deserialize)]
pub struct OrderResponse {
    pub status: String,
    pub response: OrderResponseContent,
}

/// Response content can be either success (object) or error (string)
#[derive(Debug, Clone, Deserialize)]
#[serde(untagged)]
pub enum OrderResponseContent {
    Success(OrderResponseData),
    Error(String),
}

#[derive(Debug, Clone, Deserialize)]
pub struct OrderResponseData {
    #[serde(rename = "type", default)]
    pub type_: Option<String>,
    pub data: OrderStatusData,
}

#[derive(Debug, Clone, Deserialize)]
pub struct OrderStatusData {
    pub statuses: Vec<OrderStatus>,
}

#[derive(Debug, Clone, Deserialize)]
#[serde(untagged)]
pub enum OrderStatus {
    Resting { resting: RestingOrder },
    Filled { filled: FilledOrder },
    Error { error: String },
}

#[derive(Debug, Clone, Deserialize)]
pub struct RestingOrder {
    pub oid: u64,
}

#[derive(Debug, Clone, Deserialize)]
pub struct FilledOrder {
    pub totalSz: String,
    pub avgPx: String,
    pub oid: u64,
}

/// User fill item from userFills endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct UserFill {
    pub coin: String,             // Symbol (e.g., "AVAX" or "@107" for spot)
    pub px: String,               // Fill price
    pub sz: String,               // Fill size
    pub side: String,             // "B" for buy, "A" for ask/sell
    pub time: u64,                // Timestamp in milliseconds
    pub dir: String,              // Direction: "Open Long", "Sell", "Buy", etc.
    pub fee: String,              // Fee amount
    #[serde(rename = "feeToken")]
    pub fee_token: String,        // Fee token (e.g., "USDC")
    pub oid: u64,                 // Order ID
    pub tid: u64,                 // Trade ID
    pub hash: String,             // Transaction hash
    pub crossed: bool,            // Whether order crossed the spread
    #[serde(rename = "closedPnl")]
    pub closed_pnl: String,       // Closed PnL
    #[serde(rename = "startPosition")]
    pub start_position: String,   // Position size before fill
    #[serde(rename = "builderFee")]
    pub builder_fee: Option<String>, // Optional builder fee
}

/// User state from clearinghouseState endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct UserState {
    #[serde(rename = "assetPositions")]
    pub asset_positions: Vec<AssetPosition>,
    #[serde(rename = "crossMarginSummary")]
    pub cross_margin_summary: CrossMarginSummary,
    #[serde(rename = "marginSummary")]
    pub margin_summary: MarginSummary,
    #[serde(rename = "withdrawable")]
    pub withdrawable: String,
    pub time: u64,
}

/// Asset position wrapper
#[derive(Debug, Clone, Deserialize)]
pub struct AssetPosition {
    #[serde(rename = "type")]
    pub type_: String,  // "oneWay" for one-way mode
    pub position: Position,
}

/// Position data for a specific asset
#[derive(Debug, Clone, Deserialize)]
pub struct Position {
    pub coin: String,                 // Symbol (e.g., "SOL", "BTC")
    pub szi: String,                  // Signed size (positive = long, negative = short)
    #[serde(rename = "entryPx")]
    pub entry_px: Option<String>,     // Entry price
    #[serde(rename = "positionValue")]
    pub position_value: String,       // Position value in USD
    #[serde(rename = "unrealizedPnl")]
    pub unrealized_pnl: String,       // Unrealized PnL
    #[serde(rename = "returnOnEquity")]
    pub return_on_equity: String,     // ROE
    #[serde(rename = "liquidationPx")]
    pub liquidation_px: Option<String>, // Liquidation price (if applicable)
    pub leverage: Leverage,           // Leverage configuration
    #[serde(rename = "marginUsed")]
    pub margin_used: String,          // Margin used for this position
    #[serde(rename = "maxLeverage")]
    pub max_leverage: u32,            // Max leverage allowed for this asset
    #[serde(rename = "cumFunding")]
    pub cum_funding: CumFunding,      // Cumulative funding
}

/// Cumulative funding data
#[derive(Debug, Clone, Deserialize)]
pub struct CumFunding {
    #[serde(rename = "allTime")]
    pub all_time: String,
    #[serde(rename = "sinceOpen")]
    pub since_open: String,
    #[serde(rename = "sinceChange")]
    pub since_change: String,
}

/// Leverage configuration
#[derive(Debug, Clone, Deserialize)]
pub struct Leverage {
    #[serde(rename = "type")]
    pub type_: String,  // "cross" or "isolated"
    pub value: u32,     // Leverage value (e.g., 1, 5, 20)
    #[serde(rename = "rawUsd")]
    pub raw_usd: Option<String>,  // Raw USD value (for isolated positions)
}

/// Margin summary
#[derive(Debug, Clone, Deserialize)]
pub struct MarginSummary {
    #[serde(rename = "accountValue")]
    pub account_value: String,        // Total account value
    #[serde(rename = "totalNtlPos")]
    pub total_ntl_pos: String,        // Total notional position
    #[serde(rename = "totalRawUsd")]
    pub total_raw_usd: String,        // Total raw USD
    #[serde(rename = "totalMarginUsed")]
    pub total_margin_used: String,    // Total margin used
}

/// Cross margin summary
#[derive(Debug, Clone, Deserialize)]
pub struct CrossMarginSummary {
    #[serde(rename = "accountValue")]
    pub account_value: String,        // Account value
    #[serde(rename = "totalNtlPos")]
    pub total_ntl_pos: String,        // Total notional position
    #[serde(rename = "totalRawUsd")]
    pub total_raw_usd: String,        // Total raw USD
    #[serde(rename = "totalMarginUsed")]
    pub total_margin_used: String,    // Total margin used
}


================================================================================
FILE: src\connector\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\mod.rs
================================================================================

pub mod pacifica;
pub mod hyperliquid;


================================================================================
FILE: src\connector\pacifica\client.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\pacifica\client.rs
================================================================================

use crate::connector::pacifica::types::*;
use anyhow::{anyhow, Result};
use futures_util::{SinkExt, StreamExt};
use tokio::time::{sleep, Duration, interval};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{debug, error, info, warn};

const MAINNET_WS_URL: &str = "wss://ws.pacifica.fi/ws";

/// Configuration for the orderbook client
#[derive(Debug, Clone)]
pub struct OrderbookConfig {
    pub symbol: String,
    pub agg_level: u32,
    pub reconnect_attempts: u32,
    pub ping_interval_secs: u64,
}

impl Default for OrderbookConfig {
    fn default() -> Self {
        Self {
            symbol: "BTC".to_string(),
            agg_level: 1,
            reconnect_attempts: 5,
            ping_interval_secs: 30,
        }
    }
}

/// Orderbook WebSocket client with health check and auto-reconnect
pub struct OrderbookClient {
    config: OrderbookConfig,
    ws_url: String,
}

impl OrderbookClient {
    /// Create a new orderbook client
    ///
    /// # Arguments
    /// * `config` - Client configuration
    pub fn new(config: OrderbookConfig) -> Result<Self> {
        let ws_url = MAINNET_WS_URL.to_string();

        info!(
            "[PACIFICA] Initializing orderbook client for {} on mainnet",
            config.symbol
        );

        Ok(Self { config, ws_url })
    }

    /// Start the client with a callback for top of book updates
    ///
    /// # Arguments
    /// * `callback` - Function called with (best_bid_price, best_ask_price, symbol, timestamp)
    pub async fn start<F>(&mut self, mut callback: F) -> Result<()>
    where
        F: FnMut(String, String, String, u64) + Send + 'static,
    {
        let mut reconnect_count = 0;

        loop {
            match self.connect_and_run(&mut callback).await {
                Ok(_) => {
                    info!("[PACIFICA] WebSocket connection closed gracefully");
                    break;
                }
                Err(e) => {
                    reconnect_count += 1;
                    error!(
                        "[PACIFICA] WebSocket error (attempt {}/{}): {}",
                        reconnect_count, self.config.reconnect_attempts, e
                    );

                    if reconnect_count >= self.config.reconnect_attempts {
                        return Err(anyhow!(
                            "[PACIFICA] Failed to connect after {} attempts",
                            self.config.reconnect_attempts
                        ));
                    }

                    // Fast first reconnect (1s), then exponential backoff, capped at 30s
                    let backoff_secs = if reconnect_count == 1 {
                        1
                    } else {
                        std::cmp::min(2_u64.pow(reconnect_count - 1), 30)
                    };
                    warn!("[PACIFICA] Reconnecting in {} seconds...", backoff_secs);
                    sleep(Duration::from_secs(backoff_secs)).await;
                }
            }
        }

        Ok(())
    }

    /// Internal method to connect and run the WebSocket client
    async fn connect_and_run<F>(&self, callback: &mut F) -> Result<()>
    where
        F: FnMut(String, String, String, u64),
    {
        info!("[PACIFICA] Connecting to {}", self.ws_url);

        // Connect to WebSocket
        let (ws_stream, _) = connect_async(&self.ws_url).await?;
        info!("[PACIFICA] WebSocket connected successfully");

        let (mut write, mut read) = ws_stream.split();

        // Subscribe to orderbook
        let subscribe_msg = SubscribeMessage::new(
            self.config.symbol.clone(),
            self.config.agg_level,
        );
        let subscribe_json = serde_json::to_string(&subscribe_msg)?;

        debug!("[PACIFICA] Sending subscription: {}", subscribe_json);
        write.send(Message::Text(subscribe_json)).await?;
        info!("[PACIFICA] Subscribed to orderbook for {}", self.config.symbol);

        // Setup ping interval
        let mut ping_interval = interval(Duration::from_secs(self.config.ping_interval_secs));
        ping_interval.tick().await; // Skip first immediate tick

        // Main event loop
        loop {
            tokio::select! {
                // Handle incoming messages
                msg = read.next() => {
                    match msg {
                        Some(Ok(Message::Text(text))) => {
                            debug!("[PACIFICA] Received message: {}", text);
                            self.handle_message(&text, callback)?;
                        }
                        Some(Ok(Message::Close(_))) => {
                            info!("[PACIFICA] Received close message from server");
                            break;
                        }
                        Some(Ok(Message::Ping(data))) => {
                            debug!("[PACIFICA] Received ping from server");
                            write.send(Message::Pong(data)).await?;
                        }
                        Some(Ok(Message::Pong(_))) => {
                            debug!("[PACIFICA] Received pong from server");
                        }
                        Some(Err(e)) => {
                            return Err(anyhow!("[PACIFICA] WebSocket error: {}", e));
                        }
                        None => {
                            warn!("[PACIFICA] WebSocket stream ended");
                            break;
                        }
                        _ => {}
                    }
                }

                // Send periodic pings
                _ = ping_interval.tick() => {
                    let ping_msg = PingMessage::new();
                    let ping_json = serde_json::to_string(&ping_msg)?;
                    debug!("[PACIFICA] Sending ping: {}", ping_json);

                    if let Err(e) = write.send(Message::Text(ping_json)).await {
                        error!("[PACIFICA] Failed to send ping: {}", e);
                        return Err(anyhow!("[PACIFICA] Failed to send ping: {}", e));
                    }
                }
            }
        }

        Ok(())
    }

    /// Handle incoming WebSocket messages
    fn handle_message<F>(&self, text: &str, callback: &mut F) -> Result<()>
    where
        F: FnMut(String, String, String, u64),
    {
        // First try to parse as generic response to check channel
        let response: WebSocketResponse = serde_json::from_str(text)?;

        // Handle messages without channel field
        let channel = match response.channel {
            Some(ch) => ch,
            None => {
                debug!("[PACIFICA] Received message without channel field, ignoring: {}",
                    if text.len() > 100 { &text[..100] } else { text });
                return Ok(());
            }
        };

        match channel.as_str() {
            "pong" => {
                debug!("[PACIFICA] Received pong response");
                Ok(())
            }
            "book" => {
                // Parse as orderbook response
                let orderbook_response: OrderbookResponse = serde_json::from_str(text)?;
                let orderbook_data = orderbook_response.data;

                // Extract top of book
                let tob = orderbook_data.get_top_of_book();

                // Call the callback with top of book data
                if let (Some(bid), Some(ask)) = (tob.best_bid, tob.best_ask) {
                    callback(
                        bid.price,
                        ask.price,
                        tob.symbol,
                        tob.timestamp,
                    );
                } else {
                    warn!("[PACIFICA] Incomplete top of book data received");
                }

                Ok(())
            }
            other => {
                debug!("[PACIFICA] Received unknown channel: {}", other);
                Ok(())
            }
        }
    }
}

impl Drop for OrderbookClient {
    fn drop(&mut self) {
        info!("[PACIFICA] OrderbookClient dropped for symbol: {}", self.config.symbol);
    }
}


================================================================================
FILE: src\connector\pacifica\fill_detection.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\pacifica\fill_detection.rs
================================================================================

use anyhow::{Context, Result};
use futures_util::{SinkExt, StreamExt};
use std::collections::{HashMap, HashSet};
use std::sync::Arc;
use std::time::Instant;
use parking_lot::Mutex;
use tokio::time::{interval, Duration};
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{debug, error, info, warn};

use super::types::{
    AccountOrderUpdatesResponse, AccountOrderUpdatesSubscribe, AccountPositionsResponse,
    AccountPositionsSubscribe, FillEvent, PingMessage,
};

/// Configuration for fill detection client
#[derive(Debug, Clone)]
pub struct FillDetectionConfig {
    /// Account address to monitor
    pub account: String,
    /// Maximum number of reconnection attempts
    pub reconnect_attempts: u32,
    /// Ping interval in seconds
    pub ping_interval_secs: u64,
    /// Enable position-based fill detection (redundancy layer)
    pub enable_position_fill_detection: bool,
}

/// Handle for updating position baselines from external fill sources
///
/// This allows order-based fill detection to update the position baseline
/// so that position-based detection doesn't trigger duplicate hedges.
#[derive(Clone)]
pub struct PositionBaselineUpdater {
    position_snapshots: Arc<Mutex<HashMap<String, PositionSnapshot>>>,
    position_initialized: Arc<Mutex<HashSet<String>>>,
}

impl PositionBaselineUpdater {
    /// Update position baseline when a fill is detected
    ///
    /// # Arguments
    /// * `symbol` - Trading symbol
    /// * `side` - Fill side ("buy" or "sell")
    /// * `filled_amount` - Amount that was filled
    /// * `avg_price` - Average fill price
    pub fn update_baseline(&self, symbol: &str, side: &str, filled_amount: f64, avg_price: f64) {
        // Batch lock acquisition for lower latency
        let mut snapshots = self.position_snapshots.lock();
        let mut initialized = self.position_initialized.lock();

        // Get current snapshot or default to 0.0
        let prev_qty = snapshots.get(symbol).map(|s| s.quantity).unwrap_or(0.0);

        // Calculate new position based on fill
        let delta = if side == "buy" { filled_amount } else { -filled_amount };
        let new_qty = prev_qty + delta;

        // Update snapshot
        snapshots.insert(
            symbol.to_string(),
            PositionSnapshot {
                quantity: new_qty,
                entry_price: avg_price,
                timestamp: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u64,
            },
        );

        // Mark as initialized
        initialized.insert(symbol.to_string());

        debug!(
            "[POSITION SYNC] Updated {} baseline: {:.4} → {:.4} ({} {:.4} @ ${:.4})",
            symbol, prev_qty, new_qty, side.to_uppercase(), filled_amount, avg_price
        );
    }
}

/// Position snapshot for tracking changes
#[derive(Debug, Clone)]
struct PositionSnapshot {
    quantity: f64,      // Signed quantity (+ for long, - for short)
    entry_price: f64,
    timestamp: u64,
}

/// WebSocket client for monitoring order fills and updates
pub struct FillDetectionClient {
    config: FillDetectionConfig,
    ws_url: String,
    /// Position snapshots per symbol for delta detection
    position_snapshots: Arc<Mutex<HashMap<String, PositionSnapshot>>>,
    /// Track last order fill time for cross-validation (symbol -> timestamp)
    last_order_fill_time: Arc<Mutex<Instant>>,
    /// Track which symbols have received their first position update (for baseline initialization)
    position_initialized: Arc<Mutex<HashSet<String>>>,
}

impl FillDetectionClient {
    /// Create a new fill detection client
    ///
    /// # Arguments
    /// * `config` - Fill detection configuration
    /// * `is_testnet` - Whether to use testnet (false = mainnet)
    pub fn new(config: FillDetectionConfig, is_testnet: bool) -> Result<Self> {
        let ws_url = if is_testnet {
            "wss://test-ws.pacifica.fi/ws".to_string()
        } else {
            "wss://ws.pacifica.fi/ws".to_string()
        };

        Ok(Self {
            config,
            ws_url,
            position_snapshots: Arc::new(Mutex::new(HashMap::new())),
            last_order_fill_time: Arc::new(Mutex::new(Instant::now())),
            position_initialized: Arc::new(Mutex::new(HashSet::new())),
        })
    }

    /// Get a handle for updating position baselines from external sources
    ///
    /// CRITICAL: Use this to update baselines when order-based fills are detected,
    /// preventing position-based detection from triggering duplicate hedges.
    pub fn get_baseline_updater(&self) -> PositionBaselineUpdater {
        PositionBaselineUpdater {
            position_snapshots: self.position_snapshots.clone(),
            position_initialized: self.position_initialized.clone(),
        }
    }

    /// Initialize position snapshots from external source (e.g., REST API at startup)
    ///
    /// This method allows pre-populating position baselines before starting the WebSocket,
    /// preventing false fill detection from pre-existing positions.
    ///
    /// # Arguments
    /// * `positions` - Vector of (symbol, quantity, entry_price, timestamp) tuples
    ///   where quantity is signed (+ for long, - for short)
    pub fn initialize_positions(&self, positions: Vec<(String, f64, f64, u64)>) {
        // Batch lock acquisition for lower latency
        let mut snapshots = self.position_snapshots.lock();
        let mut initialized = self.position_initialized.lock();

        for (symbol, quantity, entry_price, timestamp) in positions {
            snapshots.insert(
                symbol.clone(),
                PositionSnapshot {
                    quantity,
                    entry_price,
                    timestamp,
                },
            );
            initialized.insert(symbol.clone());
            info!(
                "[POSITION INIT] Pre-initialized {} position: {:.4} @ ${:.4}",
                symbol, quantity, entry_price
            );
        }
    }

    /// Update position baseline when a fill is detected by other sources
    ///
    /// CRITICAL: This prevents position-based detection from triggering duplicate hedges
    /// when order-based detection already processed the fill.
    ///
    /// # Arguments
    /// * `symbol` - Trading symbol
    /// * `side` - Fill side ("buy" or "sell")
    /// * `filled_amount` - Amount that was filled
    /// * `avg_price` - Average fill price
    pub fn update_position_baseline(&self, symbol: &str, side: &str, filled_amount: f64, avg_price: f64) {
        // Batch lock acquisition for lower latency
        let mut snapshots = self.position_snapshots.lock();
        let mut initialized = self.position_initialized.lock();

        // Get current snapshot or default to 0.0
        let prev_qty = snapshots.get(symbol).map(|s| s.quantity).unwrap_or(0.0);

        // Calculate new position based on fill
        let delta = if side == "buy" { filled_amount } else { -filled_amount };
        let new_qty = prev_qty + delta;

        // Update snapshot
        snapshots.insert(
            symbol.to_string(),
            PositionSnapshot {
                quantity: new_qty,
                entry_price: avg_price,
                timestamp: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_millis() as u64,
            },
        );

        // Mark as initialized
        initialized.insert(symbol.to_string());

        debug!(
            "[POSITION SYNC] Updated {} baseline: {:.4} → {:.4} ({}  {:.4} @ ${:.4})",
            symbol, prev_qty, new_qty, side.to_uppercase(), filled_amount, avg_price
        );
    }

    /// Start the fill detection client with a callback for fill events
    ///
    /// # Arguments
    /// * `callback` - Function called for each fill event (partial fill, full fill, cancellation)
    pub async fn start<F>(&mut self, mut callback: F) -> Result<()>
    where
        F: FnMut(FillEvent) + Send + 'static,
    {
        let mut attempt = 0;

        loop {
            attempt += 1;
            info!(
                "Fill detection attempt {}/{}",
                attempt, self.config.reconnect_attempts
            );

            match self.connect_and_run(&mut callback).await {
                Ok(_) => {
                    info!("Fill detection client disconnected normally");
                    break;
                }
                Err(e) => {
                    error!("Fill detection error: {}", e);

                    if attempt >= self.config.reconnect_attempts {
                        error!("Max reconnection attempts reached");
                        return Err(e);
                    }

                    // Fast first reconnect (1s), then exponential backoff, capped at 30s
                    let backoff = if attempt == 1 {
                        1
                    } else {
                        std::cmp::min(2u64.pow(attempt - 1), 30)
                    };
                    warn!("Reconnecting in {} seconds...", backoff);
                    tokio::time::sleep(Duration::from_secs(backoff)).await;
                }
            }
        }

        Ok(())
    }

    /// Connect to WebSocket and run the monitoring loop
    async fn connect_and_run<F>(&self, callback: &mut F) -> Result<()>
    where
        F: FnMut(FillEvent) + Send + 'static,
    {
        info!("Connecting to Pacifica WebSocket: {}", self.ws_url);

        let (ws_stream, _) = connect_async(&self.ws_url)
            .await
            .context("Failed to connect to WebSocket")?;

        info!("WebSocket connected successfully");

        let (mut write, mut read) = ws_stream.split();

        // Subscribe to account order updates
        let subscribe_msg = AccountOrderUpdatesSubscribe::new(self.config.account.clone());
        let subscribe_json = serde_json::to_string(&subscribe_msg)?;
        write.send(Message::Text(subscribe_json)).await?;
        info!(
            "Subscribed to account_order_updates for account: {}",
            self.config.account
        );

        // Subscribe to account positions (for position-based fill detection)
        if self.config.enable_position_fill_detection {
            let positions_subscribe = AccountPositionsSubscribe::new(self.config.account.clone());
            let positions_json = serde_json::to_string(&positions_subscribe)?;
            write.send(Message::Text(positions_json)).await?;
            info!(
                "Subscribed to account_positions for account: {}",
                self.config.account
            );
        }

        // Set up ping interval
        let mut ping_interval = interval(Duration::from_secs(self.config.ping_interval_secs));

        loop {
            tokio::select! {
                // Handle incoming messages
                msg = read.next() => {
                    match msg {
                        Some(Ok(Message::Text(text))) => {
                            if let Err(e) = self.handle_message(&text, callback) {
                                error!("Error handling message: {}", e);
                            }
                        }
                        Some(Ok(Message::Close(_))) => {
                            info!("WebSocket closed by server");
                            break;
                        }
                        Some(Err(e)) => {
                            error!("WebSocket error: {}", e);
                            return Err(e.into());
                        }
                        None => {
                            info!("WebSocket stream ended");
                            break;
                        }
                        _ => {}
                    }
                }

                // Send periodic pings
                _ = ping_interval.tick() => {
                    let ping_msg = PingMessage::new();
                    let ping_json = serde_json::to_string(&ping_msg)?;
                    write.send(Message::Text(ping_json)).await?;
                    debug!("Sent ping");
                }
            }
        }

        Ok(())
    }

    /// Handle incoming WebSocket message
    fn handle_message<F>(&self, text: &str, callback: &mut F) -> Result<()>
    where
        F: FnMut(FillEvent) + Send + 'static,
    {
        // Try to parse as a generic response first to check channel
        let response: serde_json::Value = serde_json::from_str(text)?;

        if let Some(channel) = response.get("channel").and_then(|v| v.as_str()) {
            match channel {
                "pong" => {
                    debug!("Received pong");
                }
                "account_order_updates" => {
                    // Parse as account order updates response
                    let updates: AccountOrderUpdatesResponse = serde_json::from_str(text)?;
                    debug!(
                        "Received {} order update(s)",
                        updates.data.len()
                    );

                    // Update last order fill time for cross-validation
                    *self.last_order_fill_time.lock() = Instant::now();

                    // Process each order update
                    for update in updates.data {
                        debug!(
                            "Order update - ID: {}, Status: {:?}, Event: {:?}, Filled: {}/{}",
                            update.order_id,
                            update.order_status,
                            update.order_event,
                            update.filled_amount,
                            update.original_amount
                        );

                        // Convert to fill event and call callback if applicable
                        if let Some(fill_event) = update.to_fill_event() {
                            callback(fill_event);
                        }
                    }
                }
                "account_positions" => {
                    if self.config.enable_position_fill_detection {
                        // Parse as account positions response
                        let positions: AccountPositionsResponse = serde_json::from_str(text)?;
                        debug!(
                            "Received {} position update(s)",
                            positions.data.len()
                        );

                        // Process each position update
                        for position in positions.data {
                            if let Some(fill_event) = self.detect_fill_from_position(&position) {
                                callback(fill_event);
                            }
                        }
                    }
                }
                _ => {
                    debug!("Received message on channel: {}", channel);
                }
            }
        }

        Ok(())
    }

    /// Detect fill from position change (redundancy layer)
    ///
    /// Optimized for low latency with batched lock acquisition.
    fn detect_fill_from_position(&self, position: &super::types::PositionData) -> Option<FillEvent> {
        // Parse position data with validation (no locks needed)
        let amount: f64 = match position.amount.parse::<f64>() {
            Ok(val) if val >= 0.0 && val.is_finite() => val,
            Ok(val) => {
                warn!(
                    "[POSITION VALIDATION] Invalid amount value: {} (must be non-negative and finite)",
                    val
                );
                return None;
            }
            Err(e) => {
                warn!(
                    "[POSITION VALIDATION] Failed to parse amount '{}': {}",
                    position.amount, e
                );
                return None;
            }
        };

        let entry_price: f64 = match position.entry_price.parse::<f64>() {
            Ok(val) if val > 0.0 && val.is_finite() => val,
            Ok(val) => {
                warn!(
                    "[POSITION VALIDATION] Invalid entry_price value: {} (must be positive and finite)",
                    val
                );
                return None;
            }
            Err(e) => {
                warn!(
                    "[POSITION VALIDATION] Failed to parse entry_price '{}': {}",
                    position.entry_price, e
                );
                return None;
            }
        };

        // Validate side field
        if position.side != "ask" && position.side != "bid" {
            warn!(
                "[POSITION VALIDATION] Invalid side value: '{}' (must be 'ask' or 'bid')",
                position.side
            );
            return None;
        }

        // Convert to signed quantity (+ for long, - for short)
        let quantity = if position.side == "ask" {
            -amount  // Short position
        } else {
            amount   // Long position
        };

        debug!(
            "[POSITION UPDATE] {} | amount: {}, side: {}, entry: ${}, quantity: {}",
            position.symbol, amount, position.side, entry_price, quantity
        );

        // BATCH LOCK ACQUISITION: Acquire all locks at once for lower latency
        // This eliminates multiple lock/unlock cycles in the hot path
        let mut initialized = self.position_initialized.lock();
        let mut snapshots = self.position_snapshots.lock();

        let is_first_update = !initialized.contains(&position.symbol);
        let prev_snapshot = snapshots.get(&position.symbol).cloned();
        let prev_qty = prev_snapshot.as_ref().map(|s| s.quantity).unwrap_or(0.0);
        let delta = quantity - prev_qty;

        // CRITICAL FIX: If this is the first position update for this symbol,
        // treat it as baseline initialization ONLY (don't trigger fills)
        // This prevents false positives from detecting pre-existing positions as new fills
        if is_first_update {
            info!(
                "[POSITION BASELINE] Initializing position snapshot for {}: {:.4} (side: {}, entry: ${:.4})",
                position.symbol,
                quantity,
                position.side,
                entry_price
            );

            // Mark this symbol as initialized and save baseline snapshot
            initialized.insert(position.symbol.clone());
            snapshots.insert(
                position.symbol.clone(),
                PositionSnapshot {
                    quantity,
                    entry_price,
                    timestamp: position.timestamp,
                },
            );

            return None;  // Don't trigger fill detection on first update
        }

        // Validate timestamp - reject stale updates (older than previous snapshot)
        if let Some(ref prev) = prev_snapshot {
            if position.timestamp <= prev.timestamp {
                warn!(
                    "[POSITION VALIDATION] Stale position update detected for {} (current: {}, previous: {}). Ignoring.",
                    position.symbol,
                    position.timestamp,
                    prev.timestamp
                );
                return None;  // Ignore stale updates
            }
        }

        // Only detect fills if there's a significant change (> 0.0001 for floating point tolerance)
        if delta.abs() < 0.0001 {
            // Update snapshot even if no change
            snapshots.insert(
                position.symbol.clone(),
                PositionSnapshot {
                    quantity,
                    entry_price,
                    timestamp: position.timestamp,
                },
            );
            return None;
        }

        // Validate delta is reasonable (max 10 units for safety)
        // This prevents triggering on obviously corrupted data
        if delta.abs() > 10.0 {
            warn!(
                "[POSITION VALIDATION] Unreasonably large position delta detected: {:.4} (prev: {:.4}, new: {:.4}). Possible data corruption. NOT triggering hedge.",
                delta, prev_qty, quantity
            );

            // Update snapshot but don't trigger fill
            snapshots.insert(
                position.symbol.clone(),
                PositionSnapshot {
                    quantity,
                    entry_price,
                    timestamp: position.timestamp,
                },
            );
            return None;
        }

        // Determine fill side from delta
        let side = if delta > 0.0 { "buy" } else { "sell" };

        // Update snapshot before releasing locks
        snapshots.insert(
            position.symbol.clone(),
            PositionSnapshot {
                quantity,
                entry_price,
                timestamp: position.timestamp,
            },
        );

        // Release position locks before acquiring last_order_fill_time lock
        // to avoid potential deadlock and reduce lock hold time
        drop(snapshots);
        drop(initialized);

        // Cross-validate: check if we received order fills recently (for logging purposes only)
        let (cross_validated, seconds_since_last_fill) = {
            let last_time = self.last_order_fill_time.lock();
            let elapsed = last_time.elapsed().as_secs();
            (elapsed < 60, elapsed)
        };

        // Log fill detection with cross-validation status (informational only)
        if cross_validated {
            info!(
                "[POSITION FILL ✓] {} {:.4} {} @ {:.4} (pos: {:.4} → {:.4}, cross-validated with order updates)",
                side.to_uppercase(),
                delta.abs(),
                position.symbol,
                entry_price,
                prev_qty,
                quantity
            );
        } else {
            info!(
                "[POSITION FILL ⚠] {} {:.4} {} @ {:.4} (pos: {:.4} → {:.4}, {} sec since last order activity)",
                side.to_uppercase(),
                delta.abs(),
                position.symbol,
                entry_price,
                prev_qty,
                quantity,
                seconds_since_last_fill
            );
        }

        // Create position-based fill event
        Some(FillEvent::PositionFill {
            symbol: position.symbol.clone(),
            side: side.to_string(),
            filled_amount: delta.abs().to_string(),
            avg_price: entry_price.to_string(),
            timestamp: position.timestamp,
            position_delta: delta.to_string(),
            prev_position: prev_qty.to_string(),
            new_position: quantity.to_string(),
            cross_validated,
        })
    }
}


================================================================================
FILE: src\connector\pacifica\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\pacifica\mod.rs
================================================================================

mod types;
mod client;
pub mod trading;
pub mod fill_detection;
pub mod ws_trading;

pub use client::{OrderbookClient, OrderbookConfig};
pub use trading::{OpenOrderItem, PositionItem, PositionResponse, PacificaTrading, PacificaCredentials, OrderSide, TradeHistoryItem};
pub use fill_detection::{FillDetectionClient, FillDetectionConfig, PositionBaselineUpdater};
pub use ws_trading::PacificaWsTrading;
pub use types::{FillEvent, OrderStatus, OrderEvent};


================================================================================
FILE: src\connector\pacifica\trading.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\pacifica\trading.rs
================================================================================

use anyhow::{Context, Result};
use ed25519_dalek::{Signer, SigningKey};
use serde::Deserialize;
use serde_json::json;
use std::collections::HashMap;
use std::sync::{Arc, Mutex};
use tracing::{debug, info};
use uuid::Uuid;

const MAINNET_REST_URL: &str = "https://api.pacifica.fi";

/// Credentials for Pacifica trading
#[derive(Debug, Clone)]
pub struct PacificaCredentials {
    pub account: String,           // Main wallet address (SOL_WALLET)
    pub agent_wallet: String,      // Agent wallet public key (API_PUBLIC)
    pub private_key: String,       // Agent wallet private key (API_PRIVATE)
}

impl PacificaCredentials {
    /// Load credentials from environment variables
    pub fn from_env() -> Result<Self> {
        dotenv::dotenv().ok(); // Load .env file

        let account = std::env::var("SOL_WALLET")
            .context("SOL_WALLET not found in environment")?;
        let agent_wallet = std::env::var("API_PUBLIC")
            .context("API_PUBLIC not found in environment")?;
        let private_key = std::env::var("API_PRIVATE")
            .context("API_PRIVATE not found in environment")?;

        Ok(Self {
            account,
            agent_wallet,
            private_key,
        })
    }
}

/// Market information for a symbol
#[derive(Debug, Clone, Deserialize)]
pub struct MarketInfo {
    pub symbol: String,
    pub tick_size: String,  // Minimum price increment (e.g., "0.1")
    pub lot_size: String,   // Minimum size increment (e.g., "0.001")
}

/// Order side
#[derive(Debug, Clone, Copy)]
pub enum OrderSide {
    Buy,
    Sell,
}

impl OrderSide {
    pub fn as_str(&self) -> &'static str {
        match self {
            OrderSide::Buy => "bid",
            OrderSide::Sell => "ask",
        }
    }
}

/// Order response from API
#[derive(Debug, Deserialize)]
pub struct OrderResponse {
    pub success: Option<bool>,
    pub data: Option<OrderData>,
}

#[derive(Debug, Deserialize)]
pub struct OrderData {
    pub order_id: Option<u64>,
    #[serde(rename = "i")]
    pub i: Option<u64>,  // Alternative field name
    #[serde(rename = "I")]
    pub client_order_id: Option<String>,
    #[serde(rename = "s")]
    pub symbol: Option<String>,
}

/// Orderbook level from REST API
#[derive(Debug, Clone, Deserialize)]
pub struct RestBookLevel {
    #[serde(rename = "p")]
    pub price: String,
    #[serde(rename = "a")]
    pub amount: String,
    #[serde(rename = "n")]
    pub num_orders: u32,
}

/// Orderbook snapshot from REST API (raw format)
#[derive(Debug, Clone, Deserialize)]
pub struct RestBookData {
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "l")]
    pub levels: (Vec<RestBookLevel>, Vec<RestBookLevel>), // (bids, asks)
}

/// Orderbook REST API response
#[derive(Debug, Deserialize)]
pub struct RestBookResponse {
    pub success: bool,
    pub data: Option<RestBookData>,
}

/// Simplified orderbook level [price, size]
#[derive(Debug, Clone)]
pub struct OrderbookLevel {
    pub price: String,
    pub size: String,
}

/// Simplified orderbook snapshot
#[derive(Debug, Clone)]
pub struct OrderbookSnapshot {
    pub bids: Vec<OrderbookLevel>,
    pub asks: Vec<OrderbookLevel>,
}

/// Trade history item from positions/history endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct TradeHistoryItem {
    pub history_id: u64,
    pub order_id: u64,
    pub client_order_id: Option<String>,  // Can be null for some orders (e.g., liquidations)
    pub symbol: String,
    pub amount: String,           // Size of trade in token denomination
    pub price: String,            // Current market price
    pub entry_price: String,      // Actual fill price
    pub fee: String,              // Fee paid
    pub pnl: String,              // PnL from this trade
    pub event_type: String,       // "fulfill_maker" or "fulfill_taker"
    pub side: String,             // "open_long", "open_short", "close_long", "close_short"
    pub created_at: u64,          // Timestamp in milliseconds
    pub cause: String,            // "normal", "market_liquidation", etc.
    #[serde(default)]
    pub value: Option<String>,    // Actual USD notional value of the trade (if provided by API)
}

/// Trade history response from API
#[derive(Debug, Deserialize)]
pub struct TradeHistoryResponse {
    pub success: bool,
    pub data: Option<Vec<TradeHistoryItem>>,
    #[serde(default)]
    pub next_cursor: Option<String>,  // Pagination cursor for next page
    #[serde(default)]
    pub has_more: Option<bool>,       // Whether more results exist
    pub error: Option<String>,
    pub code: Option<String>,
}

/// Open order item from /api/v1/orders endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct OpenOrderItem {
    pub order_id: u64,
    pub client_order_id: String,
    pub symbol: String,
    pub side: String,              // "bid" or "ask"
    pub price: String,
    pub initial_amount: String,
    pub filled_amount: String,
    pub cancelled_amount: String,
    #[serde(default)]
    pub stop_price: Option<String>,
    pub order_type: String,        // "limit" or "market"
    #[serde(default)]
    pub stop_parent_order_id: Option<String>,
    pub reduce_only: bool,
    pub created_at: u64,
    pub updated_at: u64,
}

/// Open orders response from API
#[derive(Debug, Deserialize)]
pub struct OpenOrdersResponse {
    pub success: bool,
    pub data: Option<Vec<OpenOrderItem>>,
    pub error: Option<String>,
    pub code: Option<String>,
}

/// Position item from GET /api/v1/positions endpoint
#[derive(Debug, Clone, Deserialize)]
pub struct PositionItem {
    pub symbol: String,
    pub side: String,              // "bid" (long) or "ask" (short)
    pub amount: String,            // Position size (always positive)
    pub entry_price: String,       // Average entry price
    #[serde(default)]
    pub margin: Option<String>,    // Margin for isolated positions
    pub funding: String,           // Funding paid since position opened
    pub isolated: bool,            // Whether position is in isolated margin mode
    pub created_at: u64,           // Timestamp in milliseconds
    pub updated_at: u64,           // Timestamp in milliseconds
}

/// Position API response
#[derive(Debug, Deserialize)]
pub struct PositionResponse {
    pub success: bool,
    pub data: Option<Vec<PositionItem>>,
    pub error: Option<String>,
    pub code: Option<String>,
}

/// Pacifica trading client
pub struct PacificaTrading {
    credentials: PacificaCredentials,
    rest_url: String,
    client: reqwest::Client,
    market_info_cache: Arc<Mutex<Option<HashMap<String, MarketInfo>>>>,
}

impl PacificaTrading {
    /// Create a new trading client (mainnet only)
    pub fn new(credentials: PacificaCredentials) -> Result<Self> {
        let client = reqwest::Client::builder()
            .timeout(std::time::Duration::from_secs(10))        // Max 10s per request
            .connect_timeout(std::time::Duration::from_secs(5)) // Max 5s to connect
            .build()
            .context("Failed to build HTTP client")?;

        Ok(Self {
            credentials,
            rest_url: MAINNET_REST_URL.to_string(),
            client,
            market_info_cache: Arc::new(Mutex::new(None)),
        })
    }

    /// Fetch market info for all symbols
    /// Uses internal caching with Mutex to allow &self (no external mutation needed)
    pub async fn get_market_info(&self) -> Result<HashMap<String, MarketInfo>> {
        // Check cache first
        {
            let cache_guard = self.market_info_cache.lock().unwrap();
            if let Some(ref cached) = *cache_guard {
                return Ok(cached.clone());
            }
        }

        // Cache miss - fetch from API
        let url = format!("{}/api/v1/info", self.rest_url);
        let response = self.client.get(&url).send().await?;

        if !response.status().is_success() {
            anyhow::bail!("Failed to fetch market info: {}", response.status());
        }

        #[derive(Deserialize)]
        struct ApiResponse {
            data: Vec<MarketInfo>,
        }

        let api_response: ApiResponse = response.json().await?;

        let mut new_cache = HashMap::new();
        for info in api_response.data {
            new_cache.insert(info.symbol.clone(), info);
        }

        info!("[PACIFICA] Cached market info for {} symbols", new_cache.len());

        // Update cache
        {
            let mut cache_guard = self.market_info_cache.lock().unwrap();
            *cache_guard = Some(new_cache.clone());
        }

        Ok(new_cache)
    }

    /// Fetch orderbook snapshot via REST API
    ///
    /// # Arguments
    /// * `symbol` - Trading symbol (e.g., "SOL", "BTC")
    /// * `agg_level` - Aggregation level (1, 2, 5, 10, 100, 1000)
    ///
    /// # Returns
    /// Orderbook snapshot with bids and asks
    pub async fn get_orderbook_rest(
        &self,
        symbol: &str,
        agg_level: u32,
    ) -> Result<OrderbookSnapshot> {
        let url = format!(
            "{}/api/v1/book?symbol={}&agg_level={}",
            self.rest_url, symbol, agg_level
        );

        debug!("[PACIFICA] Fetching orderbook via REST: {}", url);

        let response = self.client.get(&url).send().await?;

        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await?;
            anyhow::bail!("Failed to fetch orderbook: {} - {}", status, error_text);
        }

        let book_response: RestBookResponse = response.json().await?;

        if !book_response.success {
            anyhow::bail!("Orderbook request failed");
        }

        let book_data = book_response
            .data
            .context("No orderbook data in response")?;

        // Convert from RestBookLevel to OrderbookLevel
        let bids: Vec<OrderbookLevel> = book_data.levels.0
            .into_iter()
            .map(|level| OrderbookLevel {
                price: level.price,
                size: level.amount,
            })
            .collect();

        let asks: Vec<OrderbookLevel> = book_data.levels.1
            .into_iter()
            .map(|level| OrderbookLevel {
                price: level.price,
                size: level.amount,
            })
            .collect();

        debug!(
            "[PACIFICA] Orderbook for {}: {} bids, {} asks",
            symbol,
            bids.len(),
            asks.len()
        );

        Ok(OrderbookSnapshot { bids, asks })
    }

    /// Get best bid and ask prices from REST API
    ///
    /// # Arguments
    /// * `symbol` - Trading symbol (e.g., "SOL", "BTC")
    /// * `agg_level` - Aggregation level (1, 2, 5, 10, 100, 1000)
    ///
    /// # Returns
    /// Tuple of (best_bid, best_ask) or None if orderbook is empty
    pub async fn get_best_bid_ask_rest(
        &self,
        symbol: &str,
        agg_level: u32,
    ) -> Result<Option<(f64, f64)>> {
        let snapshot = self.get_orderbook_rest(symbol, agg_level).await?;

        let best_bid = snapshot
            .bids
            .first()
            .and_then(|level| level.price.parse::<f64>().ok());

        let best_ask = snapshot
            .asks
            .first()
            .and_then(|level| level.price.parse::<f64>().ok());

        match (best_bid, best_ask) {
            (Some(bid), Some(ask)) => Ok(Some((bid, ask))),
            _ => Ok(None),
        }
    }

    /// Round price to tick size
    fn round_to_tick_size(&self, price: f64, tick_size: String) -> Result<f64> {
        let tick: f64 = tick_size.parse()?;
        let rounded = (price / tick).round() * tick;

        let decimal_places = if tick_size.contains('.') {
            tick_size.split('.').nth(1).unwrap().len()
        } else {
            0
        };

        let factor = 10_f64.powi(decimal_places as i32);
        Ok((rounded * factor).round() / factor)
    }

    /// Round size to lot size
    fn round_to_lot_size(&self, size: f64, lot_size: String) -> Result<f64> {
        let lot: f64 = lot_size.parse()?;
        let rounded = (size / lot).round() * lot;

        let decimal_places = if lot_size.contains('.') {
            lot_size.split('.').nth(1).unwrap().len()
        } else {
            0
        };

        let factor = 10_f64.powi(decimal_places as i32);
        Ok((rounded * factor).round() / factor)
    }

    /// Sign a message using Ed25519
    fn sign_message(&self, header: serde_json::Value, payload: serde_json::Value) -> Result<String> {
        // Construct message: {... header, data: payload}
        let mut message = serde_json::json!({});
        if let serde_json::Value::Object(ref mut map) = message {
            if let serde_json::Value::Object(header_map) = header {
                for (k, v) in header_map {
                    map.insert(k, v);
                }
            }
            map.insert("data".to_string(), payload);
        }

        // Canonicalize JSON (sort keys alphabetically)
        let canonical = canonicalize_json(&message);

        // Decode private key from base58
        let private_key_bytes = bs58::decode(&self.credentials.private_key)
            .into_vec()
            .context("Failed to decode private key")?;

        // Solana/Pacifica private keys are 64 bytes (32 bytes seed + 32 bytes public key)
        // Ed25519 SigningKey needs only the first 32 bytes (the seed)
        if private_key_bytes.len() != 64 {
            anyhow::bail!(
                "Invalid private key length: expected 64 bytes, got {}",
                private_key_bytes.len()
            );
        }

        let seed_bytes: [u8; 32] = private_key_bytes[0..32]
            .try_into()
            .context("Failed to extract seed from private key")?;

        // Create signing key from seed
        let signing_key = SigningKey::from_bytes(&seed_bytes);

        // Sign the message
        let signature = signing_key.sign(canonical.as_bytes());

        // Encode signature as base58
        Ok(bs58::encode(signature.to_bytes()).into_string())
    }

    /// Place a limit order
    ///
    /// # Arguments
    /// * `symbol` - Trading symbol (e.g., "SOL", "BTC")
    /// * `side` - Order side (Buy or Sell)
    /// * `size` - Order size
    /// * `price` - Optional exact price. If None, uses mid_price_offset
    /// * `mid_price_offset_pct` - Offset from mid price in percentage (default 1.0%)
    /// * `current_bid` - Current best bid price (required if price is None)
    /// * `current_ask` - Current best ask price (required if price is None)
    pub async fn place_limit_order(
        &self,
        symbol: &str,
        side: OrderSide,
        size: f64,
        price: Option<f64>,
        mid_price_offset_pct: f64,
        current_bid: Option<f64>,
        current_ask: Option<f64>,
    ) -> Result<OrderData> {
        // Get market info and clone the strings we need
        let market_info = self.get_market_info().await?;
        let symbol_info = market_info
            .get(symbol)
            .context(format!("Market info not found for {}", symbol))?;

        let tick_size = symbol_info.tick_size.clone();
        let lot_size = symbol_info.lot_size.clone();

        // Calculate price
        let order_price = if let Some(p) = price {
            p
        } else {
            // Calculate from mid price with offset
            let bid = current_bid.context("current_bid required when price is None")?;
            let ask = current_ask.context("current_ask required when price is None")?;
            let mid = (bid + ask) / 2.0;

            match side {
                OrderSide::Buy => mid * (1.0 - mid_price_offset_pct / 100.0),
                OrderSide::Sell => mid * (1.0 + mid_price_offset_pct / 100.0),
            }
        };

        // Round to tick and lot size
        let rounded_price = self.round_to_tick_size(order_price, tick_size.clone())?;
        let rounded_size = self.round_to_lot_size(size, lot_size.clone())?;

        info!(
            "[PACIFICA] Placing {} order: {} {} @ ${} (tick: {}, lot: {})",
            match side { OrderSide::Buy => "BUY", OrderSide::Sell => "SELL" },
            rounded_size,
            symbol,
            rounded_price,
            tick_size,
            lot_size
        );

        // Generate client order ID
        let client_order_id = Uuid::new_v4().to_string();

        // Build signature
        let timestamp = chrono::Utc::now().timestamp_millis();
        let expiry_window = 5000; // 5 seconds

        let header = json!({
            "type": "create_order",
            "timestamp": timestamp,
            "expiry_window": expiry_window
        });

        let payload = json!({
            "symbol": symbol,
            "price": rounded_price.to_string(),
            "amount": rounded_size.to_string(),
            "side": side.as_str(),
            "tif": "ALO",  // Add Liquidity Only (post-only)
            "reduce_only": false,
            "client_order_id": client_order_id
        });

        let signature = self.sign_message(header, payload.clone())?;

        // Build request
        let request_body = serde_json::json!({
            "account": self.credentials.account,
            "signature": signature,
            "timestamp": timestamp,
            "expiry_window": expiry_window,
            "symbol": symbol,
            "price": rounded_price.to_string(),
            "amount": rounded_size.to_string(),
            "side": side.as_str(),
            "tif": "ALO",
            "reduce_only": false,
            "client_order_id": client_order_id,
            "agent_wallet": self.credentials.agent_wallet
        });

        debug!("[PACIFICA] Order request: {}", serde_json::to_string_pretty(&request_body)?);

        // Send request
        let url = format!("{}/api/v1/orders/create", self.rest_url);
        let response = self.client
            .post(&url)
            .json(&request_body)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            anyhow::bail!("Order placement failed: {}", error_text);
        }

        let order_response: OrderResponse = response.json().await?;

        let order_data = order_response.data
            .context("No order data in response")?;

        let order_id = order_data.order_id
            .or(order_data.i)
            .context("No order ID in response")?;

        info!(
            "[PACIFICA] Order placed successfully: ID={}, ClientID={}",
            order_id,
            client_order_id
        );

        Ok(OrderData {
            order_id: Some(order_id),
            i: Some(order_id),
            client_order_id: Some(client_order_id),
            symbol: Some(symbol.to_string()),
        })
    }

    /// Place a market order
    pub async fn place_market_order(
        &self,
        symbol: &str,
        side: OrderSide,
        size: f64,
        slippage_percent: f64,
        reduce_only: bool,
    ) -> Result<OrderData> {
        // Get market info for lot size rounding
        let market_info = self.get_market_info().await?;
        let symbol_info = market_info
            .get(symbol)
            .context(format!("Market info not found for {}", symbol))?;

        let lot_size = symbol_info.lot_size.clone();
        let rounded_size = self.round_to_lot_size(size, lot_size.clone())?;

        info!(
            "[PACIFICA] Placing MARKET {} order: {} {} (lot: {}, slippage: {}%, reduce_only: {})",
            match side { OrderSide::Buy => "BUY", OrderSide::Sell => "SELL" },
            rounded_size,
            symbol,
            lot_size,
            slippage_percent,
            reduce_only
        );

        let client_order_id = Uuid::new_v4().to_string();
        let timestamp = chrono::Utc::now().timestamp_millis();
        let expiry_window = 5000;

        let header = json!({
            "type": "create_market_order",
            "timestamp": timestamp,
            "expiry_window": expiry_window
        });

        let payload = json!({
            "symbol": symbol,
            "amount": rounded_size.to_string(),
            "side": side.as_str(),
            "slippage_percent": slippage_percent.to_string(),
            "reduce_only": reduce_only,
            "client_order_id": client_order_id
        });

        let signature = self.sign_message(header, payload.clone())?;

        let request_body = serde_json::json!({
            "account": self.credentials.account,
            "signature": signature,
            "timestamp": timestamp,
            "expiry_window": expiry_window,
            "symbol": symbol,
            "amount": rounded_size.to_string(),
            "side": side.as_str(),
            "slippage_percent": slippage_percent.to_string(),
            "reduce_only": reduce_only,
            "client_order_id": client_order_id,
            "agent_wallet": self.credentials.agent_wallet
        });

        debug!("[PACIFICA] Market Order request: {}", serde_json::to_string_pretty(&request_body)?);

        let url = format!("{}/api/v1/orders/create_market", self.rest_url);
        let response = self.client
            .post(&url)
            .json(&request_body)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            anyhow::bail!("Market order placement failed: {}", error_text);
        }

        let order_response: OrderResponse = response.json().await?;
        
        let order_data = order_response.data.context("No order data in response")?;
        let order_id = order_data.order_id.or(order_data.i).context("No order ID in response")?;

        info!("[PACIFICA] Market Order placed: ID={}", order_id);

        Ok(OrderData {
            order_id: Some(order_id),
            i: Some(order_id),
            client_order_id: Some(client_order_id),
            symbol: Some(symbol.to_string()),
        })
    }

    /// Cancel an order by client order ID
    pub async fn cancel_order(
        &self,
        symbol: &str,
        client_order_id: &str,
    ) -> Result<()> {
        info!("[PACIFICA] Cancelling order: {} (ClientID: {})", symbol, client_order_id);

        // Build signature
        let timestamp = chrono::Utc::now().timestamp_millis();
        let expiry_window = 5000;

        let header = json!({
            "type": "cancel_order",
            "timestamp": timestamp,
            "expiry_window": expiry_window
        });

        let payload = json!({
            "symbol": symbol,
            "client_order_id": client_order_id
        });

        let signature = self.sign_message(header, payload.clone())?;

        // Build request
        let request_body = json!({
            "account": self.credentials.account,
            "signature": signature,
            "timestamp": timestamp,
            "expiry_window": expiry_window,
            "symbol": symbol,
            "client_order_id": client_order_id,
            "agent_wallet": self.credentials.agent_wallet
        });

        // Send request
        let url = format!("{}/api/v1/orders/cancel", self.rest_url);
        let response = self.client
            .post(&url)
            .json(&request_body)
            .send()
            .await?;

        if !response.status().is_success() {
            let error_text = response.text().await?;
            anyhow::bail!("Order cancellation failed: {}", error_text);
        }

        info!("[PACIFICA] Order cancelled successfully: {}", client_order_id);

        Ok(())
    }

    /// Cancel all orders for a specific symbol or all symbols
    ///
    /// # Arguments
    /// * `all_symbols` - If true, cancels orders for all symbols. If false, cancels only for the specified symbol
    /// * `symbol` - Trading symbol (required if all_symbols is false)
    /// * `exclude_reduce_only` - If true, excludes reduce-only orders from cancellation
    pub async fn cancel_all_orders(
        &self,
        all_symbols: bool,
        symbol: Option<&str>,
        exclude_reduce_only: bool,
    ) -> Result<u32> {
        if !all_symbols && symbol.is_none() {
            anyhow::bail!("symbol is required when all_symbols is false");
        }

        info!(
            "[PACIFICA] Cancelling all orders (all_symbols: {}, symbol: {:?}, exclude_reduce_only: {})",
            all_symbols,
            symbol,
            exclude_reduce_only
        );

        // Build signature
        let timestamp = chrono::Utc::now().timestamp_millis();
        let expiry_window = 5000;

        let header = json!({
            "type": "cancel_all_orders",
            "timestamp": timestamp,
            "expiry_window": expiry_window
        });

        let mut payload = json!({
            "all_symbols": all_symbols,
            "exclude_reduce_only": exclude_reduce_only
        });

        // Add symbol if provided
        if let Some(sym) = symbol {
            payload["symbol"] = json!(sym);
        }

        let signature = self.sign_message(header, payload.clone())?;

        // Build request
        let mut request_body = json!({
            "account": self.credentials.account,
            "signature": signature,
            "timestamp": timestamp,
            "expiry_window": expiry_window,
            "all_symbols": all_symbols,
            "exclude_reduce_only": exclude_reduce_only,
            "agent_wallet": self.credentials.agent_wallet
        });

        // Add symbol to request body if provided
        if let Some(sym) = symbol {
            request_body["symbol"] = json!(sym);
        }

        // Send request
        let url = format!("{}/api/v1/orders/cancel_all", self.rest_url);
        let response = self.client
            .post(&url)
            .json(&request_body)
            .send()
            .await?;

        // Get response text for debugging
        let response_text = response.text().await?;

        // Try to parse the response
        #[derive(serde::Deserialize, Debug)]
        struct CancelAllData {
            #[serde(default)]
            cancelled_count: Option<u32>,
        }

        #[derive(serde::Deserialize, Debug)]
        struct CancelAllResponse {
            success: bool,
            data: Option<CancelAllData>,
            error: Option<String>,
        }

        let cancel_response: CancelAllResponse = serde_json::from_str(&response_text)
            .with_context(|| format!("Failed to parse response: {}", response_text))?;

        if !cancel_response.success {
            let error_msg = cancel_response.error.unwrap_or_else(|| "Unknown error".to_string());
            anyhow::bail!("Cancel all orders failed: {}", error_msg);
        }

        let cancelled_count = cancel_response
            .data
            .and_then(|d| d.cancelled_count)
            .unwrap_or(0);

        info!(
            "[PACIFICA] Successfully cancelled {} order(s)",
            cancelled_count
        );

        Ok(cancelled_count)
    }

    /// Get trade history for the account
    ///
    /// # Arguments
    /// * `symbol` - Optional symbol to filter by (e.g., "ENA")
    /// * `limit` - Optional maximum number of records to return
    /// * `start_time` - Optional start time in milliseconds
    /// * `end_time` - Optional end time in milliseconds
    ///
    /// # Returns
    /// Vector of trade history items
    pub async fn get_trade_history(
        &self,
        symbol: Option<&str>,
        limit: Option<u32>,
        start_time: Option<u64>,
        end_time: Option<u64>,
    ) -> Result<Vec<TradeHistoryItem>> {
        let mut url = format!("{}/api/v1/positions/history?account={}",
            self.rest_url,
            self.credentials.account
        );

        if let Some(sym) = symbol {
            url.push_str(&format!("&symbol={}", sym));
        }

        if let Some(lim) = limit {
            url.push_str(&format!("&limit={}", lim));
        }

        if let Some(start) = start_time {
            url.push_str(&format!("&start_time={}", start));
        }

        if let Some(end) = end_time {
            url.push_str(&format!("&end_time={}", end));
        }

        info!("[PACIFICA] Fetching trade history from {}", url);

        let response = self.client
            .get(&url)
            .send()
            .await
            .context("Failed to fetch trade history")?;

        let response_text = response.text().await?;

        // Log the raw JSON to see all available fields
        if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(&response_text) {
            if let Some(data) = json_value.get("data").and_then(|d| d.as_array()) {
                if !data.is_empty() {
                    info!("[PACIFICA] Sample trade history item (raw JSON): {}", serde_json::to_string_pretty(&data[0]).unwrap_or_default());
                }
            }
        }

        let history_response: TradeHistoryResponse = serde_json::from_str(&response_text)
            .with_context(|| format!("Failed to parse trade history response: {}", response_text))?;

        if !history_response.success {
            let error_msg = history_response.error.unwrap_or_else(|| "Unknown error".to_string());
            anyhow::bail!("Get trade history failed: {}", error_msg);
        }

        Ok(history_response.data.unwrap_or_default())
    }

    /// Get open orders for the account
    ///
    /// # Returns
    /// Vector of open orders
    pub async fn get_open_orders(&self) -> Result<Vec<OpenOrderItem>> {
        let url = format!("{}/api/v1/orders?account={}",
            self.rest_url,
            self.credentials.account
        );

        debug!("[PACIFICA] Fetching open orders from {}", url);

        let response = self.client
            .get(&url)
            .send()
            .await
            .context("Failed to fetch open orders")?;

        // Check for rate limiting
        let status = response.status();
        if status == reqwest::StatusCode::TOO_MANY_REQUESTS {
            anyhow::bail!("Rate limit exceeded (429)");
        }

        let response_text = response.text().await?;

        let orders_response: OpenOrdersResponse = serde_json::from_str(&response_text)
            .with_context(|| format!("Failed to parse open orders response: {}", response_text))?;

        if !orders_response.success {
            let error_msg = orders_response.error.unwrap_or_else(|| "Unknown error".to_string());

            // Check for rate limit error messages
            if error_msg.to_lowercase().contains("rate limit") || error_msg.to_lowercase().contains("too many requests") {
                anyhow::bail!("Rate limit exceeded: {}", error_msg);
            }

            anyhow::bail!("Get open orders failed: {}", error_msg);
        }

        Ok(orders_response.data.unwrap_or_default())
    }

    /// Get current positions for the account
    ///
    /// # Returns
    /// Vector of position items
    pub async fn get_positions(&self) -> Result<Vec<PositionItem>> {
        let url = format!("{}/api/v1/positions?account={}",
            self.rest_url,
            self.credentials.account
        );

        debug!("[PACIFICA] Fetching positions from {}", url);

        let response = self.client
            .get(&url)
            .header("Accept", "*/*")
            .send()
            .await
            .context("Failed to fetch positions")?;

        // Check for rate limiting
        let status = response.status();
        if status == reqwest::StatusCode::TOO_MANY_REQUESTS {
            anyhow::bail!("Rate limit exceeded (429)");
        }

        if !status.is_success() {
            let body = response.text().await.unwrap_or_default();
            anyhow::bail!("Get positions request failed: {} - {}", status, body);
        }

        let response_text = response.text().await?;

        let position_response: PositionResponse = serde_json::from_str(&response_text)
            .with_context(|| format!("Failed to parse positions response: {}", response_text))?;

        if !position_response.success {
            let error_msg = position_response.error.unwrap_or_else(|| "Unknown error".to_string());

            // Check for rate limit error messages
            if error_msg.to_lowercase().contains("rate limit") || error_msg.to_lowercase().contains("too many requests") {
                anyhow::bail!("Rate limit exceeded: {}", error_msg);
            }

            anyhow::bail!("Get positions failed: {}", error_msg);
        }

        Ok(position_response.data.unwrap_or_default())
    }
}

/// Canonicalize JSON by sorting keys alphabetically
/// This matches Python's json.dumps(obj, separators=(",", ":"))
pub fn canonicalize_json(value: &serde_json::Value) -> String {
    match value {
        serde_json::Value::Null => "null".to_string(),
        serde_json::Value::Bool(b) => b.to_string(),
        serde_json::Value::Number(n) => n.to_string(),
        serde_json::Value::String(s) => {
            // Use serde_json to properly escape the string
            // This matches Python's json.dumps() string escaping
            serde_json::to_string(s).unwrap()
        }
        serde_json::Value::Array(arr) => {
            let items: Vec<String> = arr.iter().map(canonicalize_json).collect();
            format!("[{}]", items.join(","))
        }
        serde_json::Value::Object(map) => {
            let mut keys: Vec<&String> = map.keys().collect();
            keys.sort();

            let pairs: Vec<String> = keys
                .iter()
                .map(|k| {
                    // Use serde_json to properly escape the key
                    let escaped_key = serde_json::to_string(k).unwrap();
                    format!("{}:{}", escaped_key, canonicalize_json(&map[*k]))
                })
                .collect();

            format!("{{{}}}", pairs.join(","))
        }
    }
}


================================================================================
FILE: src\connector\pacifica\types.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\pacifica\types.rs
================================================================================

use serde::{Deserialize, Serialize};

/// Websocket subscription message
#[derive(Debug, Serialize)]
pub struct SubscribeMessage {
    pub method: String,
    pub params: SubscribeParams,
}

/// Subscription parameters for orderbook
#[derive(Debug, Serialize)]
pub struct SubscribeParams {
    pub source: String,
    pub symbol: String,
    pub agg_level: u32,
}

/// Unsubscription message
#[derive(Debug, Serialize)]
pub struct UnsubscribeMessage {
    pub method: String,
    pub params: SubscribeParams,
}

/// Ping message for keepalive
#[derive(Debug, Serialize)]
pub struct PingMessage {
    pub method: String,
}

/// Generic websocket response
#[derive(Debug, Deserialize)]
pub struct WebSocketResponse {
    pub channel: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub data: Option<serde_json::Value>,
}

/// Orderbook stream response
#[derive(Debug, Deserialize)]
pub struct OrderbookResponse {
    pub channel: String,
    pub data: OrderbookData,
}

/// Orderbook data structure
#[derive(Debug, Clone, Deserialize)]
pub struct OrderbookData {
    #[serde(rename = "l")]
    pub levels: Vec<Vec<BookLevel>>, // [bids, asks]
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "t")]
    pub timestamp: u64,
}

/// Book level with aggregated orders
#[derive(Debug, Clone, Deserialize)]
pub struct BookLevel {
    #[serde(rename = "a")]
    pub amount: String, // Total amount in aggregation level
    #[serde(rename = "n")]
    pub num_orders: u32, // Number of orders in aggregation level
    #[serde(rename = "p")]
    pub price: String, // Price (highest for bids, lowest for asks)
}

/// Top of book data (best bid and ask)
#[derive(Debug, Clone)]
pub struct TopOfBook {
    pub symbol: String,
    pub best_bid: Option<BookLevel>,
    pub best_ask: Option<BookLevel>,
    pub timestamp: u64,
}

impl OrderbookData {
    /// Extract the top of book (best bid and ask)
    pub fn get_top_of_book(&self) -> TopOfBook {
        let best_bid = self.levels.get(0)
            .and_then(|bids| bids.first())
            .cloned();

        let best_ask = self.levels.get(1)
            .and_then(|asks| asks.first())
            .cloned();

        TopOfBook {
            symbol: self.symbol.clone(),
            best_bid,
            best_ask,
            timestamp: self.timestamp,
        }
    }
}

impl SubscribeMessage {
    pub fn new(symbol: String, agg_level: u32) -> Self {
        Self {
            method: "subscribe".to_string(),
            params: SubscribeParams {
                source: "book".to_string(),
                symbol,
                agg_level,
            },
        }
    }
}

impl UnsubscribeMessage {
    pub fn new(symbol: String, agg_level: u32) -> Self {
        Self {
            method: "unsubscribe".to_string(),
            params: SubscribeParams {
                source: "book".to_string(),
                symbol,
                agg_level,
            },
        }
    }
}

impl PingMessage {
    pub fn new() -> Self {
        Self {
            method: "ping".to_string(),
        }
    }
}

impl Default for PingMessage {
    fn default() -> Self {
        Self::new()
    }
}

/// Account order updates subscription parameters
#[derive(Debug, Serialize)]
pub struct AccountOrderUpdatesParams {
    pub source: String,
    pub account: String,
}

/// Account order updates subscription message
#[derive(Debug, Serialize)]
pub struct AccountOrderUpdatesSubscribe {
    pub method: String,
    pub params: AccountOrderUpdatesParams,
}

impl AccountOrderUpdatesSubscribe {
    pub fn new(account: String) -> Self {
        Self {
            method: "subscribe".to_string(),
            params: AccountOrderUpdatesParams {
                source: "account_order_updates".to_string(),
                account,
            },
        }
    }
}

/// Order event type
#[derive(Debug, Clone, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum OrderEvent {
    Make,
    StopCreated,
    FulfillMarket,
    FulfillLimit,
    Adjust,
    StopParentOrderFilled,
    StopTriggered,
    StopUpgrade,
    Cancel,
    ForceCancel,
    Expired,
    PostOnlyRejected,
    SelfTradePrevented,
}

/// Order status
#[derive(Debug, Clone, Deserialize, PartialEq)]
#[serde(rename_all = "snake_case")]
pub enum OrderStatus {
    Open,
    PartiallyFilled,
    Filled,
    Cancelled,
    Rejected,
}

/// Order update data
#[derive(Debug, Clone, Deserialize)]
pub struct OrderUpdate {
    #[serde(rename = "i")]
    pub order_id: u64,
    #[serde(rename = "I")]
    pub client_order_id: Option<String>,
    #[serde(rename = "u")]
    pub account: String,
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "d")]
    pub side: String, // "bid" or "ask"
    #[serde(rename = "p")]
    pub avg_filled_price: String,
    #[serde(rename = "ip")]
    pub initial_price: String,
    #[serde(rename = "a")]
    pub original_amount: String,
    #[serde(rename = "f")]
    pub filled_amount: String,
    #[serde(rename = "oe")]
    pub order_event: OrderEvent,
    #[serde(rename = "os")]
    pub order_status: OrderStatus,
    #[serde(rename = "ot")]
    pub order_type: String, // "limit" or "market"
    #[serde(rename = "sp")]
    pub stop_price: Option<String>,
    #[serde(rename = "si")]
    pub stop_parent_order_id: Option<String>,
    #[serde(rename = "r")]
    pub reduce_only: bool,
    #[serde(rename = "ut")]
    pub updated_at: u64, // milliseconds
    #[serde(rename = "ct")]
    pub created_at: u64, // milliseconds
}

/// Account order updates response
#[derive(Debug, Deserialize)]
pub struct AccountOrderUpdatesResponse {
    pub channel: String,
    pub data: Vec<OrderUpdate>,
}

/// Fill information extracted from order update
#[derive(Debug, Clone)]
pub enum FillEvent {
    PartialFill {
        order_id: u64,
        client_order_id: Option<String>,
        symbol: String,
        side: String,
        filled_amount: String,
        original_amount: String,
        avg_price: String,
        timestamp: u64,
    },
    FullFill {
        order_id: u64,
        client_order_id: Option<String>,
        symbol: String,
        side: String,
        filled_amount: String,
        avg_price: String,
        timestamp: u64,
    },
    Cancelled {
        order_id: u64,
        client_order_id: Option<String>,
        symbol: String,
        side: String,
        filled_amount: String,
        original_amount: String,
        reason: String,
        timestamp: u64,
    },
    /// Fill detected from position change (redundancy layer)
    PositionFill {
        symbol: String,
        side: String,              // "buy" or "sell" (derived from position delta)
        filled_amount: String,     // Absolute value of position delta
        avg_price: String,         // Entry price from position
        timestamp: u64,
        position_delta: String,    // Signed position change for diagnostics
        prev_position: String,     // Previous position size
        new_position: String,      // New position size
        cross_validated: bool,     // Whether fill was also detected by order updates
    },
}

impl OrderUpdate {
    /// Convert order update to fill event if applicable
    pub fn to_fill_event(&self) -> Option<FillEvent> {
        match self.order_status {
            OrderStatus::PartiallyFilled => Some(FillEvent::PartialFill {
                order_id: self.order_id,
                client_order_id: self.client_order_id.clone(),
                symbol: self.symbol.clone(),
                side: self.side.clone(),
                filled_amount: self.filled_amount.clone(),
                original_amount: self.original_amount.clone(),
                avg_price: self.avg_filled_price.clone(),
                timestamp: self.updated_at,
            }),
            OrderStatus::Filled => Some(FillEvent::FullFill {
                order_id: self.order_id,
                client_order_id: self.client_order_id.clone(),
                symbol: self.symbol.clone(),
                side: self.side.clone(),
                filled_amount: self.filled_amount.clone(),
                avg_price: self.avg_filled_price.clone(),
                timestamp: self.updated_at,
            }),
            OrderStatus::Cancelled => {
                let reason = match self.order_event {
                    OrderEvent::Cancel => "user_cancelled",
                    OrderEvent::ForceCancel => "force_cancelled",
                    OrderEvent::Expired => "expired",
                    OrderEvent::PostOnlyRejected => "post_only_rejected",
                    OrderEvent::SelfTradePrevented => "self_trade_prevented",
                    _ => "unknown",
                };
                Some(FillEvent::Cancelled {
                    order_id: self.order_id,
                    client_order_id: self.client_order_id.clone(),
                    symbol: self.symbol.clone(),
                    side: self.side.clone(),
                    filled_amount: self.filled_amount.clone(),
                    original_amount: self.original_amount.clone(),
                    reason: reason.to_string(),
                    timestamp: self.updated_at,
                })
            },
            _ => None,
        }
    }
}

// ═══════════════════════════════════════════════════
// WebSocket Trading Operations
// ═══════════════════════════════════════════════════

/// WebSocket cancel all orders request
#[derive(Debug, Serialize)]
pub struct WsCancelAllOrdersRequest {
    /// Request ID (UUID)
    pub id: String,
    /// Request parameters
    pub params: WsCancelAllOrdersParams,
}

/// Parameters for cancel all orders
#[derive(Debug, Serialize)]
pub struct WsCancelAllOrdersParams {
    pub cancel_all_orders: WsCancelAllOrdersData,
}

/// Cancel all orders data payload
#[derive(Debug, Serialize)]
pub struct WsCancelAllOrdersData {
    /// User's wallet address
    pub account: String,
    /// Agent wallet address (optional)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub agent_wallet: Option<String>,
    /// Cryptographic signature
    pub signature: String,
    /// Current timestamp in milliseconds
    pub timestamp: i64,
    /// Signature expiry in milliseconds
    pub expiry_window: i64,
    /// Whether to cancel orders for all symbols
    pub all_symbols: bool,
    /// Whether to exclude reduce-only orders
    pub exclude_reduce_only: bool,
    /// Trading pair symbol (required if all_symbols is false)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub symbol: Option<String>,
}

/// WebSocket cancel all orders response
#[derive(Debug, Deserialize)]
pub struct WsCancelAllOrdersResponse {
    /// Status code
    pub code: u16,
    /// Response data
    pub data: WsCancelAllOrdersResponseData,
    /// Request ID (matches request)
    pub id: String,
    /// Response timestamp
    pub t: i64,
    /// Response type
    #[serde(rename = "type")]
    pub response_type: String,
}

/// Cancel all orders response data
#[derive(Debug, Deserialize)]
pub struct WsCancelAllOrdersResponseData {
    /// Number of orders successfully cancelled
    pub cancelled_count: u32,
}

/// Generic WebSocket trading error response
#[derive(Debug, Deserialize)]
pub struct WsErrorResponse {
    pub code: u16,
    pub error: Option<String>,
    pub id: String,
    pub t: i64,
    #[serde(rename = "type")]
    pub response_type: String,
}

// ═══════════════════════════════════════════════════
// Account Positions WebSocket
// ═══════════════════════════════════════════════════

/// Account positions subscription parameters
#[derive(Debug, Serialize)]
pub struct AccountPositionsParams {
    pub source: String,
    pub account: String,
}

/// Account positions subscription message
#[derive(Debug, Serialize)]
pub struct AccountPositionsSubscribe {
    pub method: String,
    pub params: AccountPositionsParams,
}

impl AccountPositionsSubscribe {
    pub fn new(account: String) -> Self {
        Self {
            method: "subscribe".to_string(),
            params: AccountPositionsParams {
                source: "account_positions".to_string(),
                account,
            },
        }
    }
}

/// Position data from WebSocket stream
#[derive(Debug, Clone, Deserialize)]
pub struct PositionData {
    #[serde(rename = "s")]
    pub symbol: String,
    #[serde(rename = "a")]
    pub amount: String,         // Position size (always positive)
    #[serde(rename = "p")]
    pub entry_price: String,    // Average entry price
    #[serde(rename = "t")]
    pub timestamp: u64,         // Timestamp in milliseconds
    #[serde(rename = "d")]
    pub side: String,           // "bid" (long) or "ask" (short)
    #[serde(rename = "m")]
    pub margin: String,         // Position margin
    #[serde(rename = "f")]
    pub funding: String,        // Funding fee
    #[serde(rename = "i")]
    pub isolated: bool,         // Is isolated position
}

/// Account positions response
#[derive(Debug, Deserialize)]
pub struct AccountPositionsResponse {
    pub channel: String,
    pub data: Vec<PositionData>,
}


================================================================================
FILE: src\connector\pacifica\ws_trading.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\connector\pacifica\ws_trading.rs
================================================================================

use anyhow::{Context, Result};
use ed25519_dalek::{Signer, SigningKey};
use futures_util::{SinkExt, StreamExt};
use serde_json::json;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use tracing::{debug, info};
use uuid::Uuid;

use super::types::{
    WsCancelAllOrdersData, WsCancelAllOrdersParams, WsCancelAllOrdersRequest,
    WsCancelAllOrdersResponse, WsErrorResponse,
};
use super::trading::canonicalize_json;
use crate::connector::pacifica::PacificaCredentials;

/// WebSocket-based trading client for Pacifica
///
/// This is an alternative to REST API trading operations with lower latency
/// and no rate limits. Uses the same WebSocket connection for multiple operations.
pub struct PacificaWsTrading {
    credentials: PacificaCredentials,
    ws_url: String,
}

impl PacificaWsTrading {
    /// Create a new WebSocket trading client
    ///
    /// # Arguments
    /// * `credentials` - Pacifica credentials
    /// * `is_testnet` - Whether to use testnet (false = mainnet)
    pub fn new(credentials: PacificaCredentials, is_testnet: bool) -> Self {
        let ws_url = if is_testnet {
            "wss://test-ws.pacifica.fi/ws".to_string()
        } else {
            "wss://ws.pacifica.fi/ws".to_string()
        };

        Self {
            credentials,
            ws_url,
        }
    }

    /// Cancel all orders via WebSocket
    ///
    /// # Arguments
    /// * `all_symbols` - Whether to cancel orders for all symbols
    /// * `symbol` - Symbol to cancel orders for (required if all_symbols is false)
    /// * `exclude_reduce_only` - Whether to exclude reduce-only orders
    ///
    /// # Returns
    /// Number of orders cancelled
    pub async fn cancel_all_orders_ws(
        &self,
        all_symbols: bool,
        symbol: Option<&str>,
        exclude_reduce_only: bool,
    ) -> Result<u32> {
        if !all_symbols && symbol.is_none() {
            anyhow::bail!("symbol is required when all_symbols is false");
        }

        info!(
            "[PACIFICA_WS] Cancelling all orders via WebSocket (all_symbols: {}, symbol: {:?}, exclude_reduce_only: {})",
            all_symbols,
            symbol,
            exclude_reduce_only
        );

        // Connect to WebSocket
        let (ws_stream, _) = connect_async(&self.ws_url)
            .await
            .context("Failed to connect to Pacifica WebSocket")?;

        debug!("[PACIFICA_WS] Connected to {}", self.ws_url);

        let (mut write, mut read) = ws_stream.split();

        // Generate request ID
        let request_id = Uuid::new_v4().to_string();

        // Build signature
        let timestamp = chrono::Utc::now().timestamp_millis();
        let expiry_window = 5000;

        let header = json!({
            "type": "cancel_all_orders",
            "timestamp": timestamp,
            "expiry_window": expiry_window
        });

        let mut payload = json!({
            "all_symbols": all_symbols,
            "exclude_reduce_only": exclude_reduce_only
        });

        // Add symbol if provided
        if let Some(sym) = symbol {
            payload["symbol"] = json!(sym);
        }

        let signature = self.sign_message(header, payload.clone())?;

        // Build cancel all orders request
        let cancel_request = WsCancelAllOrdersRequest {
            id: request_id.clone(),
            params: WsCancelAllOrdersParams {
                cancel_all_orders: WsCancelAllOrdersData {
                    account: self.credentials.account.clone(),
                    agent_wallet: Some(self.credentials.agent_wallet.clone()),
                    signature,
                    timestamp,
                    expiry_window,
                    all_symbols,
                    exclude_reduce_only,
                    symbol: symbol.map(|s| s.to_string()),
                },
            },
        };

        // Serialize and send request
        let request_json = serde_json::to_string(&cancel_request)?;
        debug!("[PACIFICA_WS] Sending request: {}", request_json);
        write.send(Message::Text(request_json)).await?;

        // Wait for response with matching ID
        while let Some(msg) = read.next().await {
            match msg {
                Ok(Message::Text(text)) => {
                    debug!("[PACIFICA_WS] Received: {}", text);

                    // Try to parse as success response
                    if let Ok(response) = serde_json::from_str::<WsCancelAllOrdersResponse>(&text)
                    {
                        if response.id == request_id {
                            if response.code == 200 {
                                info!(
                                    "[PACIFICA_WS] Successfully cancelled {} order(s)",
                                    response.data.cancelled_count
                                );
                                return Ok(response.data.cancelled_count);
                            } else {
                                anyhow::bail!(
                                    "Cancel all orders failed with code: {}",
                                    response.code
                                );
                            }
                        }
                    }

                    // Try to parse as error response
                    if let Ok(error_response) = serde_json::from_str::<WsErrorResponse>(&text) {
                        if error_response.id == request_id {
                            let error_msg = error_response
                                .error
                                .unwrap_or_else(|| format!("Unknown error (code: {})", error_response.code));
                            anyhow::bail!("WebSocket error: {}", error_msg);
                        }
                    }

                    // Ignore messages with different IDs (might be from other subscriptions)
                }
                Ok(Message::Close(_)) => {
                    anyhow::bail!("WebSocket closed before receiving response");
                }
                Err(e) => {
                    anyhow::bail!("WebSocket error: {}", e);
                }
                _ => {}
            }
        }

        anyhow::bail!("WebSocket stream ended before receiving response")
    }

    /// Sign a message using Ed25519
    ///
    /// This is identical to the REST API signature method
    fn sign_message(
        &self,
        header: serde_json::Value,
        payload: serde_json::Value,
    ) -> Result<String> {
        // Construct message: {... header, data: payload}
        let mut message = serde_json::json!({});
        if let serde_json::Value::Object(ref mut map) = message {
            if let serde_json::Value::Object(header_map) = header {
                for (k, v) in header_map {
                    map.insert(k, v);
                }
            }
            map.insert("data".to_string(), payload);
        }

        // Canonicalize JSON (sort keys alphabetically)
        let canonical = canonicalize_json(&message);

        // Decode private key from base58
        let private_key_bytes = bs58::decode(&self.credentials.private_key)
            .into_vec()
            .context("Failed to decode private key")?;

        // Solana/Pacifica private keys are 64 bytes (32 bytes seed + 32 bytes public key)
        // Ed25519 SigningKey needs only the first 32 bytes (the seed)
        if private_key_bytes.len() != 64 {
            anyhow::bail!(
                "Invalid private key length: expected 64 bytes, got {}",
                private_key_bytes.len()
            );
        }

        let seed_bytes: [u8; 32] = private_key_bytes[0..32]
            .try_into()
            .context("Failed to extract 32-byte seed")?;

        // Create signing key and sign
        let signing_key = SigningKey::from_bytes(&seed_bytes);
        let signature = signing_key.sign(canonical.as_bytes());

        // Encode signature as base58
        Ok(bs58::encode(signature.to_bytes()).into_string())
    }
}


================================================================================
FILE: src\csv_logger.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\csv_logger.rs
================================================================================

/// CSV trade history logging module
///
/// This module provides functionality to log completed trades to a CSV file
/// for historical tracking and analysis.

use anyhow::{Context, Result};
use chrono::{DateTime, Utc};
use csv::Writer;
use serde::Serialize;
use std::fs::OpenOptions;
use std::path::Path;

use crate::strategy::OrderSide;

/// Trade record for CSV logging
#[derive(Debug, Serialize)]
pub struct TradeRecord {
    /// Timestamp of the trade (ISO 8601 format)
    pub timestamp: String,
    /// End-to-end latency from fill detection to hedge execution (milliseconds)
    pub latency_ms: f64,
    /// Trading symbol (e.g., "ENA", "BTC")
    pub symbol: String,
    /// Direction on Pacifica (Buy or Sell)
    pub pacifica_side: String,
    /// Direction on Hyperliquid (opposite of Pacifica)
    pub hyperliquid_side: String,
    /// Pacifica fill price
    pub pacifica_price: f64,
    /// Pacifica fill size
    pub pacifica_size: f64,
    /// Pacifica notional value (USD)
    pub pacifica_notional: f64,
    /// Pacifica fee paid (USD)
    pub pacifica_fee: f64,
    /// Hyperliquid fill price
    pub hyperliquid_price: f64,
    /// Hyperliquid fill size
    pub hyperliquid_size: f64,
    /// Hyperliquid notional value (USD)
    pub hyperliquid_notional: f64,
    /// Hyperliquid fee paid (USD)
    pub hyperliquid_fee: f64,
    /// Total fees paid (USD)
    pub total_fees: f64,
    /// Expected profit in basis points
    pub expected_profit_bps: f64,
    /// Actual profit in basis points
    pub actual_profit_bps: f64,
    /// Actual profit in USD
    pub actual_profit_usd: f64,
    /// Gross PnL before fees (USD)
    pub gross_pnl: f64,
}

impl TradeRecord {
    /// Create a new trade record
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        timestamp: DateTime<Utc>,
        latency_ms: f64,
        symbol: String,
        pacifica_side: OrderSide,
        pacifica_price: f64,
        pacifica_size: f64,
        pacifica_notional: f64,
        pacifica_fee: f64,
        hyperliquid_price: f64,
        hyperliquid_size: f64,
        hyperliquid_notional: f64,
        hyperliquid_fee: f64,
        expected_profit_bps: f64,
        actual_profit_bps: f64,
        actual_profit_usd: f64,
    ) -> Self {
        let hyperliquid_side = match pacifica_side {
            OrderSide::Buy => "SELL",
            OrderSide::Sell => "BUY",
        };

        let gross_pnl = match pacifica_side {
            OrderSide::Buy => hyperliquid_notional - pacifica_notional,
            OrderSide::Sell => pacifica_notional - hyperliquid_notional,
        };

        let total_fees = pacifica_fee + hyperliquid_fee;

        Self {
            timestamp: timestamp.to_rfc3339(),
            latency_ms,
            symbol,
            pacifica_side: pacifica_side.as_str().to_uppercase(),
            hyperliquid_side: hyperliquid_side.to_string(),
            pacifica_price,
            pacifica_size,
            pacifica_notional,
            pacifica_fee,
            hyperliquid_price,
            hyperliquid_size,
            hyperliquid_notional,
            hyperliquid_fee,
            total_fees,
            expected_profit_bps,
            actual_profit_bps,
            actual_profit_usd,
            gross_pnl,
        }
    }
}

/// Append a trade record to the CSV file
///
/// Creates the file with headers if it doesn't exist.
/// Appends to the file if it already exists.
///
/// # Arguments
/// * `file_path` - Path to the CSV file (e.g., "trades_history.csv")
/// * `record` - Trade record to append
///
/// # Returns
/// Result indicating success or failure
pub fn log_trade(file_path: &str, record: &TradeRecord) -> Result<()> {
    let path = Path::new(file_path);
    let file_exists = path.exists();

    // Open file in append mode (create if doesn't exist)
    let file = OpenOptions::new()
        .write(true)
        .create(true)
        .append(true)
        .open(path)
        .with_context(|| format!("Failed to open CSV file: {}", file_path))?;

    let mut writer = Writer::from_writer(file);

    // Write headers only if file is new
    if !file_exists {
        writer.serialize(record)
            .context("Failed to write CSV headers")?;
    } else {
        // For existing files, don't write headers again
        writer.serialize(record)
            .context("Failed to write CSV record")?;
    }

    writer.flush()
        .context("Failed to flush CSV writer")?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    #[test]
    fn test_trade_record_creation() {
        let record = TradeRecord::new(
            Utc::now(),
            125.5,  // latency_ms
            "ENA".to_string(),
            OrderSide::Buy,
            0.3900,
            50.0,
            19.50,
            0.0029,
            0.3920,
            50.0,
            19.60,
            0.0078,
            10.0,
            8.5,
            0.0021,
        );

        assert_eq!(record.symbol, "ENA");
        assert_eq!(record.pacifica_side, "BUY");
        assert_eq!(record.hyperliquid_side, "SELL");
        assert_eq!(record.pacifica_price, 0.3900);
        assert_eq!(record.total_fees, 0.0107);
        assert_eq!(record.latency_ms, 125.5);
    }

    #[test]
    fn test_csv_logging() {
        let test_file = "test_trades.csv";

        // Clean up any existing test file
        let _ = fs::remove_file(test_file);

        let record = TradeRecord::new(
            Utc::now(),
            89.3,  // latency_ms
            "BTC".to_string(),
            OrderSide::Sell,
            50000.0,
            0.001,
            50.0,
            0.0075,
            49950.0,
            0.001,
            49.95,
            0.02,
            10.0,
            -43.5,
            -0.0775,
        );

        // Log the trade
        let result = log_trade(test_file, &record);
        assert!(result.is_ok());

        // Verify file exists
        assert!(Path::new(test_file).exists());

        // Clean up
        let _ = fs::remove_file(test_file);
    }
}


================================================================================
FILE: src\lib.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\lib.rs
================================================================================

// Library exports for xemm_rust

pub mod app;
pub mod connector;
pub mod config;
pub mod strategy;
pub mod bot;
pub mod trade_fetcher;
pub mod util;
pub mod services;
pub mod csv_logger;

// Re-export commonly used items for convenience
pub use app::XemmBot;
pub use config::Config;


================================================================================
FILE: src\main.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\main.rs
================================================================================

use anyhow::Result;

/// XEMM Bot - Cross-Exchange Market Making Bot
///
/// Single-cycle arbitrage bot that:
/// 1. Evaluates opportunities between Pacifica and Hyperliquid
/// 2. Places limit order on Pacifica
/// 3. Monitors profitability (cancels if profit drops >3 bps)
/// 4. Auto-refreshes orders based on configured interval (default 60 seconds)
/// 5. Hedges on Hyperliquid when filled (WebSocket + REST API detection)
/// 6. Hedges partial fills above $10 notional
/// 7. Exits after successful hedge
///
/// Tasks:
/// 1. Pacifica Orderbook (WebSocket - real-time push)
/// 2. Hyperliquid Orderbook (WebSocket - 99ms request/response)
/// 3. Fill Detection (WebSocket - primary, real-time)
/// 4. Pacifica REST Polling (orderbook fallback, every 2s)
/// 4.5. Hyperliquid REST Polling (orderbook fallback, every 2s)
/// 5. REST API Fill Detection (backup, 500ms polling with rate limit handling)
/// 5.5. Position Monitor (4th layer, ground truth, 500ms polling)
/// 6. Order Monitoring (profit/age checks, every 25ms)
/// 7. Hedge Execution
/// 8. Main Opportunity Loop (every 100ms)
#[tokio::main]
async fn main() -> Result<()> {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| tracing_subscriber::EnvFilter::new("info")),
        )
        .init();

    // Create and initialize bot (all wiring happens in XemmBot::new())
    let bot = xemm_rust::app::XemmBot::new().await?;

    // Run the bot (spawns all services and executes main loop)
    bot.run().await
}


================================================================================
FILE: src\services\fill_detection.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\fill_detection.rs
================================================================================

use std::collections::HashSet;
use std::sync::Arc;
use tokio::sync::{mpsc, RwLock};
use tracing::debug;
use colored::Colorize;
use fast_float::parse;

use crate::bot::{BotState, BotStatus};
use crate::connector::pacifica::{
    FillDetectionClient, FillDetectionConfig, FillEvent, PacificaTrading, PacificaWsTrading,
    PositionBaselineUpdater,
};
use crate::services::HedgeEvent;
use crate::strategy::OrderSide;
use crate::util::cancel::dual_cancel;

// Macro for timestamped colored output
macro_rules! tprintln {
    ($($arg:tt)*) => {{
        println!("{} {}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string().bright_black(),
            format!($($arg)*)
        );
    }};
}

/// WebSocket-based fill detection service (primary fill detection method)
pub struct FillDetectionService {
    pub bot_state: Arc<RwLock<BotState>>,
    pub hedge_tx: mpsc::UnboundedSender<HedgeEvent>,
    pub pacifica_trading: Arc<PacificaTrading>,
    pub pacifica_ws_trading: Arc<PacificaWsTrading>,
    pub fill_config: FillDetectionConfig,
    pub symbol: String,
    pub processed_fills: Arc<parking_lot::Mutex<HashSet<String>>>,
    pub baseline_updater: PositionBaselineUpdater,
    pub atomic_status: Arc<std::sync::atomic::AtomicU8>,
    pub order_snapshot: Arc<crate::services::order_monitor::SharedOrderSnapshot>,
}

impl FillDetectionService {
    pub async fn run(self) {
        tprintln!("{} Starting fill detection client", "[FILL_DETECTION]".magenta().bold());

        let mut fill_client = match FillDetectionClient::new(self.fill_config, false) {
            Ok(client) => client,
            Err(e) => {
                tprintln!("{} {} Failed to create fill detection client: {}",
                    "[FILL_DETECTION]".magenta().bold(),
                    "✗".red().bold(),
                    e
                );
                return;
            }
        };

        // Clone dependencies for the callback closure
        let bot_state = self.bot_state.clone();
        let hedge_tx = self.hedge_tx.clone();
        let pacifica_trading = self.pacifica_trading.clone();
        let pacifica_ws_trading = self.pacifica_ws_trading.clone();
        let symbol = self.symbol.clone();
        let processed_fills = self.processed_fills.clone();
        let baseline_updater = self.baseline_updater.clone();
        let atomic_status = self.atomic_status.clone();
        let order_snapshot = self.order_snapshot.clone();

        fill_client
            .start(move |fill_event| {
                match fill_event {
                    FillEvent::FullFill {
                        symbol: fill_symbol,
                        side,
                        filled_amount,
                        avg_price,
                        client_order_id,
                        ..
                    } => {
                        tprintln!(
                            "{} {} FULL FILL: {} {} {} @ {} (cloid: {})",
                            "[FILL_DETECTION]".magenta().bold(),
                            "✓".green().bold(),
                            side.bright_yellow(),
                            filled_amount.bright_white(),
                            fill_symbol.bright_white().bold(),
                            avg_price.cyan(),
                            client_order_id.as_deref().unwrap_or("None")
                        );

                        // Spawn async task to handle the fill
                        let bot_state_clone = bot_state.clone();
                        let hedge_tx = hedge_tx.clone();
                        let side_str = side.clone();
                        let filled_amount_str = filled_amount.clone();
                        let avg_price_str = avg_price.clone();
                        let cloid = client_order_id.clone();
                        let pac_trading_clone = pacifica_trading.clone();
                        let pac_ws_trading_clone = pacifica_ws_trading.clone();
                        let symbol_clone = symbol.clone();
                        let processed_fills_clone = processed_fills.clone();
                        let baseline_updater_clone = baseline_updater.clone();

                        tokio::spawn(async move {
                            // Check if this is our order
                            let state = bot_state_clone.read().await;
                            let is_our_order = state
                                .active_order
                                .as_ref()
                                .and_then(|o| cloid.as_ref().map(|id| &o.client_order_id == id))
                                .unwrap_or(false);
                            drop(state);

                            if is_our_order {
                                // Check if this fill was already processed (prevent duplicate hedges)
                                let fill_id = cloid.as_ref().map(|id| format!("full_{}", id)).unwrap_or_default();
                                {
                                    let mut processed = processed_fills_clone.lock();
                                    if processed.contains(&fill_id) {
                                        debug!("[FILL_DETECTION] Full fill already processed (duplicate), skipping");
                                        return;
                                    }
                                    processed.insert(fill_id);
                                }

                                // *** CRITICAL: UPDATE STATE FIRST ***
                                // Mark as filled IMMEDIATELY to prevent main loop from placing new orders
                                // State machine provides race condition protection - cancellation can run async
                                let fill_detect_start = std::time::Instant::now();

                                let order_side = match side_str.as_str() {
                                    "buy" | "bid" => OrderSide::Buy,
                                    "sell" | "ask" => OrderSide::Sell,
                                    _ => {
                                        tprintln!("{} {} Unknown side: {}", "[FILL_DETECTION]".magenta().bold(), "✗".red().bold(), side_str);
                                        return;
                                    }
                                };

                                let filled_size: f64 = parse(&filled_amount_str).unwrap_or(0.0);

                                {
                                    let mut state = bot_state_clone.write().await;
                                    state.mark_filled(filled_size, order_side);
                                }

                                tprintln!("{} {} FILL DETECTED - State updated to Filled",
                                    "[FILL_DETECTION]".magenta().bold(),
                                    "✓".green().bold()
                                );

                                // *** PARALLEL EXECUTION: Cancellation + Hedge Trigger ***
                                // State machine (mark_filled) already prevents new orders
                                // Dual cancel runs async while hedge triggers immediately
                                // Pre-hedge cancellation in hedge.rs provides defensive redundancy
                                tprintln!("{} {} Spawning async dual cancellation (REST + WebSocket)...",
                                    "[FILL_DETECTION]".magenta().bold(),
                                    "⚡".yellow().bold()
                                );

                                // Clone for async cancellation task
                                let pac_trading_bg = pac_trading_clone.clone();
                                let pac_ws_trading_bg = pac_ws_trading_clone.clone();
                                let symbol_bg = symbol_clone.clone();

                                // Spawn dual cancel in background (don't await)
                                tokio::spawn(async move {
                                    match dual_cancel(
                                        &pac_trading_bg,
                                        &pac_ws_trading_bg,
                                        &symbol_bg
                                    ).await {
                                        Ok((rest_count, ws_count)) => {
                                            tprintln!("{} {} Background dual cancellation complete (REST: {}, WS: {})",
                                                "[FILL_DETECTION]".magenta().bold(),
                                                "✓✓".green().bold(),
                                                rest_count,
                                                ws_count
                                            );
                                        }
                                        Err(e) => {
                                            tprintln!("{} {} Background dual cancellation failed: {}",
                                                "[FILL_DETECTION]".magenta().bold(),
                                                "✗".red().bold(),
                                                e
                                            );
                                        }
                                    }
                                });

                                // *** CRITICAL: UPDATE POSITION BASELINE ***
                                // This prevents position-based detection from triggering duplicate hedge
                                let avg_px: f64 = parse(&avg_price_str).unwrap_or(0.0);
                                baseline_updater_clone.update_baseline(
                                    &symbol_clone,
                                    &side_str,
                                    filled_size,
                                    avg_px
                                );

                                // *** TRIGGER HEDGE IMMEDIATELY (PARALLEL WITH CANCELLATION) ***
                                let hedge_trigger_latency = fill_detect_start.elapsed();
                                tprintln!("{} {} ⚡ PARALLEL EXECUTION: Hedge triggered in {:.1}ms (cancellation running async)",
                                    format!("[{}]", symbol_clone).bright_white().bold(),
                                    "Order filled".green().bold(),
                                    hedge_trigger_latency.as_secs_f64() * 1000.0
                                );

                                // Trigger hedge immediately (runs in parallel with background cancellation)
                                let _ = hedge_tx.send((order_side, filled_size, avg_px, fill_detect_start));
                            }
                        });
                    }
                    FillEvent::Cancelled { client_order_id, reason, .. } => {
                        // Log at debug level since monitor already logs cancellations
                        debug!(
                            "[FILL_DETECTION] Order cancelled: {} (reason: {})",
                            client_order_id.as_deref().unwrap_or("None"),
                            reason
                        );

                        // Spawn async task to handle the cancellation
                        let bot_state_clone = bot_state.clone();
                        let cloid = client_order_id.clone();
                        let atomic_status_clone = atomic_status.clone();
                        let order_snapshot_clone = order_snapshot.clone();

                        tokio::spawn(async move {
                            let mut state = bot_state_clone.write().await;
                            let is_our_order = state
                                .active_order
                                .as_ref()
                                .and_then(|o| cloid.as_ref().map(|id| &o.client_order_id == id))
                                .unwrap_or(false);

                            if is_our_order {
                                // *** CRITICAL FIX: Only reset to Idle if in OrderPlaced state ***
                                // Prevents race condition where post-fill cancellation confirmations
                                // (from dual-cancel safety mechanism) reset state while hedge executes
                                match &state.status {
                                    BotStatus::OrderPlaced => {
                                        // Normal cancellation (monitor refresh, profit deviation, etc.)
                                        state.clear_active_order();
                                        // Sync atomic status and clear order snapshot
                                        crate::services::order_monitor::sync_atomic_status(&atomic_status_clone, &state.status);
                                        order_snapshot_clone.set(None);
                                        debug!("[BOT] Active order cancelled, returning to Idle");
                                    }
                                    BotStatus::Filled | BotStatus::Hedging | BotStatus::Complete => {
                                        // Post-fill cancellation confirmation (from dual-cancel safety)
                                        // DO NOT reset state - hedge is in progress or complete
                                        debug!(
                                            "[BOT] Cancellation confirmed for order in {:?} state (ignoring, hedge in progress)",
                                            state.status
                                        );
                                    }
                                    BotStatus::Idle => {
                                        // Already idle, no action needed
                                        debug!("[BOT] Cancellation received but state already Idle");
                                    }
                                    BotStatus::Error(_) => {
                                        // Error state, don't change anything
                                        debug!("[BOT] Cancellation received in Error state (ignoring)");
                                    }
                                }
                            }
                        });
                    }
                    FillEvent::PartialFill {
                        symbol: fill_symbol,
                        side,
                        filled_amount,
                        original_amount,
                        avg_price,
                        client_order_id,
                        ..
                    } => {
                        // Calculate notional value of partial fill
                        let filled_size: f64 = parse(&filled_amount).unwrap_or(0.0);
                        let fill_price: f64 = parse(&avg_price).unwrap_or(0.0);
                        let notional_value = filled_size * fill_price;

                        tprintln!(
                            "{} {} PARTIAL FILL: {} {} {} @ {} | Filled: {} / {} | Notional: {}",
                            "[FILL_DETECTION]".magenta().bold(),
                            "⚡".yellow().bold(),
                            side.bright_yellow(),
                            filled_amount.bright_white(),
                            fill_symbol.bright_white().bold(),
                            avg_price.cyan(),
                            filled_amount.bright_white(),
                            original_amount,
                            format!("${:.2}", notional_value).cyan().bold()
                        );

                        // Only hedge if notional value > $10
                        if notional_value > 10.0 {
                            tprintln!(
                                "{} {} Partial fill notional ${:.2} > $10.00 threshold, initiating hedge",
                                "[FILL_DETECTION]".magenta().bold(),
                                "✓".green().bold(),
                                notional_value
                            );

                            // Spawn async task to handle the partial fill (same as full fill)
                            let bot_state_clone = bot_state.clone();
                            let hedge_tx = hedge_tx.clone();
                            let side_str = side.clone();
                            let filled_amount_str = filled_amount.clone();
                            let avg_price_str = avg_price.clone();
                            let cloid = client_order_id.clone();
                            let pac_trading_clone = pacifica_trading.clone();
                            let pac_ws_trading_clone = pacifica_ws_trading.clone();
                            let symbol_clone = symbol.clone();
                            let processed_fills_clone = processed_fills.clone();
                            let baseline_updater_clone = baseline_updater.clone();

                            tokio::spawn(async move {
                                // Check if this is our order
                                let state = bot_state_clone.read().await;
                                let is_our_order = state
                                    .active_order
                                    .as_ref()
                                    .and_then(|o| cloid.as_ref().map(|id| &o.client_order_id == id))
                                    .unwrap_or(false);
                                drop(state);

                                if is_our_order {
                                    // Check if this fill was already processed (prevent duplicate hedges)
                                    let fill_id = cloid.as_ref().map(|id| format!("partial_{}", id)).unwrap_or_default();
                                    {
                                        let mut processed = processed_fills_clone.lock();
                                        if processed.contains(&fill_id) {
                                            debug!("[FILL_DETECTION] Partial fill already processed (duplicate), skipping");
                                            return;
                                        }
                                        processed.insert(fill_id);
                                    }

                                    // *** CRITICAL: UPDATE STATE FIRST ***
                                    // State machine provides race condition protection - cancellation can run async
                                    let fill_detect_start = std::time::Instant::now();

                                    let order_side = match side_str.as_str() {
                                        "buy" | "bid" => OrderSide::Buy,
                                        "sell" | "ask" => OrderSide::Sell,
                                        _ => {
                                            tprintln!("{} {} Unknown side: {}", "[FILL_DETECTION]".magenta().bold(), "✗".red().bold(), side_str);
                                            return;
                                        }
                                    };

                                    let filled_size: f64 = parse(&filled_amount_str).unwrap_or(0.0);

                                    {
                                        let mut state = bot_state_clone.write().await;
                                        state.mark_filled(filled_size, order_side);
                                    }

                                    tprintln!("{} {} PARTIAL FILL DETECTED - State updated to Filled",
                                        "[FILL_DETECTION]".magenta().bold(),
                                        "✓".green().bold()
                                    );

                                    // *** PARALLEL EXECUTION: Cancellation + Hedge Trigger ***
                                    // State machine (mark_filled) already prevents new orders
                                    // Dual cancel runs async while hedge triggers immediately
                                    // Pre-hedge cancellation in hedge.rs provides defensive redundancy
                                    tprintln!("{} {} Spawning async dual cancellation (REST + WebSocket)...",
                                        "[FILL_DETECTION]".magenta().bold(),
                                        "⚡".yellow().bold()
                                    );

                                    // Clone for async cancellation task
                                    let pac_trading_bg = pac_trading_clone.clone();
                                    let pac_ws_trading_bg = pac_ws_trading_clone.clone();
                                    let symbol_bg = symbol_clone.clone();

                                    // Spawn dual cancel in background (don't await)
                                    tokio::spawn(async move {
                                        match dual_cancel(
                                            &pac_trading_bg,
                                            &pac_ws_trading_bg,
                                            &symbol_bg
                                        ).await {
                                            Ok((rest_count, ws_count)) => {
                                                tprintln!("{} {} Background dual cancellation complete (REST: {}, WS: {})",
                                                    "[FILL_DETECTION]".magenta().bold(),
                                                    "✓✓".green().bold(),
                                                    rest_count,
                                                    ws_count
                                                );
                                            }
                                            Err(e) => {
                                                tprintln!("{} {} Background dual cancellation failed: {}",
                                                    "[FILL_DETECTION]".magenta().bold(),
                                                    "✗".red().bold(),
                                                    e
                                                );
                                            }
                                        }
                                    });

                                    // *** CRITICAL: UPDATE POSITION BASELINE ***
                                    let avg_px: f64 = parse(&avg_price_str).unwrap_or(0.0);
                                    baseline_updater_clone.update_baseline(
                                        &symbol_clone,
                                        &side_str,
                                        filled_size,
                                        avg_px
                                    );

                                    // *** TRIGGER HEDGE IMMEDIATELY (PARALLEL WITH CANCELLATION) ***
                                    let hedge_trigger_latency = fill_detect_start.elapsed();
                                    tprintln!("{} {} ⚡ PARALLEL EXECUTION: Hedge triggered in {:.1}ms (cancellation running async)",
                                        format!("[{}]", symbol_clone).bright_white().bold(),
                                        "Partial fill".green().bold(),
                                        hedge_trigger_latency.as_secs_f64() * 1000.0
                                    );

                                    // Trigger hedge immediately (runs in parallel with background cancellation)
                                    let _ = hedge_tx.send((order_side, filled_size, avg_px, fill_detect_start));
                                }
                            });
                        } else {
                            tprintln!(
                                "{} {} Partial fill notional ${:.2} < $10.00 threshold, skipping hedge",
                                "[FILL_DETECTION]".magenta().bold(),
                                "→".bright_black(),
                                notional_value
                            );
                        }
                    }
                    FillEvent::PositionFill { .. } => {
                        // Position-based fills are handled by PositionMonitorService
                        // This is logged at debug level to avoid spam
                        debug!("[FILL_DETECTION] Position fill event (handled by PositionMonitorService)");
                    }
                }
            })
            .await
            .ok();
    }
}


================================================================================
FILE: src\services\hedge.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\hedge.rs
================================================================================

use std::sync::Arc;
use parking_lot::Mutex;
use std::time::Duration;
use tokio::sync::{mpsc, RwLock};
use colored::Colorize;
use chrono::Utc;
use futures_util::{SinkExt, StreamExt};
use tokio::net::TcpStream;
use tokio_tungstenite::{connect_async, tungstenite::protocol::Message, MaybeTlsStream, WebSocketStream};
use fast_float::parse;

use crate::bot::BotState;
use crate::config::Config;
use crate::connector::hyperliquid::HyperliquidTrading;
use crate::connector::hyperliquid::types::{WsPostRequest, WsPostRequestInner, WsPostResponse};
use crate::connector::pacifica::PacificaTrading;
use crate::services::HedgeEvent;
use crate::strategy::OrderSide;
use crate::trade_fetcher;
use crate::csv_logger;

type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;
type WsWrite = futures_util::stream::SplitSink<WsStream, Message>;
type WsRead = futures_util::stream::SplitStream<WsStream>;

// Macro for timestamped colored output
macro_rules! tprintln {
    ($($arg:tt)*) => {{
        println!("{} {}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string().bright_black(),
            format!($($arg)*)
        );
    }};
}

/// Hedge execution service
///
/// Receives hedge triggers via mpsc channel and executes the hedge flow:
/// 1. Pre-hedge cancellation of all Pacifica orders
/// 2. Execute market order on Hyperliquid (opposite direction)
/// 3. Wait for trade propagation (20s)
/// 4. Fetch trade history from both exchanges
/// 5. Calculate actual profit using real fill data and fees
/// 6. Display comprehensive trade summary
/// 7. Post-hedge cancellation (safety)
/// 8. Position verification on both exchanges
/// 9. Mark cycle complete and signal shutdown
pub struct HedgeService {
    pub bot_state: Arc<RwLock<BotState>>,
    pub hedge_rx: mpsc::UnboundedReceiver<HedgeEvent>,
    pub hyperliquid_prices: Arc<Mutex<(f64, f64)>>,
    pub config: Config,
    pub hyperliquid_trading: Arc<HyperliquidTrading>,
    pub pacifica_trading: Arc<PacificaTrading>,
    pub shutdown_tx: mpsc::Sender<()>,
}

impl HedgeService {
    pub async fn run(mut self) {
        let use_ws_for_hedge = self.config.hyperliquid_use_ws_for_hedge;
        let mut ws_write: Option<WsWrite> = None;
        let mut ws_read: Option<WsRead> = None;
        let mut ws_request_id: u64 = 0;

        // Optionally establish trading WebSocket up front so it is hot
        if use_ws_for_hedge {
            match self.connect_hyperliquid_ws().await {
                Ok((write, read)) => {
                    tprintln!(
                        "{} {} Hyperliquid trading WebSocket connected (hedge execution via WS)",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "✓".green().bold(),
                    );
                    ws_write = Some(write);
                    ws_read = Some(read);
                }
                Err(e) => {
                    tprintln!(
                        "{} {} Failed to pre-connect Hyperliquid trading WebSocket (using REST until reconnect succeeds): {}",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "⚠".yellow().bold(),
                        e
                    );
                }
            }
        }

        // Keep-alive interval for WebSocket pings (5s to keep connection warm)
        let mut keepalive_interval = tokio::time::interval(std::time::Duration::from_secs(5));
        keepalive_interval.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

        loop {
            tokio::select! {
                // Send periodic pings to keep WebSocket connection warm
                _ = keepalive_interval.tick() => {
                    if let Some(write) = ws_write.as_mut() {
                        if let Err(e) = write.send(Message::Ping(vec![])).await {
                            tprintln!("{} {} Failed to send keepalive ping: {}",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "⚠".yellow().bold(),
                                e
                            );
                            // Connection likely dead, clear write handle
                            ws_write = None;
                        }
                    }
                }

                // Main hedge event processing
                Some((side, size, avg_price, fill_timestamp)) = self.hedge_rx.recv() => {
            let reception_latency = fill_timestamp.elapsed();
            tprintln!("{} ⚡ HEDGE RECEIVED: {} {} @ {} | Reception latency: {:.1}ms",
                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                side.as_str().bright_yellow(),
                size,
                format!("${:.4}", avg_price).cyan(),
                reception_latency.as_secs_f64() * 1000.0
            );

            // *** CRITICAL: CANCEL ALL ORDERS BEFORE HEDGE ***
            // Extra safety: cancel again in case fill detection missed anything
            // or there was a race condition
            tprintln!("{} {} Pre-hedge safety: Cancelling all Pacifica orders...",
                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                "⚡".yellow().bold()
            );

            if let Err(e) = self.pacifica_trading
                .cancel_all_orders(false, Some(&self.config.symbol), false)
                .await
            {
                tprintln!("{} {} Failed to cancel orders before hedge: {}",
                    format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                    "⚠".yellow().bold(),
                    e
                );
            } else {
                tprintln!("{} {} Pre-hedge cancellation complete",
                    format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                    "✓".green().bold()
                );
            }

            // Update status
            {
                let mut state = self.bot_state.write().await;
                state.mark_hedging();
            }

            // Execute opposite direction on Hyperliquid
            let is_buy = match side {
                OrderSide::Buy => false, // Filled buy on Pacifica → sell on Hyperliquid
                OrderSide::Sell => true, // Filled sell on Pacifica → buy on Hyperliquid
            };

            let (mut hl_bid, mut hl_ask) = *self.hyperliquid_prices.lock();

            if hl_bid <= 0.0 || hl_ask <= 0.0 {
                tprintln!("{} {} Hyperliquid price cache empty - fetching fresh snapshot before hedging",
                    format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                    "⚠".yellow().bold()
                );

                const MAX_ATTEMPTS: usize = 5;
                for attempt in 1..=MAX_ATTEMPTS {
                    match self.hyperliquid_trading.get_l2_snapshot(&self.config.symbol).await {
                        Ok(Some((bid, ask))) if bid > 0.0 && ask > 0.0 => {
                            hl_bid = bid;
                            hl_ask = ask;
                            let mut cache = self.hyperliquid_prices.lock();
                            *cache = (bid, ask);
                            tprintln!("{} {} Refreshed Hyperliquid prices: bid ${:.4}, ask ${:.4}",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "✓".green().bold(),
                                hl_bid,
                                hl_ask
                            );
                            break;
                        }
                        Ok(_) => {
                            tprintln!("{} {} Snapshot missing bid/ask data (attempt {}/{})",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "⚠".yellow().bold(),
                                attempt,
                                MAX_ATTEMPTS
                            );
                        }
                        Err(err) => {
                            tprintln!("{} {} Failed to fetch Hyperliquid snapshot (attempt {}/{}): {}",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "⚠".yellow().bold(),
                                attempt,
                                MAX_ATTEMPTS,
                                err
                            );
                        }
                    }

                    if attempt < MAX_ATTEMPTS {
                        tokio::time::sleep(Duration::from_millis(500)).await;
                        let cached = *self.hyperliquid_prices.lock();
                        hl_bid = cached.0;
                        hl_ask = cached.1;
                        if hl_bid > 0.0 && hl_ask > 0.0 {
                            tprintln!("{} {} Hyperliquid prices populated by feed during wait",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "✓".green().bold()
                            );
                            break;
                        }
                    }
                }

                if hl_bid <= 0.0 || hl_ask <= 0.0 {
                    tprintln!("{} {} Unable to obtain Hyperliquid prices - aborting hedge for safety",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "✗".red().bold()
                    );

                    let mut state = self.bot_state.write().await;
                    state.set_error("Hyperliquid prices unavailable for hedge".to_string());

                    self.shutdown_tx.send(()).await.ok();
                    return;
                }
            }

            tprintln!(
                "{} Executing {} {} on Hyperliquid",
                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                if is_buy { "BUY".green().bold() } else { "SELL".red().bold() },
                size
            );

            let hedge_result = if use_ws_for_hedge {
                // Ensure we have an active trading WebSocket
                if ws_write.is_none() || ws_read.is_none() {
                    match self.connect_hyperliquid_ws().await {
                        Ok((write, read)) => {
                            tprintln!(
                                "{} {} Reconnected Hyperliquid trading WebSocket for hedge execution",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "✓".green().bold()
                            );
                            ws_write = Some(write);
                            ws_read = Some(read);
                        }
                        Err(e) => {
                            tprintln!(
                                "{} {} Failed to connect Hyperliquid trading WebSocket, falling back to REST for this hedge: {}",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "⚠".yellow().bold(),
                                e
                            );
                        }
                    }
                }

                if let (Some(write), Some(read)) = (ws_write.as_mut(), ws_read.as_mut()) {
                    match self
                        .place_market_order_ws(write, read, &mut ws_request_id, is_buy, size, hl_bid, hl_ask)
                        .await
                    {
                        Ok(response) => Ok(response),
                        Err(e) => {
                            tprintln!(
                                "{} {} WebSocket hedge execution failed, falling back to REST: {}",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "⚠".yellow().bold(),
                                e
                            );
                            // Drop WS so next hedge attempts a clean reconnect
                            ws_write = None;
                            ws_read = None;

                            self.hyperliquid_trading
                                .place_market_order(
                                    &self.config.symbol,
                                    is_buy,
                                    size,
                                    self.config.hyperliquid_slippage,
                                    false, // reduce_only
                                    Some(hl_bid),
                                    Some(hl_ask),
                                )
                                .await
                        }
                    }
                } else {
                    // No WS connection available – use REST for this hedge
                    self.hyperliquid_trading
                        .place_market_order(
                            &self.config.symbol,
                            is_buy,
                            size,
                            self.config.hyperliquid_slippage,
                            false, // reduce_only
                            Some(hl_bid),
                            Some(hl_ask),
                        )
                        .await
                }
            } else {
                // WS disabled via config – use REST only
                self.hyperliquid_trading
                    .place_market_order(
                        &self.config.symbol,
                        is_buy,
                        size,
                        self.config.hyperliquid_slippage,
                        false, // reduce_only
                        Some(hl_bid),
                        Some(hl_ask),
                    )
                    .await
            };

            match hedge_result {
                Ok(response) => {
                    // Extract success data from response
                    let response_data = match &response.response {
                        crate::connector::hyperliquid::OrderResponseContent::Success(data) => data,
                        crate::connector::hyperliquid::OrderResponseContent::Error(error) => {
                            // This should not happen as trading.rs already handles errors,
                            // but handle it defensively
                            tprintln!("{} {} Hedge response contains error: {}",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "✗".red().bold(),
                                error
                            );

                            let mut state = self.bot_state.write().await;
                            state.set_error(format!("Hedge failed: {}", error));
                            drop(state);

                            self.shutdown_tx.send(()).await.ok();
                            return;
                        }
                    };

                    // Calculate ACTUAL end-to-end latency from fill detection to hedge completion
                    let end_to_end_latency = fill_timestamp.elapsed();

                    // Validate and extract order status
                    let hedge_fill_price = if let Some(status) = response_data.data.statuses.first() {
                        match status {
                            crate::connector::hyperliquid::OrderStatus::Filled { filled } => {
                                tprintln!("{} {} Hedge executed successfully: Filled {} @ ${} | Total latency: {:.1}ms",
                                    format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                    "✓".green().bold(),
                                    filled.totalSz,
                                    filled.avgPx,
                                    end_to_end_latency.as_secs_f64() * 1000.0
                                );
                                filled.avgPx.parse::<f64>().ok()
                            }
                            crate::connector::hyperliquid::OrderStatus::Error { error } => {
                                tprintln!("{} {} Hedge order FAILED: {}",
                                    format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                    "✗".red().bold(),
                                    error
                                );

                                // Set error state
                                {
                                    let mut state = self.bot_state.write().await;
                                    state.set_error(format!("Hedge order failed: {}", error));
                                }

                                // Signal shutdown with error
                                self.shutdown_tx.send(()).await.ok();
                                return;  // Exit hedge service immediately
                            }
                            crate::connector::hyperliquid::OrderStatus::Resting { resting } => {
                                tprintln!("{} {} Hedge order is RESTING (oid: {}) - unexpected for IOC market order",
                                    format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                    "⚠".yellow().bold(),
                                    resting.oid
                                );

                                // Treat as error - IOC orders should never rest
                                {
                                    let mut state = self.bot_state.write().await;
                                    state.set_error(format!("Hedge order resting (unexpected for IOC): oid {}", resting.oid));
                                }

                                self.shutdown_tx.send(()).await.ok();
                                return;
                            }
                        }
                    } else {
                        tprintln!("{} {} Hedge response has no statuses - unexpected API response",
                            format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                            "⚠".yellow().bold()
                        );
                        None
                    };

                    // Validate we got a fill price before continuing
                    let hedge_fill_price = match hedge_fill_price {
                        Some(price) => price,
                        None => {
                            tprintln!("{} {} No hedge fill price available - hedge may have failed",
                                format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                                "✗".red().bold()
                            );

                            {
                                let mut state = self.bot_state.write().await;
                                state.set_error("Hedge execution failed - no fill price".to_string());
                            }

                            self.shutdown_tx.send(()).await.ok();
                            return;
                        }
                    };

                    // Get expected profit from active order before marking complete
                    let expected_profit_bps = {
                        let state = self.bot_state.read().await;
                        state.active_order.as_ref().map(|o| o.initial_profit_bps)
                    };

                    // Wait for trades to propagate to exchange APIs (20 seconds)
                    tprintln!("{} Waiting 20 seconds for trades to propagate to APIs...",
                        format!("[{} PROFIT]", self.config.symbol).bright_blue().bold()
                    );
                    tokio::time::sleep(Duration::from_secs(20)).await;

                    // Get client_order_id from bot state
                    let client_order_id = {
                        let state = self.bot_state.read().await;
                        state.active_order.as_ref().map(|o| o.client_order_id.clone())
                    };

                    // Fetch Pacifica trade history with retry logic
                    let (pacifica_fill_price, pacifica_actual_fee, pacifica_notional): (Option<f64>, Option<f64>, Option<f64>) = if let Some(cloid) = &client_order_id {
                        let result = trade_fetcher::fetch_pacifica_trade(
                            self.pacifica_trading.clone(),
                            &self.config.symbol,
                            &cloid,
                            3, // max_attempts
                            |msg| {
                                tprintln!("{} {}",
                                    format!("[{} PROFIT]", self.config.symbol).bright_blue().bold(),
                                    msg
                                );
                            }
                        ).await;
                        (result.fill_price, result.actual_fee, result.total_notional)
                    } else {
                        (None, None, None)
                    };

                    // Fetch Hyperliquid user fills with retry logic
                    let hl_wallet = std::env::var("HL_WALLET").unwrap_or_default();
                    let (hl_fill_price, hl_actual_fee, hl_notional): (Option<f64>, Option<f64>, Option<f64>) = {
                        let result = trade_fetcher::fetch_hyperliquid_fills(
                            &self.hyperliquid_trading,
                            &hl_wallet,
                            &self.config.symbol,
                            3, // max_attempts
                            30, // time_window_secs
                            |msg| {
                                tprintln!("{} {}",
                                    format!("[{} PROFIT]", self.config.symbol).bright_blue().bold(),
                                    msg
                                );
                            }
                        ).await;
                        (result.fill_price, result.actual_fee, result.total_notional)
                    };

                    // Calculate actual profitability using real fill data and actual fees
                    let (actual_profit_bps, actual_profit_usd, pacifica_actual_price, hl_actual_price, pac_fee_usd, hl_fee_usd) =
                        match (pacifica_notional, hl_notional, pacifica_fill_price, hl_fill_price) {
                            (Some(pac_notional), Some(hl_notional), pac_price_opt, hl_price_opt) => {
                                // Use ACTUAL notional values from exchanges (not recalculated!)
                                // This handles multi-fill trades correctly and avoids Pacifica API bugs

                                // Use actual fees from trade history, or fall back to theoretical
                                let pac_fee = pacifica_actual_fee.unwrap_or_else(|| {
                                    // Fallback: 1.5 bps on notional
                                    pac_notional * (self.config.pacifica_maker_fee_bps / 10000.0)
                                });

                                let hl_fee = hl_actual_fee.unwrap_or_else(|| {
                                    // Fallback: 4 bps on notional
                                    hl_notional * (self.config.hyperliquid_taker_fee_bps / 10000.0)
                                });

                                // Use the shared profit calculation function (same as test utility!)
                                let is_pacifica_buy = matches!(side, OrderSide::Buy);
                                let profit = trade_fetcher::calculate_hedge_profit(
                                    pac_notional,
                                    hl_notional,
                                    pac_fee,
                                    hl_fee,
                                    is_pacifica_buy,
                                );

                                (profit.profit_bps, profit.net_profit, pac_price_opt, hl_price_opt, pac_fee, hl_fee)
                            }
                            _ => {
                                // Fallback to fill event data if trade history unavailable
                                tprintln!("{} {} Using fill event data (trade history unavailable)",
                                    format!("[{} PROFIT]", self.config.symbol).bright_blue().bold(),
                                    "⚠".yellow().bold()
                                );

                                // Calculate profit using fill event prices and estimated fees
                                let hl_price = hedge_fill_price;
                                let pac_price = avg_price;

                                // Estimate fees using configured rates
                                let pac_fee = pac_price * size * (self.config.pacifica_maker_fee_bps / 10000.0);
                                let hl_fee = hl_price * size * (self.config.hyperliquid_taker_fee_bps / 10000.0);

                                // Calculate profit
                                let (profit_usd, cost, _revenue) = match side {
                                    OrderSide::Buy => {
                                        // Bought on Pacifica (maker), Sold on Hyperliquid (taker)
                                        let cost = (pac_price * size) + pac_fee;
                                        let revenue = (hl_price * size) - hl_fee;
                                        (revenue - cost, cost, revenue)
                                    }
                                    OrderSide::Sell => {
                                        // Sold on Pacifica (maker), Bought on Hyperliquid (taker)
                                        let revenue = (pac_price * size) - pac_fee;
                                        let cost = (hl_price * size) + hl_fee;
                                        (revenue - cost, cost, revenue)
                                    }
                                };

                                let profit_rate = if cost > 0.0 { profit_usd / cost } else { 0.0 };
                                let profit_bps = profit_rate * 10000.0;

                                (profit_bps, profit_usd, Some(pac_price), Some(hl_price), pac_fee, hl_fee)
                            }
                        };

                    // Log trade to CSV file
                    if pacifica_actual_price.is_some() && hl_actual_price.is_some() {
                        let trade_record = csv_logger::TradeRecord::new(
                            Utc::now(),
                            end_to_end_latency.as_secs_f64() * 1000.0,  // Convert to milliseconds
                            self.config.symbol.clone(),
                            side,
                            pacifica_actual_price.unwrap(),
                            size,
                            pacifica_notional.unwrap_or(pacifica_actual_price.unwrap() * size),
                            pac_fee_usd,
                            hl_actual_price.unwrap(),
                            size,
                            hl_notional.unwrap_or(hl_actual_price.unwrap() * size),
                            hl_fee_usd,
                            expected_profit_bps.unwrap_or(0.0),
                            actual_profit_bps,
                            actual_profit_usd,
                        );

                        let csv_file = format!("{}_trades.csv", self.config.symbol.to_lowercase());
                        if let Err(e) = csv_logger::log_trade(&csv_file, &trade_record) {
                            tprintln!("{} {} Failed to log trade to CSV: {}",
                                format!("[{} CSV]", self.config.symbol).bright_yellow().bold(),
                                "⚠".yellow().bold(),
                                e
                            );
                        } else {
                            tprintln!("{} {} Trade logged to {}",
                                format!("[{} CSV]", self.config.symbol).bright_green().bold(),
                                "✓".green().bold(),
                                csv_file
                            );
                        }
                    }

                    // Display comprehensive summary
                    tprintln!("{}", "═══════════════════════════════════════════════════".green().bold());
                    tprintln!("{}", "  BOT CYCLE COMPLETE!".green().bold());
                    tprintln!("{}", "═══════════════════════════════════════════════════".green().bold());
                    tprintln!("");
                    tprintln!("{}", "📊 TRADE SUMMARY:".bright_white().bold());
                    if let Some(pac_price) = pacifica_actual_price {
                        tprintln!("  {}: {} {} {} @ {} {}",
                            "Pacifica".bright_magenta(),
                            side.as_str().bright_yellow(),
                            format!("{:.4}", size).bright_white(),
                            self.config.symbol.bright_white().bold(),
                            format!("${:.6}", pac_price).cyan().bold(),
                            "(actual fill)".bright_black()
                        );
                    }
                    if let Some(hl_price) = hl_actual_price {
                        tprintln!("  {}: {} {} {} @ {} {}",
                            "Hyperliquid".bright_magenta(),
                            if is_buy { "BUY".green() } else { "SELL".red() },
                            format!("{:.4}", size).bright_white(),
                            self.config.symbol.bright_white().bold(),
                            format!("${:.6}", hl_price).cyan().bold(),
                            "(actual fill)".bright_black()
                        );
                    }
                    tprintln!("");
                    tprintln!("{}", "💰 PROFITABILITY:".bright_white().bold());
                    if let Some(expected) = expected_profit_bps {
                        tprintln!("  Expected: {} bps", format!("{:.2}", expected).bright_white());
                    }
                    if pacifica_actual_price.is_some() && hl_actual_price.is_some() {
                        let profit_color = if actual_profit_bps > 0.0 { format!("{:.2}", actual_profit_bps).green().bold() } else { format!("{:.2}", actual_profit_bps).red().bold() };
                        let usd_color = if actual_profit_usd > 0.0 { format!("${:.4}", actual_profit_usd).green().bold() } else { format!("${:.4}", actual_profit_usd).red().bold() };
                        tprintln!("  Actual:   {} bps ({})", profit_color, usd_color);
                        if let Some(expected) = expected_profit_bps {
                            let diff = actual_profit_bps - expected;
                            let diff_sign = if diff >= 0.0 { "+" } else { "" };
                            let diff_color = if diff >= 0.0 { format!("{}{:.2}", diff_sign, diff).green() } else { format!("{:.2}", diff).red() };
                            tprintln!("  Difference: {} bps", diff_color);
                        }
                    } else {
                        tprintln!("  {} Unable to calculate actual profit (trade history unavailable)", "⚠".yellow().bold());
                    }
                    tprintln!("");
                    tprintln!("{}", "📈 FEES:".bright_white().bold());
                    if pacifica_actual_price.is_some() && hl_actual_price.is_some() {
                        // Show actual fees paid
                        tprintln!("  Pacifica: {} {}",
                            format!("${:.4}", pac_fee_usd).yellow(),
                            if pacifica_actual_fee.is_some() { "(actual)" } else { "(estimated)" }.bright_black()
                        );
                        tprintln!("  Hyperliquid: {} {}",
                            format!("${:.4}", hl_fee_usd).yellow(),
                            if hl_actual_fee.is_some() { "(actual)" } else { "(estimated)" }.bright_black()
                        );
                        tprintln!("  Total: {}", format!("${:.4}", pac_fee_usd + hl_fee_usd).yellow().bold());
                    } else {
                        // Fallback to theoretical fees
                        tprintln!("  Pacifica (maker): {} bps", format!("{:.2}", self.config.pacifica_maker_fee_bps).yellow());
                        tprintln!("  Hyperliquid (taker): {} bps", format!("{:.2}", self.config.hyperliquid_taker_fee_bps).yellow());
                        tprintln!("  Total fees: {} bps", format!("{:.2}", self.config.pacifica_maker_fee_bps + self.config.hyperliquid_taker_fee_bps).yellow().bold());
                    }
                    tprintln!("{}", "═══════════════════════════════════════════════════".green().bold());

                    // *** CRITICAL: FINAL SAFETY CANCELLATION ***
                    // Cancel all orders one last time before marking complete
                    // This ensures no stray orders remain active
                    tprintln!("");
                    tprintln!("{} {} Post-hedge safety: Final cancellation of all Pacifica orders...",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "⚡".yellow().bold()
                    );

                    if let Err(e) = self.pacifica_trading
                        .cancel_all_orders(false, Some(&self.config.symbol), false)
                        .await
                    {
                        tprintln!("{} {} Failed to cancel orders after hedge completion: {}",
                            format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                            "⚠".yellow().bold(),
                            e
                        );
                    } else {
                        tprintln!("{} {} Final cancellation complete",
                            format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                            "✓".green().bold()
                        );
                    }

                    // *** POST-HEDGE POSITION VERIFICATION ***
                    // Wait for positions to propagate and verify net position is neutral
                    tprintln!("");
                    tprintln!("{} {} Post-hedge verification: Waiting 8 seconds for positions to propagate...",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "⏱".cyan().bold()
                    );
                    tokio::time::sleep(tokio::time::Duration::from_secs(8)).await;

                    tprintln!("{} Verifying final positions on both exchanges...",
                        format!("[{} VERIFY]", self.config.symbol).cyan().bold()
                    );

                    // Check Pacifica position
                    let pacifica_position = match self.pacifica_trading.get_positions().await {
                        Ok(positions) => {
                            if let Some(pos) = positions.iter().find(|p| p.symbol == self.config.symbol) {
                                let amount: f64 = parse(&pos.amount).unwrap_or(0.0);
                                let signed_amount = if pos.side == "bid" { amount } else { -amount };

                                tprintln!("{} Pacifica: {} {} (signed: {:.4})",
                                    format!("[{} VERIFY]", self.config.symbol).cyan().bold(),
                                    amount,
                                    pos.side,
                                    signed_amount
                                );
                                Some(signed_amount)
                            } else {
                                tprintln!("{} Pacifica: No position (flat)",
                                    format!("[{} VERIFY]", self.config.symbol).cyan().bold()
                                );
                                Some(0.0)
                            }
                        }
                        Err(e) => {
                            tprintln!("{} {} Failed to fetch Pacifica position: {}",
                                format!("[{} VERIFY]", self.config.symbol).yellow().bold(),
                                "⚠".yellow().bold(),
                                e
                            );
                            None
                        }
                    };

                    // Check Hyperliquid position
                    let hl_wallet = std::env::var("HL_WALLET").unwrap_or_default();
                    let mut hyperliquid_position: Option<f64> = None;

                    // Try up to 3 times with delays if position not found
                    for retry in 0..3 {
                        if retry > 0 {
                            tprintln!("{} Retry {} - waiting 3 more seconds for Hyperliquid position...",
                                format!("[{} VERIFY]", self.config.symbol).cyan().bold(),
                                retry
                            );
                            tokio::time::sleep(tokio::time::Duration::from_secs(3)).await;
                        }

                        match self.hyperliquid_trading.get_user_state(&hl_wallet).await {
                            Ok(user_state) => {
                                if let Some(asset_pos) = user_state.asset_positions.iter().find(|ap| ap.position.coin == self.config.symbol) {
                                    let szi: f64 = parse(&asset_pos.position.szi).unwrap_or(0.0);
                                    tprintln!("{} Hyperliquid: {} (signed: {:.4})",
                                        format!("[{} VERIFY]", self.config.symbol).cyan().bold(),
                                        if szi > 0.0 { "LONG".green() } else if szi < 0.0 { "SHORT".red() } else { "FLAT".bright_white() },
                                        szi
                                    );
                                    hyperliquid_position = Some(szi);
                                    break;
                                } else if retry == 2 {
                                    tprintln!("{} Hyperliquid: No position found after 3 attempts (flat)",
                                        format!("[{} VERIFY]", self.config.symbol).cyan().bold()
                                    );
                                    hyperliquid_position = Some(0.0);
                                }
                            }
                            Err(e) => {
                                if retry == 2 {
                                    tprintln!("{} {} Failed to fetch Hyperliquid position after 3 attempts: {}",
                                        format!("[{} VERIFY]", self.config.symbol).yellow().bold(),
                                        "⚠".yellow().bold(),
                                        e
                                    );
                                    hyperliquid_position = None;
                                }
                            }
                        }
                    }

                    // Calculate net position across both exchanges
                    if let (Some(pac_pos), Some(hl_pos)) = (pacifica_position, hyperliquid_position) {
                        let net_position = pac_pos + hl_pos;

                        tprintln!("");
                        tprintln!("{} Net Position: {:.4} (Pacifica: {:.4} + Hyperliquid: {:.4})",
                            format!("[{} VERIFY]", self.config.symbol).cyan().bold(),
                            net_position,
                            pac_pos,
                            hl_pos
                        );

                        // Check if net position is close to neutral
                        if net_position.abs() < 0.01 {
                            tprintln!("{} {} Net position is NEUTRAL (properly hedged across both exchanges)",
                                format!("[{} VERIFY]", self.config.symbol).cyan().bold(),
                                "✓".green().bold()
                            );
                        } else {
                            tprintln!("");
                            tprintln!("{}", "⚠".repeat(80).yellow());
                            tprintln!("{} {} WARNING: Net position NOT neutral!",
                                format!("[{} VERIFY]", self.config.symbol).red().bold(),
                                "⚠".yellow().bold()
                            );
                            tprintln!("{} Position delta: {:.4} {}",
                                format!("[{} VERIFY]", self.config.symbol).red().bold(),
                                net_position.abs(),
                                self.config.symbol
                            );
                            tprintln!("{} This indicates a potential hedge failure or partial fill.",
                                format!("[{} VERIFY]", self.config.symbol).red().bold()
                            );
                            tprintln!("{} Please check positions manually and rebalance if needed!",
                                format!("[{} VERIFY]", self.config.symbol).red().bold()
                            );
                            tprintln!("{}", "⚠".repeat(80).yellow());
                            tprintln!("");
                        }
                    } else {
                        tprintln!("");
                        tprintln!("{} {} WARNING: Could not verify net position!",
                            format!("[{} VERIFY]", self.config.symbol).yellow().bold(),
                            "⚠".yellow().bold()
                        );
                        tprintln!("{} Failed to fetch positions from one or both exchanges.",
                            format!("[{} VERIFY]", self.config.symbol).yellow().bold()
                        );
                        tprintln!("{} Please check positions manually!",
                            format!("[{} VERIFY]", self.config.symbol).yellow().bold()
                        );
                        tprintln!("");
                    }

                    // Mark cycle as complete AFTER displaying profit AND final cancellation
                    let mut state = self.bot_state.write().await;
                    state.mark_complete();
                    drop(state);

                    // Signal shutdown
                    self.shutdown_tx.send(()).await.ok();
                }
                Err(e) => {
                    tprintln!("{} {} Hedge failed: {}",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "✗".red().bold(),
                        e.to_string().red()
                    );

                    // *** CRITICAL: CANCEL ALL ORDERS ON ERROR ***
                    // Even if hedge fails, cancel all orders to prevent stray positions
                    tprintln!("{} {} Error recovery: Cancelling all Pacifica orders...",
                        format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                        "⚡".yellow().bold()
                    );

                    if let Err(cancel_err) = self.pacifica_trading
                        .cancel_all_orders(false, Some(&self.config.symbol), false)
                        .await
                    {
                        tprintln!("{} {} Failed to cancel orders after hedge error: {}",
                            format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                            "⚠".yellow().bold(),
                            cancel_err
                        );
                    } else {
                        tprintln!("{} {} Error recovery cancellation complete",
                            format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
                            "✓".green().bold()
                        );
                    }

                    let mut state = self.bot_state.write().await;
                    state.set_error(format!("Hedge failed: {}", e));

                    // Signal shutdown with error
                    self.shutdown_tx.send(()).await.ok();
                }
            }
                } // Close Some((side, size, avg_price, fill_timestamp)) arm
            } // Close tokio::select!
        } // Close loop
    }

    /// Establish a Hyperliquid trading WebSocket connection for hedging.
    async fn connect_hyperliquid_ws(&self) -> anyhow::Result<(WsWrite, WsRead)> {
        let ws_url = if self.hyperliquid_trading.is_testnet() {
            "wss://api.hyperliquid-testnet.xyz/ws"
        } else {
            "wss://api.hyperliquid.xyz/ws"
        };

        let (ws_stream, _) = connect_async(ws_url).await?;
        let (write, read) = ws_stream.split();
        Ok((write, read))
    }

    /// Place a market IOC order over Hyperliquid WebSocket using the shared
    /// REST signing and request-building logic.
    async fn place_market_order_ws(
        &self,
        write: &mut WsWrite,
        read: &mut WsRead,
        request_id_counter: &mut u64,
        is_buy: bool,
        size: f64,
        bid: f64,
        ask: f64,
    ) -> anyhow::Result<crate::connector::hyperliquid::OrderResponse> {
        // Build signed order payload (same as REST)
        let payload = self
            .hyperliquid_trading
            .build_market_order_request(
                &self.config.symbol,
                is_buy,
                size,
                self.config.hyperliquid_slippage,
                false,
                Some(bid),
                Some(ask),
            )
            .await?;

        *request_id_counter += 1;
        let request_id = *request_id_counter;

        let ws_request = WsPostRequest {
            method: "post".to_string(),
            id: request_id,
            request: WsPostRequestInner {
                type_: "action".to_string(),
                payload,
            },
        };

        let request_json = serde_json::to_string(&ws_request)?;
        tprintln!(
            "{} Sending Hyperliquid hedge order via WebSocket (id={})",
            format!("[{} HEDGE]", self.config.symbol).bright_magenta().bold(),
            request_id
        );
        write.send(Message::Text(request_json)).await?;

        // Wait for the matching post response
        loop {
            match read.next().await {
                Some(Ok(Message::Text(text))) => {
                    // Try to parse as a generic post response
                    let ws_resp: WsPostResponse = match serde_json::from_str(&text) {
                        Ok(r) => r,
                        Err(_) => {
                            // Ignore unrelated/non-standard messages
                            continue;
                        }
                    };

                    if ws_resp.channel != "post" || ws_resp.data.id != request_id {
                        // Response for another request or channel – ignore
                        continue;
                    }

                    let resp_type = ws_resp.data.response.type_;
                    let payload = ws_resp.data.response.payload;

                    return match resp_type.as_str() {
                        "action" => {
                            let order_response: crate::connector::hyperliquid::OrderResponse =
                                serde_json::from_value(payload)?;
                            Ok(order_response)
                        }
                        "error" => {
                            let msg = payload
                                .as_str()
                                .unwrap_or("Unknown Hyperliquid WebSocket error")
                                .to_string();
                            anyhow::bail!("Hyperliquid WebSocket order error: {}", msg);
                        }
                        other => {
                            anyhow::bail!("Unexpected Hyperliquid WebSocket response type: {}", other);
                        }
                    };
                }
                Some(Ok(Message::Ping(data))) => {
                    // Respond to low-level WebSocket ping frames
                    write.send(Message::Pong(data)).await?;
                }
                Some(Ok(Message::Pong(_))) => {
                    // Ignore
                }
                Some(Ok(Message::Close(frame))) => {
                    anyhow::bail!("Hyperliquid WebSocket closed: {:?}", frame);
                }
                Some(Err(e)) => {
                    anyhow::bail!("Hyperliquid WebSocket error: {}", e);
                }
                None => {
                    anyhow::bail!("Hyperliquid WebSocket stream ended unexpectedly");
                }
                _ => {}
            }
        }
    }
}


================================================================================
FILE: src\services\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\mod.rs
================================================================================

/// Service modules - each task runs in its own service

pub mod fill_detection;
pub mod rest_fill_detection;
pub mod position_monitor;
pub mod order_monitor;
pub mod hedge;
pub mod orderbook;
pub mod rest_poll;

use crate::strategy::OrderSide;

/// HedgeEvent represents a single hedge trigger coming from any
/// fill detection layer. It is carried through a low-latency queue
/// between the fill detection “thread(s)” and the hedge executor.
///
/// Tuple layout:
/// (side, size, avg_price, fill_detect_timestamp)
pub type HedgeEvent = (OrderSide, f64, f64, std::time::Instant);


================================================================================
FILE: src\services\order_monitor.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\order_monitor.rs
================================================================================

use std::sync::atomic::{AtomicU8, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use parking_lot::Mutex;
use tokio::sync::{mpsc, RwLock};
use tokio::time::interval;
use tracing::{debug, info, warn};

use crate::bot::{BotState, BotStatus};
use crate::config::Config;
use crate::connector::hyperliquid::HyperliquidTrading;
use crate::connector::pacifica::PacificaTrading;
use crate::strategy::{OpportunityEvaluator, OrderSide};
use crate::util::rate_limit::{is_rate_limit_error, RateLimitTracker};

// ============================================================================
// ATOMIC STATUS FOR LOCK-FREE HOT PATH CHECKS
// ============================================================================

/// Atomic bot status for lock-free checks in hot path
#[repr(u8)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum AtomicBotStatus {
    Idle = 0,
    OrderPlaced = 1,
    Filled = 2,
    Hedging = 3,
    Complete = 4,
}

impl From<&BotStatus> for AtomicBotStatus {
    fn from(status: &BotStatus) -> Self {
        match status {
            BotStatus::Idle => AtomicBotStatus::Idle,
            BotStatus::OrderPlaced => AtomicBotStatus::OrderPlaced,
            BotStatus::Filled => AtomicBotStatus::Filled,
            BotStatus::Hedging => AtomicBotStatus::Hedging,
            BotStatus::Complete => AtomicBotStatus::Complete,
            BotStatus::Error(_) => AtomicBotStatus::Idle, // Treat errors as idle for monitoring purposes
        }
    }
}

// ============================================================================
// LIGHTWEIGHT ORDER SNAPSHOT (AVOID CLONING FULL ORDER)
// ============================================================================

/// Minimal order data needed for monitoring (avoids full clone)
#[derive(Debug, Clone, Copy)]
pub struct OrderSnapshot {
    pub side: OrderSide,
    pub price: f64,
    pub size: f64,
    pub initial_profit_bps: f64,
    pub placed_at: Instant,
}

/// Shared order snapshot updated atomically by order placer
/// Uses Option wrapped in Mutex for atomic swap semantics
pub struct SharedOrderSnapshot {
    inner: Mutex<Option<OrderSnapshot>>,
}

impl SharedOrderSnapshot {
    pub fn new() -> Self {
        Self {
            inner: Mutex::new(None),
        }
    }

    #[inline]
    pub fn get(&self) -> Option<OrderSnapshot> {
        *self.inner.lock()
    }

    #[inline]
    pub fn set(&self, snapshot: Option<OrderSnapshot>) {
        *self.inner.lock() = snapshot;
    }
}

// ============================================================================
// CANCELLATION REQUEST CHANNEL (DECOUPLE FROM HOT PATH)
// ============================================================================

/// Cancellation request sent from monitor to cancellation handler
#[derive(Debug)]
pub enum CancelRequest {
    /// Cancel due to age expiry
    AgeExpiry { symbol: String, reason: String },
    /// Cancel due to profit deviation
    ProfitDeviation { symbol: String, current_profit_bps: f64, deviation_bps: f64 },
}

// ============================================================================
// ORDER MONITOR SERVICE (OPTIMIZED)
// ============================================================================

/// Order monitoring service
///
/// Monitors active orders for:
/// 1. Age - refreshes order if age > order_refresh_interval_secs
/// 2. Profit deviation - cancels if profit drops > profit_cancel_threshold_bps
/// 3. Periodic profit logging every 2 seconds
///
/// Key optimizations:
/// - Lock-free status check via atomic
/// - No REST calls in hot loop (delegated to separate task)
/// - No cloning (uses lightweight snapshot)
/// - No allocations in hot path
pub struct OrderMonitorService {
    // Shared state (write lock only needed for mutations)
    pub bot_state: Arc<RwLock<BotState>>,
    
    // Lock-free status for hot path (updated by state manager)
    pub atomic_status: Arc<AtomicU8>,
    
    // Lightweight order snapshot (updated when order placed)
    pub order_snapshot: Arc<SharedOrderSnapshot>,
    
    // Price feeds (lock-free reads via parking_lot)
    pub pacifica_prices: Arc<Mutex<(f64, f64)>>,
    pub hyperliquid_prices: Arc<Mutex<(f64, f64)>>,
    
    // Configuration
    pub config: Config,
    pub evaluator: OpportunityEvaluator,
    
    // Trading connectors (only used by cancellation task)
    pub pacifica_trading: Arc<PacificaTrading>,
    pub hyperliquid_trading: Arc<HyperliquidTrading>,
    
    // Channel for cancel requests (decouples hot path from I/O)
    pub cancel_tx: mpsc::Sender<CancelRequest>,
}

impl OrderMonitorService {
    /// Create a new order monitor service with cancellation channel
    pub fn new(
        bot_state: Arc<RwLock<BotState>>,
        atomic_status: Arc<AtomicU8>,
        order_snapshot: Arc<SharedOrderSnapshot>,
        pacifica_prices: Arc<Mutex<(f64, f64)>>,
        hyperliquid_prices: Arc<Mutex<(f64, f64)>>,
        config: Config,
        evaluator: OpportunityEvaluator,
        pacifica_trading: Arc<PacificaTrading>,
        hyperliquid_trading: Arc<HyperliquidTrading>,
    ) -> (Self, mpsc::Receiver<CancelRequest>) {
        // Bounded channel to prevent unbounded growth, but large enough to not block
        let (cancel_tx, cancel_rx) = mpsc::channel(64);
        
        let service = Self {
            bot_state,
            atomic_status,
            order_snapshot,
            pacifica_prices,
            hyperliquid_prices,
            config,
            evaluator,
            pacifica_trading,
            hyperliquid_trading,
            cancel_tx,
        };
        
        (service, cancel_rx)
    }

    /// Main monitoring loop - LATENCY CRITICAL
    /// 
    /// This loop runs at 1kHz and must complete each iteration in <1ms.
    /// All I/O operations are delegated to separate tasks via channels.
    pub async fn run_monitor_loop(&self) {
        let mut monitor_interval = interval(Duration::from_millis(1));
        
        // Timing thresholds
        let age_threshold = Duration::from_secs(self.config.order_refresh_interval_secs);
        let profit_threshold = self.config.profit_cancel_threshold_bps;

        loop {
            monitor_interval.tick().await;

            // FAST PATH: Lock-free status check
            let status = self.atomic_status.load(Ordering::Acquire);
            if status != AtomicBotStatus::OrderPlaced as u8 {
                continue;
            }

            // Get order snapshot (single lock, no clone of complex types)
            let snapshot = match self.order_snapshot.get() {
                Some(s) => s,
                None => continue,
            };

            // Get prices (parking_lot mutex is very fast for uncontended case)
            let (hl_bid, hl_ask) = *self.hyperliquid_prices.lock();
            if hl_bid == 0.0 || hl_ask == 0.0 {
                continue;
            }

            let age = snapshot.placed_at.elapsed();

            // Check 1: Age threshold
            if age > age_threshold {
                // Send cancel request (non-blocking)
                let _ = self.cancel_tx.try_send(CancelRequest::AgeExpiry {
                    symbol: self.config.symbol.clone(),
                    reason: format!("age {}ms > {}s threshold", age.as_millis(), self.config.order_refresh_interval_secs),
                });
                continue;
            }

            // Check 2: Profit deviation (using raw method - no allocation)
            let current_profit = self.evaluator.recalculate_profit_raw(
                snapshot.side,
                snapshot.price,
                hl_bid,
                hl_ask,
            );
            
            // Consistent calculation: positive = profit dropped (bad)
            let profit_change = snapshot.initial_profit_bps - current_profit;
            let profit_deviation = profit_change.abs();

            if profit_deviation > profit_threshold {
                // Send cancel request (non-blocking)
                let _ = self.cancel_tx.try_send(CancelRequest::ProfitDeviation {
                    symbol: self.config.symbol.clone(),
                    current_profit_bps: current_profit,
                    deviation_bps: profit_deviation,
                });
            }
        }
    }

    /// Cancellation handler task - runs separately from hot path
    /// 
    /// Handles all I/O operations: REST API calls, state updates, logging
    pub async fn run_cancellation_handler(
        &self,
        mut cancel_rx: mpsc::Receiver<CancelRequest>,
    ) {
        let mut rate_limit = RateLimitTracker::new();

        while let Some(request) = cancel_rx.recv().await {
            // Check rate limit backoff
            if rate_limit.should_skip() {
                debug!(
                    "[CANCEL] Skipping cancellation (rate limit backoff, {:.1}s remaining)",
                    rate_limit.remaining_backoff_secs()
                );
                continue;
            }

            // Double-check state hasn't changed (order might have filled)
            let status = self.atomic_status.load(Ordering::Acquire);
            if status != AtomicBotStatus::OrderPlaced as u8 {
                debug!("[CANCEL] Skipping - status changed to {}", status);
                continue;
            }

            // Get current snapshot for logging
            let _snapshot = self.order_snapshot.get();

            // Check for partial fills before cancelling
            match self.check_for_fills().await {
                FillCheckResult::HasFills(amount) => {
                    info!(
                        "[CANCEL] Order has fills ({}) - skipping cancellation, waiting for fill detection",
                        amount
                    );
                    continue;
                }
                FillCheckResult::NotFound => {
                    debug!("[CANCEL] Order not in open orders - might be filled/cancelled");
                    continue;
                }
                FillCheckResult::NoFills => {
                    // Safe to proceed with cancellation
                }
                FillCheckResult::CheckFailed(e) => {
                    debug!("[CANCEL] Fill check failed: {} - proceeding with cancellation", e);
                    // Continue with cancellation (safer than leaving hanging orders)
                }
            }

            // Log the cancellation reason
            match &request {
                CancelRequest::AgeExpiry { reason, .. } => {
                    info!("[CANCEL] Age expiry: {}", reason);
                }
                CancelRequest::ProfitDeviation { current_profit_bps, deviation_bps, .. } => {
                    info!(
                        "[CANCEL] Profit deviation: current={:.2} bps, deviation={:.2} bps",
                        current_profit_bps, deviation_bps
                    );
                }
            }

            // Execute cancellation
            let symbol = match &request {
                CancelRequest::AgeExpiry { symbol, .. } => symbol,
                CancelRequest::ProfitDeviation { symbol, .. } => symbol,
            };

            match self.pacifica_trading.cancel_all_orders(false, Some(symbol), false).await {
                Ok(_) => {
                    rate_limit.record_success();
                    
                    // Clear state only if still in OrderPlaced
                    let mut state = self.bot_state.write().await;
                    if matches!(state.status, BotStatus::OrderPlaced) {
                        state.clear_active_order();
                        self.atomic_status.store(AtomicBotStatus::Idle as u8, Ordering::Release);
                        self.order_snapshot.set(None);
                    }
                    drop(state);

                    // Refresh prices in parallel (not blocking the handler)
                    self.refresh_prices_parallel().await;
                }
                Err(e) => {
                    if is_rate_limit_error(&e) {
                        rate_limit.record_error();
                        warn!(
                            "[CANCEL] Rate limit exceeded. Backing off for {}s (attempt #{})",
                            rate_limit.get_backoff_secs(),
                            rate_limit.consecutive_errors()
                        );
                    } else {
                        warn!("[CANCEL] Failed to cancel: {}", e);
                    }
                }
            }
        }
    }

    /// Periodic profit logging task - runs at 0.5 Hz (every 2 seconds)
    pub async fn run_profit_logger(&self) {
        let mut log_interval = interval(Duration::from_secs(2));

        loop {
            log_interval.tick().await;

            // Only log for active orders
            let status = self.atomic_status.load(Ordering::Acquire);
            if status != AtomicBotStatus::OrderPlaced as u8 {
                continue;
            }

            let snapshot = match self.order_snapshot.get() {
                Some(s) => s,
                None => continue,
            };

            let (hl_bid, hl_ask) = *self.hyperliquid_prices.lock();
            if hl_bid == 0.0 || hl_ask == 0.0 {
                continue;
            }

            let current_profit = self.evaluator.recalculate_profit_raw(
                snapshot.side,
                snapshot.price,
                hl_bid,
                hl_ask,
            );
            let profit_change = current_profit - snapshot.initial_profit_bps;
            let age_ms = snapshot.placed_at.elapsed().as_millis();

            let hedge_price = match snapshot.side {
                OrderSide::Buy => hl_bid,
                OrderSide::Sell => hl_ask,
            };

            info!(
                "[PROFIT] Current: {:.2} bps (initial: {:.2}, change: {:+.2}) | PAC: ${:.4} | HL: ${:.4} | Age: {:.3}s",
                current_profit,
                snapshot.initial_profit_bps,
                profit_change,
                snapshot.price,
                hedge_price,
                age_ms as f64 / 1000.0
            );
        }
    }

    /// Check if order has fills (called from cancellation handler, not hot path)
    async fn check_for_fills(&self) -> FillCheckResult {
        // Get client_order_id from full state (only in cancellation handler)
        let state = self.bot_state.read().await;
        let client_order_id = match &state.active_order {
            Some(order) => order.client_order_id.clone(),
            None => return FillCheckResult::NotFound,
        };
        drop(state);

        match self.pacifica_trading.get_open_orders().await {
            Ok(orders) => {
                if let Some(order) = orders.iter().find(|o| o.client_order_id == client_order_id) {
                    let filled_amount: f64 = fast_float::parse(&order.filled_amount).unwrap_or(0.0);
                    if filled_amount > 0.0 {
                        FillCheckResult::HasFills(filled_amount)
                    } else {
                        FillCheckResult::NoFills
                    }
                } else {
                    FillCheckResult::NotFound
                }
            }
            Err(e) => FillCheckResult::CheckFailed(e.to_string()),
        }
    }

    /// Refresh prices from both exchanges in parallel
    async fn refresh_prices_parallel(&self) {
        let pac_future = self.pacifica_trading.get_best_bid_ask_rest(
            &self.config.symbol,
            self.config.agg_level,
        );
        let hl_future = self.hyperliquid_trading.get_l2_snapshot(&self.config.symbol);

        let (pac_result, hl_result) = tokio::join!(pac_future, hl_future);

        if let Ok(Some((bid, ask))) = pac_result {
            *self.pacifica_prices.lock() = (bid, ask);
            debug!("[REFRESH] Pacifica: bid=${:.6}, ask=${:.6}", bid, ask);
        }

        if let Ok(Some((bid, ask))) = hl_result {
            *self.hyperliquid_prices.lock() = (bid, ask);
            debug!("[REFRESH] Hyperliquid: bid=${:.6}, ask=${:.6}", bid, ask);
        }
    }
}

/// Result of checking for partial fills
enum FillCheckResult {
    HasFills(f64),
    NoFills,
    NotFound,
    CheckFailed(String),
}

// ============================================================================
// HELPER: Update atomic status when BotState changes
// ============================================================================

/// Call this whenever BotState.status changes to keep atomic in sync
#[inline]
pub fn sync_atomic_status(atomic: &AtomicU8, status: &BotStatus) {
    let atomic_val = AtomicBotStatus::from(status) as u8;
    atomic.store(atomic_val, Ordering::Release);
}

/// Call this when placing a new order to update snapshot
#[inline]
pub fn update_order_snapshot(
    snapshot: &SharedOrderSnapshot,
    side: OrderSide,
    price: f64,
    size: f64,
    initial_profit_bps: f64,
) {
    snapshot.set(Some(OrderSnapshot {
        side,
        price,
        size,
        initial_profit_bps,
        placed_at: Instant::now(),
    }));
}

// ============================================================================
// STARTUP HELPER
// ============================================================================

/// Spawn all monitor tasks
pub fn spawn_monitor_tasks(service: Arc<OrderMonitorService>, cancel_rx: mpsc::Receiver<CancelRequest>) {
    // Hot path monitor (1kHz)
    let service_clone = Arc::clone(&service);
    tokio::spawn(async move {
        service_clone.run_monitor_loop().await;
    });

    // Cancellation handler (processes cancel requests)
    let service_clone = Arc::clone(&service);
    tokio::spawn(async move {
        service_clone.run_cancellation_handler(cancel_rx).await;
    });

    // Profit logger (0.5 Hz)
    let service_clone = Arc::clone(&service);
    tokio::spawn(async move {
        service_clone.run_profit_logger().await;
    });
}


================================================================================
FILE: src\services\orderbook.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\orderbook.rs
================================================================================

use std::sync::Arc;
use parking_lot::Mutex;
use anyhow::{Context, Result};
use colored::Colorize;
use fast_float::parse;

use crate::connector::pacifica::{OrderbookClient as PacificaOrderbookClient, OrderbookConfig as PacificaOrderbookConfig};
use crate::connector::hyperliquid::{OrderbookClient as HyperliquidOrderbookClient, OrderbookConfig as HyperliquidOrderbookConfig};

// Macro for timestamped colored output
macro_rules! tprintln {
    ($($arg:tt)*) => {{
        println!("{} {}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string().bright_black(),
            format!($($arg)*)
        );
    }};
}

/// Pacifica orderbook service
///
/// Subscribes to Pacifica orderbook WebSocket and updates shared price state.
/// Provides real-time bid/ask prices for opportunity evaluation.
pub struct PacificaOrderbookService {
    pub prices: Arc<Mutex<(f64, f64)>>,
    pub symbol: String,
    pub agg_level: u32,
    pub reconnect_attempts: u32,
    pub ping_interval_secs: u64,
}

impl PacificaOrderbookService {
    pub async fn run(self) -> Result<()> {
        let pac_prices_clone = self.prices.clone();
        let pacifica_ob_config = PacificaOrderbookConfig {
            symbol: self.symbol.clone(),
            agg_level: self.agg_level,
            reconnect_attempts: self.reconnect_attempts,
            ping_interval_secs: self.ping_interval_secs,
        };

        let mut pacifica_ob_client = PacificaOrderbookClient::new(pacifica_ob_config)
            .context("Failed to create Pacifica orderbook client")?;

        tprintln!("{} Starting orderbook client", "[PACIFICA_OB]".magenta().bold());
        pacifica_ob_client
            .start(move |bid, ask, _symbol, _ts| {
                let bid_price: f64 = parse(&bid).unwrap_or(0.0);
                let ask_price: f64 = parse(&ask).unwrap_or(0.0);
                *pac_prices_clone.lock() = (bid_price, ask_price);
            })
            .await
            .ok();

        Ok(())
    }
}

/// Hyperliquid orderbook service
///
/// Subscribes to Hyperliquid orderbook WebSocket and updates shared price state.
/// Provides real-time bid/ask prices for hedge execution.
pub struct HyperliquidOrderbookService {
    pub prices: Arc<Mutex<(f64, f64)>>,
    pub symbol: String,
    pub reconnect_attempts: u32,
    pub ping_interval_secs: u64,
}

impl HyperliquidOrderbookService {
    pub async fn run(self) -> Result<()> {
        let hl_prices_clone = self.prices.clone();
        let hyperliquid_ob_config = HyperliquidOrderbookConfig {
            coin: self.symbol.clone(),
            reconnect_attempts: self.reconnect_attempts,
            ping_interval_secs: self.ping_interval_secs,
        };

        let mut hyperliquid_ob_client = HyperliquidOrderbookClient::new(hyperliquid_ob_config)
            .context("Failed to create Hyperliquid orderbook client")?;

        tprintln!("{} Starting orderbook client", "[HYPERLIQUID_OB]".magenta().bold());
        hyperliquid_ob_client
            .start(move |bid, ask, _coin, _ts| {
                let bid_price: f64 = parse(&bid).unwrap_or(0.0);
                let ask_price: f64 = parse(&ask).unwrap_or(0.0);
                *hl_prices_clone.lock() = (bid_price, ask_price);
            })
            .await
            .ok();

        Ok(())
    }
}


================================================================================
FILE: src\services\position_monitor.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\position_monitor.rs
================================================================================

use std::collections::HashSet;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{mpsc, RwLock};
use tracing::debug;
use colored::Colorize;
use fast_float::parse;
use parking_lot::Mutex;

use crate::app::PositionSnapshot;
use crate::bot::BotState;
use crate::connector::pacifica::{PacificaTrading, PacificaWsTrading};
use crate::services::HedgeEvent;
use crate::strategy::OrderSide;

// Macro for timestamped colored output
macro_rules! tprintln {
    ($($arg:tt)*) => {{
        println!("{} {}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string().bright_black(),
            format!($($arg)*)
        );
    }};
}

/// Position-based fill detection service (4th layer - ground truth)
///
/// Polls Pacifica positions via REST API every 500ms to detect position changes.
/// This is the ultimate fallback - if position changed in the expected direction,
/// a fill definitely occurred regardless of WebSocket/REST/order status detection.
pub struct PositionMonitorService {
    pub bot_state: Arc<RwLock<BotState>>,
    pub hedge_tx: mpsc::UnboundedSender<HedgeEvent>,
    pub pacifica_trading: Arc<PacificaTrading>,
    pub pacifica_ws_trading: Arc<PacificaWsTrading>,
    pub symbol: String,
    pub processed_fills: Arc<Mutex<HashSet<String>>>,
    pub last_position_snapshot: Arc<Mutex<Option<PositionSnapshot>>>,
}

impl PositionMonitorService {
    pub async fn run(self) {
        loop {
            // Adaptive polling: fast when order active, slow when idle
            let has_active_order = {
                let state = self.bot_state.read().await;
                state.has_active_order_fast()
            };

            let poll_ms = if has_active_order { 250 } else { 2000 };
            tokio::time::sleep(Duration::from_millis(poll_ms)).await;

            // Only check if we have an active order
            let active_order_info = {
                let state = self.bot_state.read().await;
                if matches!(
                    state.status,
                    crate::bot::BotStatus::Complete | crate::bot::BotStatus::Error(_)
                ) {
                    continue;
                }

                state.active_order.as_ref().map(|o| (
                    o.client_order_id.clone(),
                    o.side,
                    o.size
                ))
            };

            if active_order_info.is_none() {
                // No active order - update snapshot for next order
                match self.pacifica_trading.get_positions().await {
                    Ok(positions) => {
                        let position = positions.iter().find(|p| p.symbol == self.symbol);
                        let mut snapshot = self.last_position_snapshot.lock();

                        if let Some(pos) = position {
                            let amount: f64 = parse(&pos.amount).unwrap_or(0.0);
                            *snapshot = Some(PositionSnapshot {
                                amount,
                                side: pos.side.clone(),
                                last_check: std::time::Instant::now(),
                            });
                            debug!("[POSITION_MONITOR] Updated baseline: {} {} {}",
                                self.symbol, pos.side, amount);
                        } else {
                            *snapshot = None;
                            debug!("[POSITION_MONITOR] No position for {}", self.symbol);
                        }
                    }
                    Err(e) => {
                        debug!("[POSITION_MONITOR] Failed to fetch baseline position: {}", e);
                    }
                }
                continue;
            }

            let (client_order_id, order_side, _order_size) = active_order_info.unwrap();

            // Fetch current positions
            let positions_result = self.pacifica_trading.get_positions().await;

            match positions_result {
                Ok(positions) => {
                    let current_position = positions.iter().find(|p| p.symbol == self.symbol);
                    let last_snapshot = self.last_position_snapshot.lock().clone();

                    // Calculate position delta
                    let (last_amount, last_side) = if let Some(ref snap) = last_snapshot {
                        (snap.amount, snap.side.clone())
                    } else {
                        (0.0, "none".to_string())
                    };

                    let (current_amount, current_side) = if let Some(pos) = current_position {
                        (pos.amount.parse::<f64>().unwrap_or(0.0), pos.side.clone())
                    } else {
                        (0.0, "none".to_string())
                    };

                    // Convert to signed position for delta calculation
                    let last_signed = match last_side.as_str() {
                        "bid" => last_amount,
                        "ask" => -last_amount,
                        _ => 0.0,
                    };

                    let current_signed = match current_side.as_str() {
                        "bid" => current_amount,
                        "ask" => -current_amount,
                        _ => 0.0,
                    };

                    let delta = current_signed - last_signed;

                    // Check if delta matches our order direction
                    let delta_matches_order = (delta > 0.0 && matches!(order_side, OrderSide::Buy))
                        || (delta < 0.0 && matches!(order_side, OrderSide::Sell));

                    // If delta is significant and matches order direction
                    if delta.abs() > 0.0001 && delta_matches_order {
                        // Position changed in expected direction - fill detected!
                        let fill_size = delta.abs();

                        tprintln!(
                            "{} {} Position delta detected: {} {} → {} {} (Δ {:.4})",
                            "[POSITION_MONITOR]".bright_cyan().bold(),
                            "⚡".yellow().bold(),
                            format!("{:.4}", last_signed).bright_white(),
                            last_side.yellow(),
                            format!("{:.4}", current_signed).bright_white(),
                            current_side.yellow(),
                            format!("{:.4}", delta.abs()).green().bold()
                        );

                        // CRITICAL FIX: Skip if this is first position change from None baseline (startup)
                        // This prevents hedging the bot's first order fill which establishes initial position
                        if last_snapshot.is_none() && last_signed.abs() < 0.0001 {
                            tprintln!(
                                "{} {} Skipping hedge for first position change from baseline (startup initialization)",
                                "[POSITION_MONITOR]".bright_cyan().bold(),
                                "ℹ".blue().bold()
                            );

                            // Update snapshot to prevent continuous detection
                            let mut snapshot = self.last_position_snapshot.lock();
                            *snapshot = Some(PositionSnapshot {
                                amount: current_amount,
                                side: current_side,
                                last_check: std::time::Instant::now(),
                            });
                            continue;
                        }

                        // Check bot state - don't trigger duplicate hedges
                        let current_state = {
                            let state = self.bot_state.read().await;
                            state.status.clone()
                        };

                        // Skip if already filled, hedging, or complete
                        if matches!(
                            current_state,
                            crate::bot::BotStatus::Filled |
                            crate::bot::BotStatus::Hedging |
                            crate::bot::BotStatus::Complete
                        ) {
                            tprintln!(
                                "{} {} Fill already handled by primary detection (state: {:?}), skipping duplicate hedge",
                                "[POSITION_MONITOR]".bright_cyan().bold(),
                                "ℹ".blue().bold(),
                                current_state
                            );

                            // Update snapshot to prevent continuous detection
                            let mut snapshot = self.last_position_snapshot.lock();
                            *snapshot = Some(PositionSnapshot {
                                amount: current_amount,
                                side: current_side,
                                last_check: std::time::Instant::now(),
                            });
                            continue;
                        }

                        // Check if already processed - use consistent fill_id format with WebSocket detection
                        let fill_id = format!("full_{}", client_order_id);
                        let should_process = {
                            let mut processed = self.processed_fills.lock();
                            if !processed.contains(&fill_id) {
                                processed.insert(fill_id.clone());
                                true
                            } else {
                                false
                            }
                        }; // MutexGuard is dropped here

                        if should_process {
                            tprintln!(
                                "{} {} FILL DETECTED via position change!",
                                "[POSITION_MONITOR]".bright_cyan().bold(),
                                "✓".green().bold()
                            );

                            // Update state to Filled
                            {
                                let mut state = self.bot_state.write().await;
                                state.mark_filled(fill_size, order_side);
                            }

                            // Dual cancellation
                            tprintln!("{} {} Dual cancellation (REST + WebSocket)...",
                                "[POSITION_MONITOR]".bright_cyan().bold(),
                                "⚡".yellow().bold()
                            );

                            let rest_result = self.pacifica_trading
                                .cancel_all_orders(false, Some(&self.symbol), false)
                                .await;

                            match rest_result {
                                Ok(count) => {
                                    tprintln!("{} {} REST API cancelled {} order(s)",
                                        "[POSITION_MONITOR]".bright_cyan().bold(),
                                        "✓".green().bold(),
                                        count
                                    );
                                }
                                Err(e) => {
                                    tprintln!("{} {} REST API cancel failed: {}",
                                        "[POSITION_MONITOR]".bright_cyan().bold(),
                                        "⚠".yellow().bold(),
                                        e
                                    );
                                }
                            }

                            let ws_result = self.pacifica_ws_trading
                                .cancel_all_orders_ws(false, Some(&self.symbol), false)
                                .await;

                            match ws_result {
                                Ok(count) => {
                                    tprintln!("{} {} WebSocket cancelled {} order(s)",
                                        "[POSITION_MONITOR]".bright_cyan().bold(),
                                        "✓".green().bold(),
                                        count
                                    );
                                }
                                Err(e) => {
                                    tprintln!("{} {} WebSocket cancel failed: {}",
                                        "[POSITION_MONITOR]".bright_cyan().bold(),
                                        "⚠".yellow().bold(),
                                        e
                                    );
                                }
                            }

                            // Estimate fill price (use current entry price or mid)
                            let estimated_price = current_position
                                .and_then(|p| p.entry_price.parse::<f64>().ok())
                                .unwrap_or(0.0);

                            tprintln!("{} Triggering hedge for position-detected fill",
                                "[POSITION_MONITOR]".bright_cyan().bold()
                            );

                            // Trigger hedge (with current timestamp since position monitor detects fills retroactively)
                            let _ = self.hedge_tx.send((order_side, fill_size, estimated_price, std::time::Instant::now()));
                        } else {
                            debug!("[POSITION_MONITOR] Fill already processed by another detection method");
                        }

                        // Update snapshot
                        let mut snapshot = self.last_position_snapshot.lock();
                        *snapshot = Some(PositionSnapshot {
                            amount: current_amount,
                            side: current_side,
                            last_check: std::time::Instant::now(),
                        });
                    }
                }
                Err(e) => {
                    debug!("[POSITION_MONITOR] Failed to fetch positions: {}", e);
                }
            }
        }
    }
}


================================================================================
FILE: src\services\rest_fill_detection.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\rest_fill_detection.rs
================================================================================

use std::collections::HashSet;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::{mpsc, RwLock};
use tracing::debug;
use colored::Colorize;
use fast_float::parse;

use crate::bot::BotState;
use crate::connector::pacifica::{PacificaTrading, PacificaWsTrading};
use crate::services::HedgeEvent;
use crate::strategy::OrderSide;
use crate::util::cancel::dual_cancel;
use crate::util::rate_limit::is_rate_limit_error;

// Macro for timestamped colored output
macro_rules! tprintln {
    ($($arg:tt)*) => {{
        println!("{} {}",
            chrono::Utc::now().format("%Y-%m-%dT%H:%M:%S%.6fZ").to_string().bright_black(),
            format!($($arg)*)
        );
    }};
}

/// REST API fill detection service (backup/fallback method)
///
/// Polls open_orders via REST API every 500ms to detect fills that may have been
/// missed by WebSocket. This provides redundancy and recovery capabilities.
pub struct RestFillDetectionService {
    pub bot_state: Arc<RwLock<BotState>>,
    pub hedge_tx: mpsc::UnboundedSender<HedgeEvent>,
    pub pacifica_trading: Arc<PacificaTrading>,
    pub pacifica_ws_trading: Arc<PacificaWsTrading>,
    pub symbol: String,
    pub processed_fills: Arc<parking_lot::Mutex<HashSet<String>>>,
    pub min_hedge_notional: f64,
    pub poll_interval_ms: u64,
}

impl RestFillDetectionService {
    pub async fn run(self) {
        let mut consecutive_errors = 0u32;
        let mut last_known_filled_amount: f64 = 0.0;

        loop {
            // Adaptive polling: fast when order active, slow when idle
            let has_active_order = {
                let state = self.bot_state.read().await;
                state.has_active_order_fast() || matches!(state.status, crate::bot::BotStatus::Filled | crate::bot::BotStatus::Hedging)
            };

            let poll_ms = if has_active_order { self.poll_interval_ms } else { 1000 };
            tokio::time::sleep(Duration::from_millis(poll_ms)).await;

            // Get active order info, with recovery logic for recent cancellations
            let active_order_info = {
                let state = self.bot_state.read().await;

                // Skip only for terminal states
                if matches!(
                    state.status,
                    crate::bot::BotStatus::Complete | crate::bot::BotStatus::Error(_)
                ) {
                    tokio::time::sleep(Duration::from_secs(1)).await;
                    continue;
                }

                if let Some(ref order) = state.active_order {
                    Some((order.client_order_id.clone(), order.side))
                } else {
                    // No active order - check if this is a recent cancellation
                    if matches!(state.status, crate::bot::BotStatus::Filled | crate::bot::BotStatus::Hedging) {
                        // Recent fill/hedge - keep polling briefly for catch-up
                        None // Will query all open orders below
                    } else {
                        // Old cancellation, truly idle
                        last_known_filled_amount = 0.0;
                        continue;
                    }
                }
            };

            let client_order_id_opt = active_order_info.as_ref().map(|(id, _)| id.clone());
            let order_side_opt = active_order_info.as_ref().map(|(_, side)| *side);

            // Fetch open orders via REST API
            let open_orders_result = self.pacifica_trading.get_open_orders().await;

            match open_orders_result {
                Ok(orders) => {
                    consecutive_errors = 0; // Reset error counter on success

                    // Find our order - either by client_order_id or any filled order in recovery mode
                    let our_order = if let Some(ref cloid) = client_order_id_opt {
                        // Normal mode: Find by client_order_id
                        orders.iter().find(|o| &o.client_order_id == cloid)
                    } else {
                        // Recovery mode: Find any order with fills for our symbol
                        debug!(
                            "[REST_FILL_DETECTION] Recovery mode: searching {} orders for filled orders",
                            orders.len()
                        );
                        orders.iter().filter(|o| o.symbol == self.symbol).find(|o| {
                            let filled: f64 = parse(&o.filled_amount).unwrap_or(0.0);
                            filled > 0.0
                        })
                    };

                    if let Some(order) = our_order {
                        let filled_amount: f64 = parse(&order.filled_amount).unwrap_or(0.0);
                        let initial_amount: f64 = parse(&order.initial_amount).unwrap_or(0.0);
                        let price: f64 = parse(&order.price).unwrap_or(0.0);

                        // Check if there's a NEW fill (filled_amount increased since last check)
                        if filled_amount > last_known_filled_amount && filled_amount > 0.0 {
                            let new_fill_amount = filled_amount - last_known_filled_amount;
                            let notional_value = new_fill_amount * price;

                            debug!(
                                "[REST_FILL_DETECTION] Fill detected: {} -> {} (new: {}) | Notional: ${:.2}",
                                last_known_filled_amount, filled_amount, new_fill_amount, notional_value
                            );

                            // Update last known amount
                            last_known_filled_amount = filled_amount;

                            // Check if this is a full fill or significant partial fill
                            let is_full_fill = (filled_amount - initial_amount).abs() < 0.0001;

                            if is_full_fill || notional_value > self.min_hedge_notional {
                                let fill_type = if is_full_fill { "full" } else { "partial" };
                                let cloid = &order.client_order_id;
                                let fill_id = format!("{}_{}_rest", fill_type, cloid);

                                // Check if already processed (prevent duplicate hedges from WebSocket)
                                let mut processed = self.processed_fills.lock();
                                if processed.contains(&fill_id)
                                    || processed.contains(&format!("full_{}", cloid))
                                    || processed.contains(&format!("partial_{}", cloid))
                                {
                                    debug!("[REST_FILL_DETECTION] Fill already processed by WebSocket, skipping");
                                    continue;
                                }
                                processed.insert(fill_id);
                                drop(processed);

                                // Determine order side from order data or state
                                let order_side = if let Some(side) = order_side_opt {
                                    side
                                } else {
                                    // Recovery mode: parse from order.side string
                                    match order.side.as_str() {
                                        "bid" | "buy" => OrderSide::Buy,
                                        "ask" | "sell" => OrderSide::Sell,
                                        _ => {
                                            debug!(
                                                "[REST_FILL_DETECTION] Unknown order side: {}, skipping",
                                                order.side
                                            );
                                            continue;
                                        }
                                    }
                                };

                                tprintln!(
                                    "{} {} {} FILL: {} {} {} @ {} | Filled: {} / {} | Notional: {} {}",
                                    "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                    "✓".green().bold(),
                                    if is_full_fill { "FULL" } else { "PARTIAL" },
                                    order.side.bright_yellow(),
                                    filled_amount,
                                    self.symbol.bright_white().bold(),
                                    format!("${:.6}", price).cyan(),
                                    filled_amount,
                                    initial_amount,
                                    format!("${:.2}", notional_value).cyan().bold(),
                                    "(REST API)".bright_black()
                                );

                                // Trigger hedge (same flow as WebSocket)
                                let bot_state_clone = self.bot_state.clone();
                                let hedge_tx_clone = self.hedge_tx.clone();
                                let pac_trading_clone = self.pacifica_trading.clone();
                                let pac_ws_trading_clone = self.pacifica_ws_trading.clone();
                                let symbol_clone = self.symbol.clone();

                                tokio::spawn(async move {
                                    // Update state
                                    {
                                        let mut state = bot_state_clone.write().await;
                                        state.mark_filled(filled_amount, order_side);
                                    }

                                    tprintln!(
                                        "{} {} State updated to Filled (REST)",
                                        "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                        "✓".green().bold()
                                    );

                                    // Dual cancellation
                                    tprintln!(
                                        "{} {} Dual cancellation (REST + WebSocket)...",
                                        "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                        "⚡".yellow().bold()
                                    );

                                    match dual_cancel(&pac_trading_clone, &pac_ws_trading_clone, &symbol_clone).await
                                    {
                                        Ok((rest_count, ws_count)) => {
                                            tprintln!(
                                                "{} {} Dual cancellation complete (REST: {}, WS: {})",
                                                "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                                "✓✓".green().bold(),
                                                rest_count,
                                                ws_count
                                            );
                                        }
                                        Err(e) => {
                                            tprintln!(
                                                "{} {} Dual cancellation failed: {}",
                                                "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                                "✗".red().bold(),
                                                e
                                            );
                                        }
                                    }

                                    tprintln!(
                                        "{} {}, triggering hedge (REST)",
                                        format!("[{}]", symbol_clone).bright_white().bold(),
                                        "Order filled".green().bold()
                                    );

                                    // Trigger hedge (with current timestamp since REST detection detects fills retroactively)
                                    let _ = hedge_tx_clone.send((order_side, filled_amount, price, std::time::Instant::now()));
                                });
                            } else {
                                debug!(
                                    "[REST_FILL_DETECTION] Fill notional ${:.2} < ${:.2} threshold, skipping",
                                    notional_value, self.min_hedge_notional
                                );
                            }
                        }
                    } else if client_order_id_opt.is_some() {
                        // Order not found but we expect it - might be filled and removed
                        debug!("[REST_FILL_DETECTION] Active order not found in open_orders (might be fully filled)");
                    }
                }
                Err(e) => {
                    consecutive_errors += 1;

                    // Check if it's a rate limit error
                    let is_rate_limit = is_rate_limit_error(&e);

                    if is_rate_limit {
                        // Exponential backoff for rate limits: 1s, 2s, 4s, 8s, 16s, 32s (max)
                        let backoff_secs = std::cmp::min(2u64.pow(consecutive_errors - 1), 32);
                        tprintln!(
                            "{} {} Rate limit hit, backing off for {} seconds...",
                            "[REST_FILL_DETECTION]".bright_cyan().bold(),
                            "⚠".yellow().bold(),
                            backoff_secs
                        );
                        tokio::time::sleep(Duration::from_secs(backoff_secs)).await;
                    } else {
                        // Other errors: log and continue with normal polling
                        debug!(
                            "[REST_FILL_DETECTION] Error fetching open orders (attempt {}): {}",
                            consecutive_errors, e
                        );

                        // If too many consecutive errors, log warning
                        if consecutive_errors >= 5 {
                            tprintln!(
                                "{} {} {} consecutive errors fetching open orders",
                                "[REST_FILL_DETECTION]".bright_cyan().bold(),
                                "⚠".yellow().bold(),
                                consecutive_errors
                            );
                        }
                    }
                }
            }
        }
    }
}


================================================================================
FILE: src\services\rest_poll.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\services\rest_poll.rs
================================================================================

use std::sync::Arc;
use parking_lot::Mutex;
use std::time::Duration;
use tokio::time::interval;
use tracing::debug;

use crate::connector::hyperliquid::HyperliquidTrading;
use crate::connector::pacifica::PacificaTrading;

/// Pacifica REST API polling service
///
/// Complements WebSocket orderbook by polling REST API periodically.
/// Provides redundancy if WebSocket connection is lost or delayed.
/// Updates shared price state at configured interval.
pub struct PacificaRestPollService {
    pub prices: Arc<Mutex<(f64, f64)>>,
    pub pacifica_trading: Arc<PacificaTrading>,
    pub symbol: String,
    pub agg_level: u32,
    pub poll_interval_secs: u64,
}

impl PacificaRestPollService {
    pub async fn run(self) {
        let mut interval_timer = interval(Duration::from_secs(self.poll_interval_secs));
        interval_timer.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

        loop {
            interval_timer.tick().await;

            match self.pacifica_trading.get_best_bid_ask_rest(&self.symbol, self.agg_level).await {
                Ok(Some((bid, ask))) => {
                    // Update shared orderbook prices
                    *self.prices.lock() = (bid, ask);
                    debug!(
                        "[PACIFICA_REST] Updated prices via REST: bid=${:.4}, ask=${:.4}",
                        bid, ask
                    );
                }
                Ok(None) => {
                    debug!("[PACIFICA_REST] No bid/ask available from REST API");
                }
                Err(e) => {
                    debug!("[PACIFICA_REST] Failed to fetch prices: {}", e);
                }
            }
        }
    }
}

/// Hyperliquid REST API polling service
///
/// Complements WebSocket orderbook by polling REST API periodically.
/// Provides redundancy if WebSocket connection is lost or delayed.
/// Updates shared price state at configured interval (typically 2s).
pub struct HyperliquidRestPollService {
    pub prices: Arc<Mutex<(f64, f64)>>,
    pub hyperliquid_trading: Arc<HyperliquidTrading>,
    pub symbol: String,
    pub poll_interval_secs: u64,
}

impl HyperliquidRestPollService {
    pub async fn run(self) {
        let mut interval_timer = interval(Duration::from_secs(self.poll_interval_secs));
        interval_timer.set_missed_tick_behavior(tokio::time::MissedTickBehavior::Skip);

        loop {
            interval_timer.tick().await;

            match self.hyperliquid_trading.get_l2_snapshot(&self.symbol).await {
                Ok(Some((bid, ask))) => {
                    // Update shared orderbook prices
                    *self.prices.lock() = (bid, ask);
                    debug!(
                        "[HYPERLIQUID_REST] Updated prices via REST: bid=${:.4}, ask=${:.4}",
                        bid, ask
                    );
                }
                Ok(None) => {
                    debug!("[HYPERLIQUID_REST] No bid/ask available from REST API");
                }
                Err(e) => {
                    debug!("[HYPERLIQUID_REST] Failed to fetch prices: {}", e);
                }
            }
        }
    }
}


================================================================================
FILE: src\strategy\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\strategy\mod.rs
================================================================================

pub mod opportunity;

pub use opportunity::{Opportunity, OpportunityEvaluator, OrderSide};


================================================================================
FILE: src\strategy\opportunity.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\strategy\opportunity.rs
================================================================================

/// Order side (Buy or Sell)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum OrderSide {
    Buy = 0,
    Sell = 1,
}

/// Trading opportunity with calculated parameters
#[derive(Debug, Clone)]
pub struct Opportunity {
    /// Direction of the Pacifica order
    pub direction: OrderSide,
    /// Limit price for Pacifica order
    pub pacifica_price: f64,
    /// Expected hedge price on Hyperliquid
    pub hyperliquid_price: f64,
    /// Order size in base currency
    pub size: f64,
    /// Calculated profit in basis points
    pub initial_profit_bps: f64,
    /// Timestamp when opportunity was evaluated (milliseconds)
    pub timestamp: u64,
}

/// Precomputed fee factors to avoid repeated calculations
#[derive(Debug, Clone, Copy)]
struct FeeFactors {
    /// 1.0 + maker_fee
    one_plus_maker: f64,
    /// 1.0 - maker_fee
    one_minus_maker: f64,
    /// 1.0 + taker_fee
    one_plus_taker: f64,
    /// 1.0 - taker_fee
    one_minus_taker: f64,
    /// 1.0 + maker_fee + profit_rate (buy denominator)
    buy_denominator: f64,
    /// 1.0 - maker_fee - profit_rate (sell denominator)
    sell_denominator: f64,
}

/// Opportunity evaluator for XEMM strategy
#[derive(Debug, Clone)]
pub struct OpportunityEvaluator {
    /// Pacifica maker fee (as decimal, e.g., 0.0001 for 1 bps)
    maker_fee: f64,
    /// Hyperliquid taker fee (as decimal, e.g., 0.00025 for 2.5 bps)
    taker_fee: f64,
    /// Target profit rate (as decimal, e.g., 0.001 for 10 bps)
    profit_rate: f64,
    /// Pacifica tick size (minimum price increment)
    pacifica_tick_size: f64,
    /// Inverse tick size for faster division
    inv_tick_size: f64,
    /// Precomputed fee factors
    fee_factors: FeeFactors,
}

impl OpportunityEvaluator {
    /// Create a new opportunity evaluator
    ///
    /// # Arguments
    /// * `maker_fee_bps` - Pacifica maker fee in basis points (e.g., 1.0 = 0.01%)
    /// * `taker_fee_bps` - Hyperliquid taker fee in basis points (e.g., 2.5 = 0.025%)
    /// * `profit_rate_bps` - Target profit in basis points (e.g., 10.0 = 0.1%)
    /// * `pacifica_tick_size` - Minimum price increment on Pacifica
    pub fn new(
        maker_fee_bps: f64,
        taker_fee_bps: f64,
        profit_rate_bps: f64,
        pacifica_tick_size: f64,
    ) -> Self {
        let maker_fee = maker_fee_bps * 0.0001; // Multiply instead of divide
        let taker_fee = taker_fee_bps * 0.0001;
        let profit_rate = profit_rate_bps * 0.0001;

        let fee_factors = FeeFactors {
            one_plus_maker: 1.0 + maker_fee,
            one_minus_maker: 1.0 - maker_fee,
            one_plus_taker: 1.0 + taker_fee,
            one_minus_taker: 1.0 - taker_fee,
            buy_denominator: 1.0 + maker_fee + profit_rate,
            sell_denominator: 1.0 - maker_fee - profit_rate,
        };

        Self {
            maker_fee,
            taker_fee,
            profit_rate,
            pacifica_tick_size,
            inv_tick_size: 1.0 / pacifica_tick_size, // Precompute for faster rounding
            fee_factors,
        }
    }

    /// Evaluate BUY opportunity on Pacifica
    ///
    /// Strategy: BUY on Pacifica → SELL (taker) on Hyperliquid
    ///
    /// # Arguments
    /// * `hl_bid` - Current Hyperliquid best bid
    /// * `notional_usd` - Notional order size in USD
    /// * `timestamp_ms` - Current timestamp in milliseconds (pass from caller to avoid syscall)
    ///
    /// # Returns
    /// Some(Opportunity) if profitable, None otherwise
    #[inline]
    pub fn evaluate_buy_opportunity(
        &self,
        hl_bid: f64,
        notional_usd: f64,
        timestamp_ms: u64,
    ) -> Option<Opportunity> {
        // Calculate ideal limit price using precomputed factors
        // buy_limit_price = (HL_bid * (1 - takerFee)) / (1 + makerFee + profitRate)
        let buy_limit_price = (hl_bid * self.fee_factors.one_minus_taker) / self.fee_factors.buy_denominator;

        // Round DOWN to tick (conservative for buy)
        let buy_limit_rounded = self.round_price_down(buy_limit_price);

        // Calculate order size from notional
        let size = notional_usd / buy_limit_rounded;

        // Calculate actual profit after rounding (in bps)
        let buy_cost = buy_limit_rounded * self.fee_factors.one_plus_maker;
        let buy_revenue = hl_bid * self.fee_factors.one_minus_taker;
        let buy_profit_bps = ((buy_revenue - buy_cost) / buy_cost) * 10000.0;

        // Only return if profitable
        if buy_profit_bps > 0.0 {
            Some(Opportunity {
                direction: OrderSide::Buy,
                pacifica_price: buy_limit_rounded,
                hyperliquid_price: hl_bid,
                size,
                initial_profit_bps: buy_profit_bps,
                timestamp: timestamp_ms,
            })
        } else {
            None
        }
    }

    /// Evaluate SELL opportunity on Pacifica
    ///
    /// Strategy: SELL on Pacifica → BUY (taker) on Hyperliquid
    ///
    /// # Arguments
    /// * `hl_ask` - Current Hyperliquid best ask
    /// * `notional_usd` - Notional order size in USD
    /// * `timestamp_ms` - Current timestamp in milliseconds (pass from caller to avoid syscall)
    ///
    /// # Returns
    /// Some(Opportunity) if profitable, None otherwise
    #[inline]
    pub fn evaluate_sell_opportunity(
        &self,
        hl_ask: f64,
        notional_usd: f64,
        timestamp_ms: u64,
    ) -> Option<Opportunity> {
        // Calculate ideal limit price using precomputed factors
        // sell_limit_price = (HL_ask * (1 + takerFee)) / (1 - makerFee - profitRate)
        let sell_limit_price = (hl_ask * self.fee_factors.one_plus_taker) / self.fee_factors.sell_denominator;

        // Round UP to tick (conservative for sell)
        let sell_limit_rounded = self.round_price_up(sell_limit_price);

        // Calculate order size from notional
        let size = notional_usd / sell_limit_rounded;

        // Calculate actual profit after rounding (in bps)
        let sell_revenue = sell_limit_rounded * self.fee_factors.one_minus_maker;
        let sell_cost = hl_ask * self.fee_factors.one_plus_taker;
        let sell_profit_bps = ((sell_revenue - sell_cost) / sell_cost) * 10000.0;

        // Only return if profitable
        if sell_profit_bps > 0.0 {
            Some(Opportunity {
                direction: OrderSide::Sell,
                pacifica_price: sell_limit_rounded,
                hyperliquid_price: hl_ask,
                size,
                initial_profit_bps: sell_profit_bps,
                timestamp: timestamp_ms,
            })
        } else {
            None
        }
    }

    /// Recalculate profit for an existing opportunity based on current market prices
    ///
    /// Used for monitoring if the opportunity is still profitable
    ///
    /// # Arguments
    /// * `opportunity` - The original opportunity
    /// * `current_hl_bid` - Current Hyperliquid best bid
    /// * `current_hl_ask` - Current Hyperliquid best ask
    ///
    /// # Returns
    /// Current profit in basis points
    #[inline]
    pub fn recalculate_profit(
        &self,
        opportunity: &Opportunity,
        current_hl_bid: f64,
        current_hl_ask: f64,
    ) -> f64 {
        self.recalculate_profit_raw(
            opportunity.direction,
            opportunity.pacifica_price,
            current_hl_bid,
            current_hl_ask,
        )
    }

    /// Recalculate profit without requiring an Opportunity struct
    ///
    /// Avoids temporary allocations in hot paths
    ///
    /// # Arguments
    /// * `direction` - Order direction (Buy or Sell)
    /// * `pacifica_price` - The Pacifica limit price
    /// * `current_hl_bid` - Current Hyperliquid best bid
    /// * `current_hl_ask` - Current Hyperliquid best ask
    ///
    /// # Returns
    /// Current profit in basis points
    #[inline(always)]
    pub fn recalculate_profit_raw(
        &self,
        direction: OrderSide,
        pacifica_price: f64,
        current_hl_bid: f64,
        current_hl_ask: f64,
    ) -> f64 {
        match direction {
            OrderSide::Buy => {
                // BUY on Pacifica (at pacifica_price) → SELL on Hyperliquid (at current_hl_bid)
                let buy_cost = pacifica_price * self.fee_factors.one_plus_maker;
                let buy_revenue = current_hl_bid * self.fee_factors.one_minus_taker;
                ((buy_revenue - buy_cost) / buy_cost) * 10000.0
            }
            OrderSide::Sell => {
                // SELL on Pacifica (at pacifica_price) → BUY on Hyperliquid (at current_hl_ask)
                let sell_revenue = pacifica_price * self.fee_factors.one_minus_maker;
                let sell_cost = current_hl_ask * self.fee_factors.one_plus_taker;
                ((sell_revenue - sell_cost) / sell_cost) * 10000.0
            }
        }
    }

    /// Pick the best opportunity from two options
    ///
    /// Chooses the one closer to mid price, or with higher profit if equidistant
    ///
    /// # Arguments
    /// * `buy_opp` - Buy opportunity (if any)
    /// * `sell_opp` - Sell opportunity (if any)
    /// * `pac_mid` - Pacifica mid price
    ///
    /// # Returns
    /// The best opportunity, or None if both are None
    #[inline]
    pub fn pick_best_opportunity(
        buy_opp: Option<Opportunity>,
        sell_opp: Option<Opportunity>,
        pac_mid: f64,
    ) -> Option<Opportunity> {
        match (buy_opp, sell_opp) {
            (Some(buy), Some(sell)) => {
                // Calculate distance from mid price
                let buy_distance = (pac_mid - buy.pacifica_price).abs();
                let sell_distance = (sell.pacifica_price - pac_mid).abs();

                // Choose the one closer to mid price
                if buy_distance < sell_distance {
                    Some(buy)
                } else if sell_distance < buy_distance {
                    Some(sell)
                } else {
                    // If equidistant, choose the one with higher profit
                    if buy.initial_profit_bps > sell.initial_profit_bps {
                        Some(buy)
                    } else {
                        Some(sell)
                    }
                }
            }
            (Some(buy), None) => Some(buy),
            (None, Some(sell)) => Some(sell),
            (None, None) => None,
        }
    }

    /// Round price down to nearest tick size (for BUY orders)
    #[inline(always)]
    fn round_price_down(&self, price: f64) -> f64 {
        (price * self.inv_tick_size).floor() * self.pacifica_tick_size
    }

    /// Round price up to nearest tick size (for SELL orders)
    #[inline(always)]
    fn round_price_up(&self, price: f64) -> f64 {
        (price * self.inv_tick_size).ceil() * self.pacifica_tick_size
    }
}

impl OrderSide {
    /// Convert to string representation
    #[inline(always)]
    pub const fn as_str(&self) -> &'static str {
        match self {
            OrderSide::Buy => "BUY",
            OrderSide::Sell => "SELL",
        }
    }

    /// Get opposite side (for hedging)
    #[inline(always)]
    pub const fn opposite(&self) -> OrderSide {
        match self {
            OrderSide::Buy => OrderSide::Sell,
            OrderSide::Sell => OrderSide::Buy,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fee_factors_precomputation() {
        let evaluator = OpportunityEvaluator::new(1.0, 2.5, 10.0, 0.01);
        
        // Verify precomputed factors
        assert!((evaluator.fee_factors.one_plus_maker - 1.0001).abs() < 1e-10);
        assert!((evaluator.fee_factors.one_minus_taker - 0.99975).abs() < 1e-10);
    }

    #[test]
    fn test_recalculate_profit_raw_matches_struct_version() {
        let evaluator = OpportunityEvaluator::new(1.0, 2.5, 10.0, 0.01);
        
        let opp = Opportunity {
            direction: OrderSide::Buy,
            pacifica_price: 100.0,
            hyperliquid_price: 100.5,
            size: 1.0,
            initial_profit_bps: 5.0,
            timestamp: 0,
        };
        
        let hl_bid = 100.3;
        let hl_ask = 100.4;
        
        let profit_struct = evaluator.recalculate_profit(&opp, hl_bid, hl_ask);
        let profit_raw = evaluator.recalculate_profit_raw(
            opp.direction,
            opp.pacifica_price,
            hl_bid,
            hl_ask,
        );
        
        assert!((profit_struct - profit_raw).abs() < 1e-10);
    }
}


================================================================================
FILE: src\trade_fetcher.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\trade_fetcher.rs
================================================================================

/// Trade fetching and profit calculation utilities
///
/// This module contains the logic for fetching actual trade fills from
/// both exchanges after a hedge execution. This is used by the main bot
/// for profit calculation and can be tested independently.

use std::sync::Arc;
use std::time::Duration;

use crate::connector::pacifica::trading::{PacificaTrading, TradeHistoryItem};
use crate::connector::hyperliquid::trading::HyperliquidTrading;
use crate::connector::hyperliquid::types::UserFill;

/// Result of fetching trade data from an exchange
#[derive(Debug, Clone)]
pub struct TradeFetchResult {
    pub fill_price: Option<f64>,
    pub actual_fee: Option<f64>,
    pub total_size: Option<f64>,
    pub total_notional: Option<f64>,  // Actual total USD value from all fills
}

/// Result of profit calculation
#[derive(Debug, Clone)]
pub struct ProfitResult {
    pub gross_pnl: f64,
    pub net_profit: f64,
    pub profit_bps: f64,
    pub pac_fee: f64,
    pub hl_fee: f64,
}

/// Calculate profit from hedge trade using actual notional values
///
/// # Arguments
/// * `pac_notional` - Actual USD notional value from Pacifica
/// * `hl_notional` - Actual USD notional value from Hyperliquid
/// * `pac_fee` - Actual fee paid on Pacifica
/// * `hl_fee` - Actual fee paid on Hyperliquid
/// * `is_pacifica_buy` - True if bought on Pacifica, false if sold
///
/// # Returns
/// ProfitResult with gross P&L, net profit, and profit in basis points
pub fn calculate_hedge_profit(
    pac_notional: f64,
    hl_notional: f64,
    pac_fee: f64,
    hl_fee: f64,
    is_pacifica_buy: bool,
) -> ProfitResult {
    // Calculate gross P&L based on direction
    let gross_pnl = if is_pacifica_buy {
        // Bought on Pacifica, sold on Hyperliquid
        hl_notional - pac_notional
    } else {
        // Sold on Pacifica, bought on Hyperliquid
        pac_notional - hl_notional
    };

    // Calculate net profit after fees
    let net_profit = gross_pnl - pac_fee - hl_fee;

    // Calculate profit in basis points (based on Pacifica notional)
    let profit_bps = if pac_notional > 0.0 {
        (net_profit / pac_notional) * 10000.0
    } else {
        0.0
    };

    ProfitResult {
        gross_pnl,
        net_profit,
        profit_bps,
        pac_fee,
        hl_fee,
    }
}

/// Fetch Pacifica trade history with retry logic
///
/// Attempts to find trades matching the given client_order_id.
/// Retries up to max_attempts times with 10-second delays between attempts.
///
/// Returns: (fill_price, actual_fee)
pub async fn fetch_pacifica_trade(
    trading: Arc<PacificaTrading>,
    symbol: &str,
    client_order_id: &str,
    max_attempts: u32,
    log_fn: impl Fn(&str),
) -> TradeFetchResult {
    let mut attempt = 1;
    let mut result = TradeFetchResult {
        fill_price: None,
        actual_fee: None,
        total_size: None,
        total_notional: None,
    };

    while attempt <= max_attempts {
        log_fn(&format!(
            "Fetching Pacifica trade history (attempt {}/{})",
            attempt, max_attempts
        ));

        match trading
            .get_trade_history(Some(symbol), Some(20), None, None)
            .await
        {
            Ok(trades) => {
                // Find all MAKER trades matching our client_order_id
                // Filter out taker fills (market orders) to only get limit order fills
                let matching_trades: Vec<_> = trades
                    .iter()
                    .filter(|t| {
                        t.client_order_id.as_deref() == Some(client_order_id) &&
                        t.event_type == "fulfill_maker"
                    })
                    .collect();

                if !matching_trades.is_empty() {
                    log_fn(&format!(
                        "✓ Found {} matching Pacifica trade(s)",
                        matching_trades.len()
                    ));

                    result = calculate_pacifica_trade_result(&matching_trades);
                    break; // Found the trade, exit retry loop
                } else {
                    log_fn("⚠ No matching Pacifica trades found yet");

                    if attempt < max_attempts {
                        log_fn("Waiting 10 seconds before retry...");
                        tokio::time::sleep(Duration::from_secs(10)).await;
                    }
                }
            }
            Err(e) => {
                log_fn(&format!("✗ Failed to fetch Pacifica trade history: {}", e));

                if attempt < max_attempts {
                    log_fn("Waiting 10 seconds before retry...");
                    tokio::time::sleep(Duration::from_secs(10)).await;
                }
            }
        }

        attempt += 1;
    }

    result
}

/// Calculate weighted average price and total fees from Pacifica trades
pub fn calculate_pacifica_trade_result(trades: &[&TradeHistoryItem]) -> TradeFetchResult {
    if trades.len() == 1 {
        // Single fill
        let price = trades[0].entry_price.parse::<f64>().ok();
        let size = trades[0].amount.parse::<f64>().ok();
        let notional = match (price, size) {
            (Some(p), Some(s)) => Some(p * s),
            _ => None,
        };

        TradeFetchResult {
            fill_price: price,
            actual_fee: trades[0].fee.parse().ok(),
            total_size: size,
            total_notional: notional,
        }
    } else {
        // Multiple fills with same client_order_id
        // BUGFIX: Pacifica API sometimes reports wrong entry_price for "close" side trades
        // For fills with the same client_order_id and timestamp, use the price from the FIRST fill
        // (which is typically the "open" side trade with the correct limit order price)

        // Get the reference price from the first fill
        let reference_price = trades[0].entry_price.parse::<f64>().ok();

        let mut total_notional = 0.0;
        let mut total_size = 0.0;
        let mut total_fee = 0.0;

        if let Some(ref_price) = reference_price {
            // Use the same price for all fills (they came from the same limit order)
            for trade in trades {
                if let Ok(size) = trade.amount.parse::<f64>() {
                    total_notional += ref_price * size;
                    total_size += size;
                }
                if let Ok(fee) = trade.fee.parse::<f64>() {
                    total_fee += fee;
                }
            }
        }

        TradeFetchResult {
            fill_price: reference_price,
            actual_fee: if total_fee > 0.0 {
                Some(total_fee)
            } else {
                None
            },
            total_size: if total_size > 0.0 {
                Some(total_size)
            } else {
                None
            },
            total_notional: if total_notional > 0.0 {
                Some(total_notional)
            } else {
                None
            },
        }
    }
}

/// Fetch Hyperliquid user fills with retry logic
///
/// Attempts to find recent fills for the given symbol.
/// Retries up to max_attempts times with 10-second delays between attempts.
///
/// Returns: (fill_price, actual_fee)
pub async fn fetch_hyperliquid_fills(
    trading: &HyperliquidTrading,
    wallet: &str,
    symbol: &str,
    max_attempts: u32,
    time_window_secs: u64,
    log_fn: impl Fn(&str),
) -> TradeFetchResult {
    let mut attempt = 1;
    let mut result = TradeFetchResult {
        fill_price: None,
        actual_fee: None,
        total_size: None,
        total_notional: None,
    };

    while attempt <= max_attempts {
        log_fn(&format!(
            "Fetching Hyperliquid fills (attempt {}/{})",
            attempt, max_attempts
        ));

        match trading.get_user_fills(wallet, true).await {
            Ok(fills) => {
                // Find recent fills for this symbol
                let now = chrono::Utc::now().timestamp_millis() as u64;
                let time_window_ms = time_window_secs * 1000;

                let recent_fills: Vec<_> = fills
                    .iter()
                    .filter(|f| {
                        f.coin == symbol && now.saturating_sub(f.time) < time_window_ms
                    })
                    .collect();

                if !recent_fills.is_empty() {
                    log_fn(&format!(
                        "✓ Found {} matching Hyperliquid fill(s)",
                        recent_fills.len()
                    ));

                    result = calculate_hyperliquid_fill_result(&recent_fills);
                    break; // Found the fills, exit retry loop
                } else {
                    log_fn("⚠ No matching Hyperliquid fills found yet");

                    if attempt < max_attempts {
                        log_fn("Waiting 10 seconds before retry...");
                        tokio::time::sleep(Duration::from_secs(10)).await;
                    }
                }
            }
            Err(e) => {
                log_fn(&format!("✗ Failed to fetch Hyperliquid fills: {}", e));

                if attempt < max_attempts {
                    log_fn("Waiting 10 seconds before retry...");
                    tokio::time::sleep(Duration::from_secs(10)).await;
                }
            }
        }

        attempt += 1;
    }

    result
}

/// Calculate weighted average price and total fees from Hyperliquid fills
pub fn calculate_hyperliquid_fill_result(fills: &[&UserFill]) -> TradeFetchResult {
    if fills.len() == 1 {
        // Single fill
        let price = fills[0].px.parse::<f64>().ok();
        let size = fills[0].sz.parse::<f64>().ok();
        let notional = match (price, size) {
            (Some(p), Some(s)) => Some(p * s),
            _ => None,
        };

        TradeFetchResult {
            fill_price: price,
            actual_fee: fills[0].fee.parse().ok(),
            total_size: size,
            total_notional: notional,
        }
    } else {
        // Multiple fills - calculate weighted average and sum fees
        let mut total_notional = 0.0;
        let mut total_size = 0.0;
        let mut total_fee = 0.0;

        for fill in fills {
            if let (Ok(price), Ok(size)) = (fill.px.parse::<f64>(), fill.sz.parse::<f64>()) {
                total_notional += price * size;
                total_size += size;
            }
            if let Ok(fee) = fill.fee.parse::<f64>() {
                total_fee += fee;
            }
        }

        TradeFetchResult {
            fill_price: if total_size > 0.0 {
                Some(total_notional / total_size)
            } else {
                None
            },
            actual_fee: if total_fee > 0.0 {
                Some(total_fee)
            } else {
                None
            },
            total_size: if total_size > 0.0 {
                Some(total_size)
            } else {
                None
            },
            total_notional: if total_notional > 0.0 {
                Some(total_notional)
            } else {
                None
            },
        }
    }
}


================================================================================
FILE: src\util\cancel.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\util\cancel.rs
================================================================================

use anyhow::Result;
use crate::connector::pacifica::{PacificaTrading, PacificaWsTrading};

/// Performs dual cancellation (REST + WebSocket) for redundancy
///
/// This function attempts to cancel orders via both REST API and WebSocket
/// to maximize the chance of successful cancellation. Both methods are attempted
/// regardless of individual failures.
///
/// # Arguments
/// * `rest` - REST API trading client
/// * `ws` - WebSocket trading client
/// * `symbol` - Symbol to cancel orders for
///
/// # Returns
/// * `Ok((rest_count, ws_count))` - Number of orders cancelled by each method
pub async fn dual_cancel(
    rest: &PacificaTrading,
    ws: &PacificaWsTrading,
    symbol: &str,
) -> Result<(u32, u32)> {
    // REST API cancel (fast, reliable)
    let rest_count = match rest.cancel_all_orders(false, Some(symbol), false).await {
        Ok(count) => count,
        Err(e) => {
            tracing::warn!("REST cancel_all_orders failed: {}", e);
            0
        }
    };

    // WebSocket cancel (ultra-fast, no rate limits)
    let ws_count = match ws.cancel_all_orders_ws(false, Some(symbol), false).await {
        Ok(count) => count,
        Err(e) => {
            tracing::warn!("WS cancel_all_orders_ws failed: {}", e);
            0
        }
    };

    Ok((rest_count, ws_count))
}


================================================================================
FILE: src\util\mod.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\util\mod.rs
================================================================================

/// Utility modules

pub mod cancel;
pub mod rate_limit;


================================================================================
FILE: src\util\rate_limit.rs
PATH: C:\Users\david\Desktop\freqtrade\XEMM\XEMM_CROSS_EXCHANGE_MARKET_MAKING_PACIFICA_HYPERLIQUID\src\util\rate_limit.rs
================================================================================

use std::time::{Duration, Instant};

/// Rate limit tracker for exponential backoff
#[derive(Debug)]
pub struct RateLimitTracker {
    last_error_time: Option<Instant>,
    consecutive_errors: u32,
}

impl RateLimitTracker {
    /// Create a new rate limit tracker
    pub fn new() -> Self {
        Self {
            last_error_time: None,
            consecutive_errors: 0,
        }
    }

    /// Record a rate limit error
    pub fn record_error(&mut self) {
        self.last_error_time = Some(Instant::now());
        self.consecutive_errors += 1;
    }

    /// Record a successful API call
    pub fn record_success(&mut self) {
        self.last_error_time = None;
        self.consecutive_errors = 0;
    }

    /// Get current backoff duration in seconds (exponential: 1, 2, 4, 8, 16, 32 max)
    pub fn get_backoff_secs(&self) -> u64 {
        if self.consecutive_errors == 0 {
            return 0;
        }
        std::cmp::min(2u64.pow(self.consecutive_errors - 1), 32)
    }

    /// Check if we should skip this operation due to active backoff
    pub fn should_skip(&self) -> bool {
        if let Some(last_error) = self.last_error_time {
            let backoff_duration = Duration::from_secs(self.get_backoff_secs());
            last_error.elapsed() < backoff_duration
        } else {
            false
        }
    }

    /// Get remaining backoff time in seconds
    pub fn remaining_backoff_secs(&self) -> f64 {
        if let Some(last_error) = self.last_error_time {
            let backoff_duration = Duration::from_secs(self.get_backoff_secs());
            let elapsed = last_error.elapsed();
            if elapsed < backoff_duration {
                (backoff_duration - elapsed).as_secs_f64()
            } else {
                0.0
            }
        } else {
            0.0
        }
    }

    /// Get the number of consecutive errors
    pub fn consecutive_errors(&self) -> u32 {
        self.consecutive_errors
    }
}

impl Default for RateLimitTracker {
    fn default() -> Self {
        Self::new()
    }
}

/// Check if an error is a rate limit error
pub fn is_rate_limit_error(error: &anyhow::Error) -> bool {
    let error_string = error.to_string().to_lowercase();
    error_string.contains("rate limit")
        || error_string.contains("too many requests")
        || error_string.contains("429")
}

